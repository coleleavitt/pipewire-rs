/* automatically generated by rust-bindgen 0.71.1 */

pub const __GENTOO_NOT_FREESTANDING: u32 = 1;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const _INTTYPES_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC23: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_TIME_BITS64: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const __GLIBC_USE_C23_STRTOL: u32 = 0;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 40;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C23: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C23: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const _BITS_STDINT_LEAST_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const ____gwchar_t_defined: u32 = 1;
pub const __PRI64_PREFIX: &[u8; 2] = b"l\0";
pub const __PRIPTR_PREFIX: &[u8; 2] = b"l\0";
pub const PRId8: &[u8; 2] = b"d\0";
pub const PRId16: &[u8; 2] = b"d\0";
pub const PRId32: &[u8; 2] = b"d\0";
pub const PRId64: &[u8; 3] = b"ld\0";
pub const PRIdLEAST8: &[u8; 2] = b"d\0";
pub const PRIdLEAST16: &[u8; 2] = b"d\0";
pub const PRIdLEAST32: &[u8; 2] = b"d\0";
pub const PRIdLEAST64: &[u8; 3] = b"ld\0";
pub const PRIdFAST8: &[u8; 2] = b"d\0";
pub const PRIdFAST16: &[u8; 3] = b"ld\0";
pub const PRIdFAST32: &[u8; 3] = b"ld\0";
pub const PRIdFAST64: &[u8; 3] = b"ld\0";
pub const PRIi8: &[u8; 2] = b"i\0";
pub const PRIi16: &[u8; 2] = b"i\0";
pub const PRIi32: &[u8; 2] = b"i\0";
pub const PRIi64: &[u8; 3] = b"li\0";
pub const PRIiLEAST8: &[u8; 2] = b"i\0";
pub const PRIiLEAST16: &[u8; 2] = b"i\0";
pub const PRIiLEAST32: &[u8; 2] = b"i\0";
pub const PRIiLEAST64: &[u8; 3] = b"li\0";
pub const PRIiFAST8: &[u8; 2] = b"i\0";
pub const PRIiFAST16: &[u8; 3] = b"li\0";
pub const PRIiFAST32: &[u8; 3] = b"li\0";
pub const PRIiFAST64: &[u8; 3] = b"li\0";
pub const PRIo8: &[u8; 2] = b"o\0";
pub const PRIo16: &[u8; 2] = b"o\0";
pub const PRIo32: &[u8; 2] = b"o\0";
pub const PRIo64: &[u8; 3] = b"lo\0";
pub const PRIoLEAST8: &[u8; 2] = b"o\0";
pub const PRIoLEAST16: &[u8; 2] = b"o\0";
pub const PRIoLEAST32: &[u8; 2] = b"o\0";
pub const PRIoLEAST64: &[u8; 3] = b"lo\0";
pub const PRIoFAST8: &[u8; 2] = b"o\0";
pub const PRIoFAST16: &[u8; 3] = b"lo\0";
pub const PRIoFAST32: &[u8; 3] = b"lo\0";
pub const PRIoFAST64: &[u8; 3] = b"lo\0";
pub const PRIu8: &[u8; 2] = b"u\0";
pub const PRIu16: &[u8; 2] = b"u\0";
pub const PRIu32: &[u8; 2] = b"u\0";
pub const PRIu64: &[u8; 3] = b"lu\0";
pub const PRIuLEAST8: &[u8; 2] = b"u\0";
pub const PRIuLEAST16: &[u8; 2] = b"u\0";
pub const PRIuLEAST32: &[u8; 2] = b"u\0";
pub const PRIuLEAST64: &[u8; 3] = b"lu\0";
pub const PRIuFAST8: &[u8; 2] = b"u\0";
pub const PRIuFAST16: &[u8; 3] = b"lu\0";
pub const PRIuFAST32: &[u8; 3] = b"lu\0";
pub const PRIuFAST64: &[u8; 3] = b"lu\0";
pub const PRIx8: &[u8; 2] = b"x\0";
pub const PRIx16: &[u8; 2] = b"x\0";
pub const PRIx32: &[u8; 2] = b"x\0";
pub const PRIx64: &[u8; 3] = b"lx\0";
pub const PRIxLEAST8: &[u8; 2] = b"x\0";
pub const PRIxLEAST16: &[u8; 2] = b"x\0";
pub const PRIxLEAST32: &[u8; 2] = b"x\0";
pub const PRIxLEAST64: &[u8; 3] = b"lx\0";
pub const PRIxFAST8: &[u8; 2] = b"x\0";
pub const PRIxFAST16: &[u8; 3] = b"lx\0";
pub const PRIxFAST32: &[u8; 3] = b"lx\0";
pub const PRIxFAST64: &[u8; 3] = b"lx\0";
pub const PRIX8: &[u8; 2] = b"X\0";
pub const PRIX16: &[u8; 2] = b"X\0";
pub const PRIX32: &[u8; 2] = b"X\0";
pub const PRIX64: &[u8; 3] = b"lX\0";
pub const PRIXLEAST8: &[u8; 2] = b"X\0";
pub const PRIXLEAST16: &[u8; 2] = b"X\0";
pub const PRIXLEAST32: &[u8; 2] = b"X\0";
pub const PRIXLEAST64: &[u8; 3] = b"lX\0";
pub const PRIXFAST8: &[u8; 2] = b"X\0";
pub const PRIXFAST16: &[u8; 3] = b"lX\0";
pub const PRIXFAST32: &[u8; 3] = b"lX\0";
pub const PRIXFAST64: &[u8; 3] = b"lX\0";
pub const PRIdMAX: &[u8; 3] = b"ld\0";
pub const PRIiMAX: &[u8; 3] = b"li\0";
pub const PRIoMAX: &[u8; 3] = b"lo\0";
pub const PRIuMAX: &[u8; 3] = b"lu\0";
pub const PRIxMAX: &[u8; 3] = b"lx\0";
pub const PRIXMAX: &[u8; 3] = b"lX\0";
pub const PRIdPTR: &[u8; 3] = b"ld\0";
pub const PRIiPTR: &[u8; 3] = b"li\0";
pub const PRIoPTR: &[u8; 3] = b"lo\0";
pub const PRIuPTR: &[u8; 3] = b"lu\0";
pub const PRIxPTR: &[u8; 3] = b"lx\0";
pub const PRIXPTR: &[u8; 3] = b"lX\0";
pub const SCNd8: &[u8; 4] = b"hhd\0";
pub const SCNd16: &[u8; 3] = b"hd\0";
pub const SCNd32: &[u8; 2] = b"d\0";
pub const SCNd64: &[u8; 3] = b"ld\0";
pub const SCNdLEAST8: &[u8; 4] = b"hhd\0";
pub const SCNdLEAST16: &[u8; 3] = b"hd\0";
pub const SCNdLEAST32: &[u8; 2] = b"d\0";
pub const SCNdLEAST64: &[u8; 3] = b"ld\0";
pub const SCNdFAST8: &[u8; 4] = b"hhd\0";
pub const SCNdFAST16: &[u8; 3] = b"ld\0";
pub const SCNdFAST32: &[u8; 3] = b"ld\0";
pub const SCNdFAST64: &[u8; 3] = b"ld\0";
pub const SCNi8: &[u8; 4] = b"hhi\0";
pub const SCNi16: &[u8; 3] = b"hi\0";
pub const SCNi32: &[u8; 2] = b"i\0";
pub const SCNi64: &[u8; 3] = b"li\0";
pub const SCNiLEAST8: &[u8; 4] = b"hhi\0";
pub const SCNiLEAST16: &[u8; 3] = b"hi\0";
pub const SCNiLEAST32: &[u8; 2] = b"i\0";
pub const SCNiLEAST64: &[u8; 3] = b"li\0";
pub const SCNiFAST8: &[u8; 4] = b"hhi\0";
pub const SCNiFAST16: &[u8; 3] = b"li\0";
pub const SCNiFAST32: &[u8; 3] = b"li\0";
pub const SCNiFAST64: &[u8; 3] = b"li\0";
pub const SCNu8: &[u8; 4] = b"hhu\0";
pub const SCNu16: &[u8; 3] = b"hu\0";
pub const SCNu32: &[u8; 2] = b"u\0";
pub const SCNu64: &[u8; 3] = b"lu\0";
pub const SCNuLEAST8: &[u8; 4] = b"hhu\0";
pub const SCNuLEAST16: &[u8; 3] = b"hu\0";
pub const SCNuLEAST32: &[u8; 2] = b"u\0";
pub const SCNuLEAST64: &[u8; 3] = b"lu\0";
pub const SCNuFAST8: &[u8; 4] = b"hhu\0";
pub const SCNuFAST16: &[u8; 3] = b"lu\0";
pub const SCNuFAST32: &[u8; 3] = b"lu\0";
pub const SCNuFAST64: &[u8; 3] = b"lu\0";
pub const SCNo8: &[u8; 4] = b"hho\0";
pub const SCNo16: &[u8; 3] = b"ho\0";
pub const SCNo32: &[u8; 2] = b"o\0";
pub const SCNo64: &[u8; 3] = b"lo\0";
pub const SCNoLEAST8: &[u8; 4] = b"hho\0";
pub const SCNoLEAST16: &[u8; 3] = b"ho\0";
pub const SCNoLEAST32: &[u8; 2] = b"o\0";
pub const SCNoLEAST64: &[u8; 3] = b"lo\0";
pub const SCNoFAST8: &[u8; 4] = b"hho\0";
pub const SCNoFAST16: &[u8; 3] = b"lo\0";
pub const SCNoFAST32: &[u8; 3] = b"lo\0";
pub const SCNoFAST64: &[u8; 3] = b"lo\0";
pub const SCNx8: &[u8; 4] = b"hhx\0";
pub const SCNx16: &[u8; 3] = b"hx\0";
pub const SCNx32: &[u8; 2] = b"x\0";
pub const SCNx64: &[u8; 3] = b"lx\0";
pub const SCNxLEAST8: &[u8; 4] = b"hhx\0";
pub const SCNxLEAST16: &[u8; 3] = b"hx\0";
pub const SCNxLEAST32: &[u8; 2] = b"x\0";
pub const SCNxLEAST64: &[u8; 3] = b"lx\0";
pub const SCNxFAST8: &[u8; 4] = b"hhx\0";
pub const SCNxFAST16: &[u8; 3] = b"lx\0";
pub const SCNxFAST32: &[u8; 3] = b"lx\0";
pub const SCNxFAST64: &[u8; 3] = b"lx\0";
pub const SCNdMAX: &[u8; 3] = b"ld\0";
pub const SCNiMAX: &[u8; 3] = b"li\0";
pub const SCNoMAX: &[u8; 3] = b"lo\0";
pub const SCNuMAX: &[u8; 3] = b"lu\0";
pub const SCNxMAX: &[u8; 3] = b"lx\0";
pub const SCNdPTR: &[u8; 3] = b"ld\0";
pub const SCNiPTR: &[u8; 3] = b"li\0";
pub const SCNoPTR: &[u8; 3] = b"lo\0";
pub const SCNuPTR: &[u8; 3] = b"lu\0";
pub const SCNxPTR: &[u8; 3] = b"lx\0";
pub const _BITS_SIGNUM_GENERIC_H: u32 = 1;
pub const SIGINT: u32 = 2;
pub const SIGILL: u32 = 4;
pub const SIGABRT: u32 = 6;
pub const SIGFPE: u32 = 8;
pub const SIGSEGV: u32 = 11;
pub const SIGTERM: u32 = 15;
pub const SIGHUP: u32 = 1;
pub const SIGQUIT: u32 = 3;
pub const SIGTRAP: u32 = 5;
pub const SIGKILL: u32 = 9;
pub const SIGPIPE: u32 = 13;
pub const SIGALRM: u32 = 14;
pub const SIGIOT: u32 = 6;
pub const _BITS_SIGNUM_ARCH_H: u32 = 1;
pub const SIGSTKFLT: u32 = 16;
pub const SIGPWR: u32 = 30;
pub const SIGBUS: u32 = 7;
pub const SIGSYS: u32 = 31;
pub const SIGURG: u32 = 23;
pub const SIGSTOP: u32 = 19;
pub const SIGTSTP: u32 = 20;
pub const SIGCONT: u32 = 18;
pub const SIGCHLD: u32 = 17;
pub const SIGTTIN: u32 = 21;
pub const SIGTTOU: u32 = 22;
pub const SIGPOLL: u32 = 29;
pub const SIGXFSZ: u32 = 25;
pub const SIGXCPU: u32 = 24;
pub const SIGVTALRM: u32 = 26;
pub const SIGPROF: u32 = 27;
pub const SIGUSR1: u32 = 10;
pub const SIGUSR2: u32 = 12;
pub const SIGWINCH: u32 = 28;
pub const SIGIO: u32 = 29;
pub const SIGCLD: u32 = 17;
pub const __SIGRTMIN: u32 = 32;
pub const __SIGRTMAX: u32 = 64;
pub const _NSIG: u32 = 65;
pub const __sig_atomic_t_defined: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const __time_t_defined: u32 = 1;
pub const __siginfo_t_defined: u32 = 1;
pub const __SI_MAX_SIZE: u32 = 128;
pub const _BITS_SIGINFO_ARCH_H: u32 = 1;
pub const __SI_ERRNO_THEN_CODE: u32 = 1;
pub const __SI_HAVE_SIGSYS: u32 = 1;
pub const _BITS_SIGINFO_CONSTS_H: u32 = 1;
pub const __SI_ASYNCIO_AFTER_SIGIO: u32 = 1;
pub const __sigevent_t_defined: u32 = 1;
pub const __SIGEV_MAX_SIZE: u32 = 64;
pub const __have_pthread_attr_t: u32 = 1;
pub const _BITS_SIGEVENT_CONSTS_H: u32 = 1;
pub const NSIG: u32 = 65;
pub const _BITS_SIGACTION_H: u32 = 1;
pub const SA_NOCLDSTOP: u32 = 1;
pub const SA_NOCLDWAIT: u32 = 2;
pub const SA_SIGINFO: u32 = 4;
pub const SA_ONSTACK: u32 = 134217728;
pub const SA_RESTART: u32 = 268435456;
pub const SA_NODEFER: u32 = 1073741824;
pub const SA_RESETHAND: u32 = 2147483648;
pub const SA_INTERRUPT: u32 = 536870912;
pub const SA_NOMASK: u32 = 1073741824;
pub const SA_ONESHOT: u32 = 2147483648;
pub const SA_STACK: u32 = 134217728;
pub const SIG_BLOCK: u32 = 0;
pub const SIG_UNBLOCK: u32 = 1;
pub const SIG_SETMASK: u32 = 2;
pub const _BITS_SIGCONTEXT_H: u32 = 1;
pub const FP_XSTATE_MAGIC1: u32 = 1179670611;
pub const FP_XSTATE_MAGIC2: u32 = 1179670597;
pub const __stack_t_defined: u32 = 1;
pub const _SYS_UCONTEXT_H: u32 = 1;
pub const __NGREG: u32 = 23;
pub const NGREG: u32 = 23;
pub const _BITS_SIGSTACK_H: u32 = 1;
pub const MINSIGSTKSZ: u32 = 2048;
pub const SIGSTKSZ: u32 = 8192;
pub const _BITS_SS_FLAGS_H: u32 = 1;
pub const __sigstack_defined: u32 = 1;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const _BITS_SIGTHREAD_H: u32 = 1;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _SYS_TYPES_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _ALLOCA_H: u32 = 1;
pub const _STRING_H: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const _STDIO_H: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const __cookie_io_functions_t_defined: u32 = 1;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &[u8; 5] = b"/tmp\0";
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const SPA_NSEC_PER_SEC: u32 = 1000000000;
pub const SPA_NSEC_PER_MSEC: u32 = 1000000;
pub const SPA_NSEC_PER_USEC: u32 = 1000;
pub const SPA_USEC_PER_SEC: u32 = 1000000;
pub const SPA_USEC_PER_MSEC: u32 = 1000;
pub const SPA_MSEC_PER_SEC: u32 = 1000;
pub const _ERRNO_H: u32 = 1;
pub const _BITS_ERRNO_H: u32 = 1;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const ENOTBLK: u32 = 15;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const EINVAL: u32 = 22;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const ETXTBSY: u32 = 26;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const ERANGE: u32 = 34;
pub const EDEADLK: u32 = 35;
pub const ENAMETOOLONG: u32 = 36;
pub const ENOLCK: u32 = 37;
pub const ENOSYS: u32 = 38;
pub const ENOTEMPTY: u32 = 39;
pub const ELOOP: u32 = 40;
pub const EWOULDBLOCK: u32 = 11;
pub const ENOMSG: u32 = 42;
pub const EIDRM: u32 = 43;
pub const ECHRNG: u32 = 44;
pub const EL2NSYNC: u32 = 45;
pub const EL3HLT: u32 = 46;
pub const EL3RST: u32 = 47;
pub const ELNRNG: u32 = 48;
pub const EUNATCH: u32 = 49;
pub const ENOCSI: u32 = 50;
pub const EL2HLT: u32 = 51;
pub const EBADE: u32 = 52;
pub const EBADR: u32 = 53;
pub const EXFULL: u32 = 54;
pub const ENOANO: u32 = 55;
pub const EBADRQC: u32 = 56;
pub const EBADSLT: u32 = 57;
pub const EDEADLOCK: u32 = 35;
pub const EBFONT: u32 = 59;
pub const ENOSTR: u32 = 60;
pub const ENODATA: u32 = 61;
pub const ETIME: u32 = 62;
pub const ENOSR: u32 = 63;
pub const ENONET: u32 = 64;
pub const ENOPKG: u32 = 65;
pub const EREMOTE: u32 = 66;
pub const ENOLINK: u32 = 67;
pub const EADV: u32 = 68;
pub const ESRMNT: u32 = 69;
pub const ECOMM: u32 = 70;
pub const EPROTO: u32 = 71;
pub const EMULTIHOP: u32 = 72;
pub const EDOTDOT: u32 = 73;
pub const EBADMSG: u32 = 74;
pub const EOVERFLOW: u32 = 75;
pub const ENOTUNIQ: u32 = 76;
pub const EBADFD: u32 = 77;
pub const EREMCHG: u32 = 78;
pub const ELIBACC: u32 = 79;
pub const ELIBBAD: u32 = 80;
pub const ELIBSCN: u32 = 81;
pub const ELIBMAX: u32 = 82;
pub const ELIBEXEC: u32 = 83;
pub const EILSEQ: u32 = 84;
pub const ERESTART: u32 = 85;
pub const ESTRPIPE: u32 = 86;
pub const EUSERS: u32 = 87;
pub const ENOTSOCK: u32 = 88;
pub const EDESTADDRREQ: u32 = 89;
pub const EMSGSIZE: u32 = 90;
pub const EPROTOTYPE: u32 = 91;
pub const ENOPROTOOPT: u32 = 92;
pub const EPROTONOSUPPORT: u32 = 93;
pub const ESOCKTNOSUPPORT: u32 = 94;
pub const EOPNOTSUPP: u32 = 95;
pub const EPFNOSUPPORT: u32 = 96;
pub const EAFNOSUPPORT: u32 = 97;
pub const EADDRINUSE: u32 = 98;
pub const EADDRNOTAVAIL: u32 = 99;
pub const ENETDOWN: u32 = 100;
pub const ENETUNREACH: u32 = 101;
pub const ENETRESET: u32 = 102;
pub const ECONNABORTED: u32 = 103;
pub const ECONNRESET: u32 = 104;
pub const ENOBUFS: u32 = 105;
pub const EISCONN: u32 = 106;
pub const ENOTCONN: u32 = 107;
pub const ESHUTDOWN: u32 = 108;
pub const ETOOMANYREFS: u32 = 109;
pub const ETIMEDOUT: u32 = 110;
pub const ECONNREFUSED: u32 = 111;
pub const EHOSTDOWN: u32 = 112;
pub const EHOSTUNREACH: u32 = 113;
pub const EALREADY: u32 = 114;
pub const EINPROGRESS: u32 = 115;
pub const ESTALE: u32 = 116;
pub const EUCLEAN: u32 = 117;
pub const ENOTNAM: u32 = 118;
pub const ENAVAIL: u32 = 119;
pub const EISNAM: u32 = 120;
pub const EREMOTEIO: u32 = 121;
pub const EDQUOT: u32 = 122;
pub const ENOMEDIUM: u32 = 123;
pub const EMEDIUMTYPE: u32 = 124;
pub const ECANCELED: u32 = 125;
pub const ENOKEY: u32 = 126;
pub const EKEYEXPIRED: u32 = 127;
pub const EKEYREVOKED: u32 = 128;
pub const EKEYREJECTED: u32 = 129;
pub const EOWNERDEAD: u32 = 130;
pub const ENOTRECOVERABLE: u32 = 131;
pub const ERFKILL: u32 = 132;
pub const EHWPOISON: u32 = 133;
pub const ENOTSUP: u32 = 95;
pub const _LOCALE_H: u32 = 1;
pub const _BITS_LOCALE_H: u32 = 1;
pub const __LC_CTYPE: u32 = 0;
pub const __LC_NUMERIC: u32 = 1;
pub const __LC_TIME: u32 = 2;
pub const __LC_COLLATE: u32 = 3;
pub const __LC_MONETARY: u32 = 4;
pub const __LC_MESSAGES: u32 = 5;
pub const __LC_ALL: u32 = 6;
pub const __LC_PAPER: u32 = 7;
pub const __LC_NAME: u32 = 8;
pub const __LC_ADDRESS: u32 = 9;
pub const __LC_TELEPHONE: u32 = 10;
pub const __LC_MEASUREMENT: u32 = 11;
pub const __LC_IDENTIFICATION: u32 = 12;
pub const LC_CTYPE: u32 = 0;
pub const LC_NUMERIC: u32 = 1;
pub const LC_TIME: u32 = 2;
pub const LC_COLLATE: u32 = 3;
pub const LC_MONETARY: u32 = 4;
pub const LC_MESSAGES: u32 = 5;
pub const LC_ALL: u32 = 6;
pub const LC_PAPER: u32 = 7;
pub const LC_NAME: u32 = 8;
pub const LC_ADDRESS: u32 = 9;
pub const LC_TELEPHONE: u32 = 10;
pub const LC_MEASUREMENT: u32 = 11;
pub const LC_IDENTIFICATION: u32 = 12;
pub const LC_CTYPE_MASK: u32 = 1;
pub const LC_NUMERIC_MASK: u32 = 2;
pub const LC_TIME_MASK: u32 = 4;
pub const LC_COLLATE_MASK: u32 = 8;
pub const LC_MONETARY_MASK: u32 = 16;
pub const LC_MESSAGES_MASK: u32 = 32;
pub const LC_PAPER_MASK: u32 = 128;
pub const LC_NAME_MASK: u32 = 256;
pub const LC_ADDRESS_MASK: u32 = 512;
pub const LC_TELEPHONE_MASK: u32 = 1024;
pub const LC_MEASUREMENT_MASK: u32 = 2048;
pub const LC_IDENTIFICATION_MASK: u32 = 4096;
pub const LC_ALL_MASK: u32 = 8127;
pub const SPA_TYPE_INFO_BASE: &[u8; 5] = b"Spa:\0";
pub const SPA_TYPE_INFO_Flags: &[u8; 10] = b"Spa:Flags\0";
pub const SPA_TYPE_INFO_FLAGS_BASE: &[u8; 11] = b"Spa:Flags:\0";
pub const SPA_TYPE_INFO_Enum: &[u8; 9] = b"Spa:Enum\0";
pub const SPA_TYPE_INFO_ENUM_BASE: &[u8; 10] = b"Spa:Enum:\0";
pub const SPA_TYPE_INFO_Pod: &[u8; 8] = b"Spa:Pod\0";
pub const SPA_TYPE_INFO_POD_BASE: &[u8; 9] = b"Spa:Pod:\0";
pub const SPA_TYPE_INFO_Struct: &[u8; 15] = b"Spa:Pod:Struct\0";
pub const SPA_TYPE_INFO_STRUCT_BASE: &[u8; 16] = b"Spa:Pod:Struct:\0";
pub const SPA_TYPE_INFO_Object: &[u8; 15] = b"Spa:Pod:Object\0";
pub const SPA_TYPE_INFO_OBJECT_BASE: &[u8; 16] = b"Spa:Pod:Object:\0";
pub const SPA_TYPE_INFO_Pointer: &[u8; 12] = b"Spa:Pointer\0";
pub const SPA_TYPE_INFO_POINTER_BASE: &[u8; 13] = b"Spa:Pointer:\0";
pub const SPA_TYPE_INFO_Interface: &[u8; 22] = b"Spa:Pointer:Interface\0";
pub const SPA_TYPE_INFO_INTERFACE_BASE: &[u8; 23] = b"Spa:Pointer:Interface:\0";
pub const SPA_TYPE_INFO_Event: &[u8; 21] = b"Spa:Pod:Object:Event\0";
pub const SPA_TYPE_INFO_EVENT_BASE: &[u8; 22] = b"Spa:Pod:Object:Event:\0";
pub const SPA_TYPE_INFO_Command: &[u8; 23] = b"Spa:Pod:Object:Command\0";
pub const SPA_TYPE_INFO_COMMAND_BASE: &[u8; 24] = b"Spa:Pod:Object:Command:\0";
pub const SPA_POD_PROP_FLAG_READONLY: u32 = 1;
pub const SPA_POD_PROP_FLAG_HARDWARE: u32 = 2;
pub const SPA_POD_PROP_FLAG_HINT_DICT: u32 = 4;
pub const SPA_POD_PROP_FLAG_MANDATORY: u32 = 8;
pub const SPA_POD_PROP_FLAG_DONT_FIXATE: u32 = 16;
pub const SPA_META_HEADER_FLAG_DISCONT: u32 = 1;
pub const SPA_META_HEADER_FLAG_CORRUPTED: u32 = 2;
pub const SPA_META_HEADER_FLAG_MARKER: u32 = 4;
pub const SPA_META_HEADER_FLAG_HEADER: u32 = 8;
pub const SPA_META_HEADER_FLAG_GAP: u32 = 16;
pub const SPA_META_HEADER_FLAG_DELTA_UNIT: u32 = 32;
pub const SPA_CHUNK_FLAG_NONE: u32 = 0;
pub const SPA_CHUNK_FLAG_CORRUPTED: u32 = 1;
pub const SPA_CHUNK_FLAG_EMPTY: u32 = 2;
pub const SPA_DATA_FLAG_NONE: u32 = 0;
pub const SPA_DATA_FLAG_READABLE: u32 = 1;
pub const SPA_DATA_FLAG_WRITABLE: u32 = 2;
pub const SPA_DATA_FLAG_DYNAMIC: u32 = 4;
pub const SPA_DATA_FLAG_READWRITE: u32 = 3;
pub const SPA_DATA_FLAG_MAPPABLE: u32 = 8;
pub const SPA_BUFFER_ALLOC_FLAG_INLINE_META: u32 = 1;
pub const SPA_BUFFER_ALLOC_FLAG_INLINE_CHUNK: u32 = 2;
pub const SPA_BUFFER_ALLOC_FLAG_INLINE_DATA: u32 = 4;
pub const SPA_BUFFER_ALLOC_FLAG_INLINE_ALL: u32 = 7;
pub const SPA_BUFFER_ALLOC_FLAG_NO_DATA: u32 = 8;
pub const SPA_TYPE_INFO_Buffer: &[u8; 19] = b"Spa:Pointer:Buffer\0";
pub const SPA_TYPE_INFO_BUFFER_BASE: &[u8; 20] = b"Spa:Pointer:Buffer:\0";
pub const SPA_TYPE_INFO_Data: &[u8; 14] = b"Spa:Enum:Data\0";
pub const SPA_TYPE_INFO_DATA_BASE: &[u8; 15] = b"Spa:Enum:Data:\0";
pub const SPA_TYPE_INFO_DATA_Fd: &[u8; 17] = b"Spa:Enum:Data:Fd\0";
pub const SPA_TYPE_INFO_DATA_FD_BASE: &[u8; 18] = b"Spa:Enum:Data:Fd:\0";
pub const SPA_TYPE_INFO_Meta: &[u8; 17] = b"Spa:Pointer:Meta\0";
pub const SPA_TYPE_INFO_META_BASE: &[u8; 18] = b"Spa:Pointer:Meta:\0";
pub const SPA_TYPE_INFO_META_Array: &[u8; 23] = b"Spa:Pointer:Meta:Array\0";
pub const SPA_TYPE_INFO_META_ARRAY_BASE: &[u8; 24] = b"Spa:Pointer:Meta:Array:\0";
pub const SPA_TYPE_INFO_META_Region: &[u8; 24] = b"Spa:Pointer:Meta:Region\0";
pub const SPA_TYPE_INFO_META_REGION_BASE: &[u8; 25] = b"Spa:Pointer:Meta:Region:\0";
pub const SPA_TYPE_INFO_META_ARRAY_Region: &[u8; 30] = b"Spa:Pointer:Meta:Array:Region\0";
pub const SPA_TYPE_INFO_META_ARRAY_REGION_BASE: &[u8; 31] = b"Spa:Pointer:Meta:Array:Region:\0";
pub const SPA_TYPE_INFO_META_Transformation: &[u8; 29] = b"Spa:Enum:Meta:Transformation\0";
pub const SPA_TYPE_INFO_META_TRANSFORMATION_BASE: &[u8; 30] = b"Spa:Enum:Meta:Transformation:\0";
pub const SPA_TYPE_INFO_Control: &[u8; 17] = b"Spa:Enum:Control\0";
pub const SPA_TYPE_INFO_CONTROL_BASE: &[u8; 18] = b"Spa:Enum:Control:\0";
pub const _CTYPE_H: u32 = 1;
pub const SPA_TYPE_INFO_Direction: &[u8; 19] = b"Spa:Enum:Direction\0";
pub const SPA_TYPE_INFO_DIRECTION_BASE: &[u8; 20] = b"Spa:Enum:Direction:\0";
pub const SPA_TYPE_INFO_Choice: &[u8; 16] = b"Spa:Enum:Choice\0";
pub const SPA_TYPE_INFO_CHOICE_BASE: &[u8; 17] = b"Spa:Enum:Choice:\0";
pub const SPA_TYPE_INFO_DeviceEvent: &[u8; 28] = b"Spa:Pod:Object:Event:Device\0";
pub const SPA_TYPE_INFO_DEVICE_EVENT_BASE: &[u8; 29] = b"Spa:Pod:Object:Event:Device:\0";
pub const SPA_TYPE_INFO_DeviceEventId: &[u8; 23] = b"Spa:Enum:DeviceEventId\0";
pub const SPA_TYPE_INFO_DEVICE_EVENT_ID_BASE: &[u8; 24] = b"Spa:Enum:DeviceEventId:\0";
pub const SPA_STATUS_OK: u32 = 0;
pub const SPA_STATUS_NEED_DATA: u32 = 1;
pub const SPA_STATUS_HAVE_DATA: u32 = 2;
pub const SPA_STATUS_STOPPED: u32 = 4;
pub const SPA_STATUS_DRAINED: u32 = 8;
pub const SPA_IO_CLOCK_FLAG_FREEWHEEL: u32 = 1;
pub const SPA_IO_CLOCK_FLAG_XRUN_RECOVER: u32 = 2;
pub const SPA_IO_CLOCK_FLAG_LAZY: u32 = 4;
pub const SPA_IO_CLOCK_FLAG_NO_RATE: u32 = 8;
pub const SPA_IO_VIDEO_SIZE_VALID: u32 = 1;
pub const SPA_IO_SEGMENT_BAR_FLAG_VALID: u32 = 1;
pub const SPA_IO_SEGMENT_VIDEO_FLAG_VALID: u32 = 1;
pub const SPA_IO_SEGMENT_VIDEO_FLAG_DROP_FRAME: u32 = 2;
pub const SPA_IO_SEGMENT_VIDEO_FLAG_PULL_DOWN: u32 = 4;
pub const SPA_IO_SEGMENT_VIDEO_FLAG_INTERLACED: u32 = 8;
pub const SPA_IO_SEGMENT_FLAG_LOOPING: u32 = 1;
pub const SPA_IO_SEGMENT_FLAG_NO_POSITION: u32 = 2;
pub const SPA_IO_POSITION_MAX_SEGMENTS: u32 = 8;
pub const SPA_IO_RATE_MATCH_FLAG_ACTIVE: u32 = 1;
pub const SPA_TYPE_INFO_IO: &[u8; 12] = b"Spa:Enum:IO\0";
pub const SPA_TYPE_INFO_IO_BASE: &[u8; 13] = b"Spa:Enum:IO:\0";
pub const SPA_TYPE_INFO_NodeEvent: &[u8; 26] = b"Spa:Pod:Object:Event:Node\0";
pub const SPA_TYPE_INFO_NODE_EVENT_BASE: &[u8; 27] = b"Spa:Pod:Object:Event:Node:\0";
pub const SPA_TYPE_INFO_NodeCommand: &[u8; 28] = b"Spa:Pod:Object:Command:Node\0";
pub const SPA_TYPE_INFO_NODE_COMMAND_BASE: &[u8; 29] = b"Spa:Pod:Object:Command:Node:\0";
pub const SPA_PARAM_INFO_SERIAL: u32 = 1;
pub const SPA_PARAM_INFO_READ: u32 = 2;
pub const SPA_PARAM_INFO_WRITE: u32 = 4;
pub const SPA_PARAM_INFO_READWRITE: u32 = 6;
pub const SPA_KEY_FORMAT_DSP: &[u8; 11] = b"format.dsp\0";
pub const SPA_TYPE_INFO_ParamId: &[u8; 17] = b"Spa:Enum:ParamId\0";
pub const SPA_TYPE_INFO_PARAM_ID_BASE: &[u8; 18] = b"Spa:Enum:ParamId:\0";
pub const SPA_TYPE_INFO_Param: &[u8; 21] = b"Spa:Pod:Object:Param\0";
pub const SPA_TYPE_INFO_PARAM_BASE: &[u8; 22] = b"Spa:Pod:Object:Param:\0";
pub const _BYTESWAP_H: u32 = 1;
pub const SPA_AUDIO_MAX_CHANNELS: u32 = 64;
pub const SPA_AUDIO_FLAG_NONE: u32 = 0;
pub const SPA_AUDIO_FLAG_UNPOSITIONED: u32 = 1;
pub const SPA_KEY_AUDIO_FORMAT: &[u8; 13] = b"audio.format\0";
pub const SPA_KEY_AUDIO_CHANNEL: &[u8; 14] = b"audio.channel\0";
pub const SPA_KEY_AUDIO_CHANNELS: &[u8; 15] = b"audio.channels\0";
pub const SPA_KEY_AUDIO_RATE: &[u8; 11] = b"audio.rate\0";
pub const SPA_KEY_AUDIO_POSITION: &[u8; 15] = b"audio.position\0";
pub const SPA_KEY_AUDIO_ALLOWED_RATES: &[u8; 20] = b"audio.allowed-rates\0";
pub const SPA_TYPE_INFO_AudioFormat: &[u8; 21] = b"Spa:Enum:AudioFormat\0";
pub const SPA_TYPE_INFO_AUDIO_FORMAT_BASE: &[u8; 22] = b"Spa:Enum:AudioFormat:\0";
pub const SPA_TYPE_INFO_AudioFlags: &[u8; 21] = b"Spa:Flags:AudioFlags\0";
pub const SPA_TYPE_INFO_AUDIO_FLAGS_BASE: &[u8; 22] = b"Spa:Flags:AudioFlags:\0";
pub const SPA_TYPE_INFO_AudioChannel: &[u8; 22] = b"Spa:Enum:AudioChannel\0";
pub const SPA_TYPE_INFO_AUDIO_CHANNEL_BASE: &[u8; 23] = b"Spa:Enum:AudioChannel:\0";
pub const SPA_TYPE_INFO_AudioIEC958Codec: &[u8; 26] = b"Spa:Enum:AudioIEC958Codec\0";
pub const SPA_TYPE_INFO_AUDIO_IEC958_CODEC_BASE: &[u8; 27] = b"Spa:Enum:AudioIEC958Codec:\0";
pub const SPA_TYPE_INFO_AudioMP3ChannelMode: &[u8; 29] = b"Spa:Enum:AudioMP3ChannelMode\0";
pub const SPA_TYPE_INFO_AUDIO_MP3_CHANNEL_MODE_BASE: &[u8; 30] = b"Spa:Enum:AudioMP3ChannelMode:\0";
pub const SPA_TYPE_INFO_AudioAACStreamFormat: &[u8; 30] = b"Spa:Enum:AudioAACStreamFormat\0";
pub const SPA_TYPE_INFO_AUDIO_AAC_STREAM_FORMAT_BASE: &[u8; 31] =
    b"Spa:Enum:AudioAACStreamFormat:\0";
pub const SPA_TYPE_INFO_AudioWMAProfile: &[u8; 25] = b"Spa:Enum:AudioWMAProfile\0";
pub const SPA_TYPE_INFO_AUDIO_WMA_PROFILE_BASE: &[u8; 26] = b"Spa:Enum:AudioWMAProfile:\0";
pub const SPA_TYPE_INFO_AudioAMRBandMode: &[u8; 26] = b"Spa:Enum:AudioAMRBandMode\0";
pub const SPA_TYPE_INFO_AUDIO_AMR_BAND_MODE_BASE: &[u8; 27] = b"Spa:Enum:AudioAMRBandMode:\0";
pub const SPA_TYPE_INFO_ParamBitorder: &[u8; 23] = b"Spa:Enum:ParamBitorder\0";
pub const SPA_TYPE_INFO_PARAM_BITORDER_BASE: &[u8; 24] = b"Spa:Enum:ParamBitorder:\0";
pub const SPA_TYPE_INFO_ParamAvailability: &[u8; 27] = b"Spa:Enum:ParamAvailability\0";
pub const SPA_TYPE_INFO_PARAM_AVAILABILITY_BASE: &[u8; 28] = b"Spa:Enum:ParamAvailability:\0";
pub const SPA_TYPE_INFO_PARAM_Meta: &[u8; 26] = b"Spa:Pod:Object:Param:Meta\0";
pub const SPA_TYPE_INFO_PARAM_META_BASE: &[u8; 27] = b"Spa:Pod:Object:Param:Meta:\0";
pub const SPA_TYPE_INFO_PARAM_IO: &[u8; 24] = b"Spa:Pod:Object:Param:IO\0";
pub const SPA_TYPE_INFO_PARAM_IO_BASE: &[u8; 25] = b"Spa:Pod:Object:Param:IO:\0";
pub const SPA_TYPE_INFO_PARAM_Buffers: &[u8; 29] = b"Spa:Pod:Object:Param:Buffers\0";
pub const SPA_TYPE_INFO_PARAM_BUFFERS_BASE: &[u8; 30] = b"Spa:Pod:Object:Param:Buffers:\0";
pub const SPA_TYPE_INFO_PARAM_BlockInfo: &[u8; 39] = b"Spa:Pod:Object:Param:Buffers:BlockInfo\0";
pub const SPA_TYPE_INFO_PARAM_BLOCK_INFO_BASE: &[u8; 40] =
    b"Spa:Pod:Object:Param:Buffers:BlockInfo:\0";
pub const SPA_TYPE_INFO_BluetoothAudioCodec: &[u8; 29] = b"Spa:Enum:BluetoothAudioCodec\0";
pub const SPA_TYPE_INFO_BLUETOOTH_AUDIO_CODEC_BASE: &[u8; 30] = b"Spa:Enum:BluetoothAudioCodec:\0";
pub const SPA_TYPE_INFO_Props: &[u8; 27] = b"Spa:Pod:Object:Param:Props\0";
pub const SPA_TYPE_INFO_PROPS_BASE: &[u8; 28] = b"Spa:Pod:Object:Param:Props:\0";
pub const SPA_TYPE_INFO_PropInfo: &[u8; 30] = b"Spa:Pod:Object:Param:PropInfo\0";
pub const SPA_TYPE_INFO_PROP_INFO_BASE: &[u8; 31] = b"Spa:Pod:Object:Param:PropInfo:\0";
pub const SPA_VIDEO_MAX_PLANES: u32 = 4;
pub const SPA_VIDEO_MAX_COMPONENTS: u32 = 4;
pub const SPA_TYPE_INFO_VideoFormat: &[u8; 21] = b"Spa:Enum:VideoFormat\0";
pub const SPA_TYPE_INFO_VIDEO_FORMAT_BASE: &[u8; 22] = b"Spa:Enum:VideoFormat:\0";
pub const SPA_TYPE_INFO_VideoFlags: &[u8; 21] = b"Spa:Flags:VideoFlags\0";
pub const SPA_TYPE_INFO_VIDEO_FLAGS_BASE: &[u8; 22] = b"Spa:Flags:VideoFlags:\0";
pub const SPA_TYPE_INFO_VideoInterlaceMode: &[u8; 28] = b"Spa:Enum:VideoInterlaceMode\0";
pub const SPA_TYPE_INFO_VIDEO_INTERLACE_MODE_BASE: &[u8; 29] = b"Spa:Enum:VideoInterlaceMode:\0";
pub const SPA_TYPE_INFO_Format: &[u8; 28] = b"Spa:Pod:Object:Param:Format\0";
pub const SPA_TYPE_INFO_FORMAT_BASE: &[u8; 29] = b"Spa:Pod:Object:Param:Format:\0";
pub const SPA_TYPE_INFO_MediaType: &[u8; 19] = b"Spa:Enum:MediaType\0";
pub const SPA_TYPE_INFO_MEDIA_TYPE_BASE: &[u8; 20] = b"Spa:Enum:MediaType:\0";
pub const SPA_TYPE_INFO_MediaSubtype: &[u8; 22] = b"Spa:Enum:MediaSubtype\0";
pub const SPA_TYPE_INFO_MEDIA_SUBTYPE_BASE: &[u8; 23] = b"Spa:Enum:MediaSubtype:\0";
pub const SPA_TYPE_INFO_FormatAudio: &[u8; 34] = b"Spa:Pod:Object:Param:Format:Audio\0";
pub const SPA_TYPE_INFO_FORMAT_AUDIO_BASE: &[u8; 35] = b"Spa:Pod:Object:Param:Format:Audio:\0";
pub const SPA_TYPE_INFO_FORMAT_AUDIO_AAC: &[u8; 38] = b"Spa:Pod:Object:Param:Format:Audio:AAC\0";
pub const SPA_TYPE_INFO_FORMAT_AUDIO_AAC_BASE: &[u8; 39] =
    b"Spa:Pod:Object:Param:Format:Audio:AAC:\0";
pub const SPA_TYPE_INFO_FORMAT_AUDIO_WMA: &[u8; 38] = b"Spa:Pod:Object:Param:Format:Audio:WMA\0";
pub const SPA_TYPE_INFO_FORMAT_AUDIO_WMA_BASE: &[u8; 39] =
    b"Spa:Pod:Object:Param:Format:Audio:WMA:\0";
pub const SPA_TYPE_INFO_FORMAT_AUDIO_AMR: &[u8; 38] = b"Spa:Pod:Object:Param:Format:Audio:AMR\0";
pub const SPA_TYPE_INFO_FORMAT_AUDIO_AMR_BASE: &[u8; 39] =
    b"Spa:Pod:Object:Param:Format:Audio:AMR:\0";
pub const SPA_TYPE_INFO_FormatVideo: &[u8; 34] = b"Spa:Pod:Object:Param:Format:Video\0";
pub const SPA_TYPE_INFO_FORMAT_VIDEO_BASE: &[u8; 35] = b"Spa:Pod:Object:Param:Format:Video:\0";
pub const SPA_TYPE_INFO_FORMAT_VIDEO_H264: &[u8; 39] = b"Spa:Pod:Object:Param:Format:Video:H264\0";
pub const SPA_TYPE_INFO_FORMAT_VIDEO_H264_BASE: &[u8; 40] =
    b"Spa:Pod:Object:Param:Format:Video:H264:\0";
pub const SPA_TYPE_INFO_FormatControl: &[u8; 36] = b"Spa:Pod:Object:Param:Format:Control\0";
pub const SPA_TYPE_INFO_FORMAT_CONTROL_BASE: &[u8; 37] = b"Spa:Pod:Object:Param:Format:Control:\0";
pub const SPA_TYPE_INFO_PARAM_Latency: &[u8; 29] = b"Spa:Pod:Object:Param:Latency\0";
pub const SPA_TYPE_INFO_PARAM_LATENCY_BASE: &[u8; 30] = b"Spa:Pod:Object:Param:Latency:\0";
pub const SPA_TYPE_INFO_PARAM_ProcessLatency: &[u8; 36] = b"Spa:Pod:Object:Param:ProcessLatency\0";
pub const SPA_TYPE_INFO_PARAM_PROCESS_LATENCY_BASE: &[u8; 37] =
    b"Spa:Pod:Object:Param:ProcessLatency:\0";
pub const SPA_TYPE_INFO_ParamPortConfigMode: &[u8; 29] = b"Spa:Enum:ParamPortConfigMode\0";
pub const SPA_TYPE_INFO_PARAM_PORT_CONFIG_MODE_BASE: &[u8; 30] = b"Spa:Enum:ParamPortConfigMode:\0";
pub const SPA_TYPE_INFO_PARAM_PortConfig: &[u8; 32] = b"Spa:Pod:Object:Param:PortConfig\0";
pub const SPA_TYPE_INFO_PARAM_PORT_CONFIG_BASE: &[u8; 33] = b"Spa:Pod:Object:Param:PortConfig:\0";
pub const SPA_TYPE_INFO_Profiler: &[u8; 24] = b"Spa:Pod:Object:Profiler\0";
pub const SPA_TYPE_INFO_PROFILER_BASE: &[u8; 25] = b"Spa:Pod:Object:Profiler:\0";
pub const SPA_TYPE_INFO_PARAM_Profile: &[u8; 29] = b"Spa:Pod:Object:Param:Profile\0";
pub const SPA_TYPE_INFO_PARAM_PROFILE_BASE: &[u8; 30] = b"Spa:Pod:Object:Param:Profile:\0";
pub const SPA_TYPE_INFO_PARAM_Route: &[u8; 27] = b"Spa:Pod:Object:Param:Route\0";
pub const SPA_TYPE_INFO_PARAM_ROUTE_BASE: &[u8; 28] = b"Spa:Pod:Object:Param:Route:\0";
pub const SPA_TYPE_INFO_PARAM_Tag: &[u8; 25] = b"Spa:Pod:Object:Param:Tag\0";
pub const SPA_TYPE_INFO_PARAM_TAG_BASE: &[u8; 26] = b"Spa:Pod:Object:Param:Tag:\0";
pub const SPA_DICT_FLAG_SORTED: u32 = 1;
pub const SPA_TYPE_INTERFACE_Log: &[u8; 26] = b"Spa:Pointer:Interface:Log\0";
pub const SPA_VERSION_LOG: u32 = 0;
pub const SPA_VERSION_LOG_TOPIC: u32 = 0;
pub const SPA_VERSION_LOG_TOPIC_ENUM: u32 = 0;
pub const SPA_VERSION_LOG_METHODS: u32 = 1;
pub const SPA_LOG_TOPIC_ENUM_NAME: &[u8; 19] = b"spa_log_topic_enum\0";
pub const SPA_KEY_LOG_LEVEL: &[u8; 10] = b"log.level\0";
pub const SPA_KEY_LOG_COLORS: &[u8; 11] = b"log.colors\0";
pub const SPA_KEY_LOG_FILE: &[u8; 9] = b"log.file\0";
pub const SPA_KEY_LOG_TIMESTAMP: &[u8; 14] = b"log.timestamp\0";
pub const SPA_KEY_LOG_LINE: &[u8; 9] = b"log.line\0";
pub const SPA_KEY_LOG_PATTERNS: &[u8; 13] = b"log.patterns\0";
pub const SPA_TYPE_INTERFACE_Node: &[u8; 27] = b"Spa:Pointer:Interface:Node\0";
pub const SPA_VERSION_NODE: u32 = 0;
pub const SPA_NODE_CHANGE_MASK_FLAGS: u32 = 1;
pub const SPA_NODE_CHANGE_MASK_PROPS: u32 = 2;
pub const SPA_NODE_CHANGE_MASK_PARAMS: u32 = 4;
pub const SPA_NODE_FLAG_RT: u32 = 1;
pub const SPA_NODE_FLAG_IN_DYNAMIC_PORTS: u32 = 2;
pub const SPA_NODE_FLAG_OUT_DYNAMIC_PORTS: u32 = 4;
pub const SPA_NODE_FLAG_IN_PORT_CONFIG: u32 = 8;
pub const SPA_NODE_FLAG_OUT_PORT_CONFIG: u32 = 16;
pub const SPA_NODE_FLAG_NEED_CONFIGURE: u32 = 32;
pub const SPA_NODE_FLAG_ASYNC: u32 = 64;
pub const SPA_PORT_CHANGE_MASK_FLAGS: u32 = 1;
pub const SPA_PORT_CHANGE_MASK_RATE: u32 = 2;
pub const SPA_PORT_CHANGE_MASK_PROPS: u32 = 4;
pub const SPA_PORT_CHANGE_MASK_PARAMS: u32 = 8;
pub const SPA_PORT_FLAG_REMOVABLE: u32 = 1;
pub const SPA_PORT_FLAG_OPTIONAL: u32 = 2;
pub const SPA_PORT_FLAG_CAN_ALLOC_BUFFERS: u32 = 4;
pub const SPA_PORT_FLAG_IN_PLACE: u32 = 8;
pub const SPA_PORT_FLAG_NO_REF: u32 = 16;
pub const SPA_PORT_FLAG_LIVE: u32 = 32;
pub const SPA_PORT_FLAG_PHYSICAL: u32 = 64;
pub const SPA_PORT_FLAG_TERMINAL: u32 = 128;
pub const SPA_PORT_FLAG_DYNAMIC_DATA: u32 = 256;
pub const SPA_RESULT_TYPE_NODE_ERROR: u32 = 1;
pub const SPA_RESULT_TYPE_NODE_PARAMS: u32 = 2;
pub const SPA_NODE_EVENT_INFO: u32 = 0;
pub const SPA_NODE_EVENT_PORT_INFO: u32 = 1;
pub const SPA_NODE_EVENT_RESULT: u32 = 2;
pub const SPA_NODE_EVENT_EVENT: u32 = 3;
pub const SPA_NODE_EVENT_NUM: u32 = 4;
pub const SPA_VERSION_NODE_EVENTS: u32 = 0;
pub const SPA_NODE_CALLBACK_READY: u32 = 0;
pub const SPA_NODE_CALLBACK_REUSE_BUFFER: u32 = 1;
pub const SPA_NODE_CALLBACK_XRUN: u32 = 2;
pub const SPA_NODE_CALLBACK_NUM: u32 = 3;
pub const SPA_VERSION_NODE_CALLBACKS: u32 = 0;
pub const SPA_NODE_PARAM_FLAG_TEST_ONLY: u32 = 1;
pub const SPA_NODE_PARAM_FLAG_FIXATE: u32 = 2;
pub const SPA_NODE_PARAM_FLAG_NEAREST: u32 = 4;
pub const SPA_NODE_BUFFERS_FLAG_ALLOC: u32 = 1;
pub const SPA_NODE_METHOD_ADD_LISTENER: u32 = 0;
pub const SPA_NODE_METHOD_SET_CALLBACKS: u32 = 1;
pub const SPA_NODE_METHOD_SYNC: u32 = 2;
pub const SPA_NODE_METHOD_ENUM_PARAMS: u32 = 3;
pub const SPA_NODE_METHOD_SET_PARAM: u32 = 4;
pub const SPA_NODE_METHOD_SET_IO: u32 = 5;
pub const SPA_NODE_METHOD_SEND_COMMAND: u32 = 6;
pub const SPA_NODE_METHOD_ADD_PORT: u32 = 7;
pub const SPA_NODE_METHOD_REMOVE_PORT: u32 = 8;
pub const SPA_NODE_METHOD_PORT_ENUM_PARAMS: u32 = 9;
pub const SPA_NODE_METHOD_PORT_SET_PARAM: u32 = 10;
pub const SPA_NODE_METHOD_PORT_USE_BUFFERS: u32 = 11;
pub const SPA_NODE_METHOD_PORT_SET_IO: u32 = 12;
pub const SPA_NODE_METHOD_PORT_REUSE_BUFFER: u32 = 13;
pub const SPA_NODE_METHOD_PROCESS: u32 = 14;
pub const SPA_NODE_METHOD_NUM: u32 = 15;
pub const SPA_VERSION_NODE_METHODS: u32 = 0;
pub const SPA_VERSION_GRAPH_NODE_CALLBACKS: u32 = 0;
pub const SPA_POD_BUILDER_FLAG_BODY: u32 = 1;
pub const SPA_POD_BUILDER_FLAG_FIRST: u32 = 2;
pub const SPA_VERSION_POD_BUILDER_CALLBACKS: u32 = 0;
pub const SPA_TYPE_INTERFACE_AUDIO_AEC: &[u8; 32] = b"Spa:Pointer:Interface:Audio:AEC\0";
pub const SPA_VERSION_AUDIO_AEC: u32 = 1;
pub const SPA_AUDIO_AEC_CHANGE_MASK_PROPS: u32 = 1;
pub const SPA_VERSION_AUDIO_AEC_EVENTS: u32 = 0;
pub const SPA_VERSION_AUDIO_AEC_METHODS: u32 = 3;
pub const SPA_TYPE_INTERFACE_Device: &[u8; 29] = b"Spa:Pointer:Interface:Device\0";
pub const SPA_VERSION_DEVICE: u32 = 0;
pub const SPA_VERSION_DEVICE_INFO: u32 = 0;
pub const SPA_DEVICE_CHANGE_MASK_FLAGS: u32 = 1;
pub const SPA_DEVICE_CHANGE_MASK_PROPS: u32 = 2;
pub const SPA_DEVICE_CHANGE_MASK_PARAMS: u32 = 4;
pub const SPA_VERSION_DEVICE_OBJECT_INFO: u32 = 0;
pub const SPA_DEVICE_OBJECT_CHANGE_MASK_FLAGS: u32 = 1;
pub const SPA_DEVICE_OBJECT_CHANGE_MASK_PROPS: u32 = 2;
pub const SPA_RESULT_TYPE_DEVICE_PARAMS: u32 = 1;
pub const SPA_DEVICE_EVENT_INFO: u32 = 0;
pub const SPA_DEVICE_EVENT_RESULT: u32 = 1;
pub const SPA_DEVICE_EVENT_EVENT: u32 = 2;
pub const SPA_DEVICE_EVENT_OBJECT_INFO: u32 = 3;
pub const SPA_DEVICE_EVENT_NUM: u32 = 4;
pub const SPA_VERSION_DEVICE_EVENTS: u32 = 0;
pub const SPA_DEVICE_METHOD_ADD_LISTENER: u32 = 0;
pub const SPA_DEVICE_METHOD_SYNC: u32 = 1;
pub const SPA_DEVICE_METHOD_ENUM_PARAMS: u32 = 2;
pub const SPA_DEVICE_METHOD_SET_PARAM: u32 = 3;
pub const SPA_DEVICE_METHOD_NUM: u32 = 4;
pub const SPA_VERSION_DEVICE_METHODS: u32 = 0;
pub const SPA_KEY_DEVICE_ENUM_API: &[u8; 16] = b"device.enum.api\0";
pub const SPA_KEY_DEVICE_API: &[u8; 11] = b"device.api\0";
pub const SPA_KEY_DEVICE_NAME: &[u8; 12] = b"device.name\0";
pub const SPA_KEY_DEVICE_ALIAS: &[u8; 13] = b"device.alias\0";
pub const SPA_KEY_DEVICE_NICK: &[u8; 12] = b"device.nick\0";
pub const SPA_KEY_DEVICE_DESCRIPTION: &[u8; 19] = b"device.description\0";
pub const SPA_KEY_DEVICE_ICON: &[u8; 12] = b"device.icon\0";
pub const SPA_KEY_DEVICE_ICON_NAME: &[u8; 17] = b"device.icon-name\0";
pub const SPA_KEY_DEVICE_PLUGGED_USEC: &[u8; 20] = b"device.plugged.usec\0";
pub const SPA_KEY_DEVICE_BUS_ID: &[u8; 14] = b"device.bus-id\0";
pub const SPA_KEY_DEVICE_BUS_PATH: &[u8; 16] = b"device.bus-path\0";
pub const SPA_KEY_DEVICE_BUS: &[u8; 11] = b"device.bus\0";
pub const SPA_KEY_DEVICE_SUBSYSTEM: &[u8; 17] = b"device.subsystem\0";
pub const SPA_KEY_DEVICE_SYSFS_PATH: &[u8; 18] = b"device.sysfs.path\0";
pub const SPA_KEY_DEVICE_VENDOR_ID: &[u8; 17] = b"device.vendor.id\0";
pub const SPA_KEY_DEVICE_VENDOR_NAME: &[u8; 19] = b"device.vendor.name\0";
pub const SPA_KEY_DEVICE_PRODUCT_ID: &[u8; 18] = b"device.product.id\0";
pub const SPA_KEY_DEVICE_PRODUCT_NAME: &[u8; 20] = b"device.product.name\0";
pub const SPA_KEY_DEVICE_SERIAL: &[u8; 14] = b"device.serial\0";
pub const SPA_KEY_DEVICE_CLASS: &[u8; 13] = b"device.class\0";
pub const SPA_KEY_DEVICE_CAPABILITIES: &[u8; 20] = b"device.capabilities\0";
pub const SPA_KEY_DEVICE_FORM_FACTOR: &[u8; 19] = b"device.form-factor\0";
pub const SPA_KEY_DEVICE_PROFILE: &[u8; 15] = b"device.profile\0";
pub const SPA_KEY_DEVICE_PROFILE_SET: &[u8; 19] = b"device.profile-set\0";
pub const SPA_KEY_DEVICE_STRING: &[u8; 14] = b"device.string\0";
pub const SPA_KEY_DEVICE_DEVIDS: &[u8; 14] = b"device.devids\0";
pub const SPA_KEY_NODE_NAME: &[u8; 10] = b"node.name\0";
pub const SPA_KEY_NODE_DESCRIPTION: &[u8; 17] = b"node.description\0";
pub const SPA_KEY_NODE_LATENCY: &[u8; 13] = b"node.latency\0";
pub const SPA_KEY_NODE_MAX_LATENCY: &[u8; 17] = b"node.max-latency\0";
pub const SPA_KEY_NODE_DRIVER: &[u8; 12] = b"node.driver\0";
pub const SPA_KEY_NODE_ALWAYS_PROCESS: &[u8; 20] = b"node.always-process\0";
pub const SPA_KEY_NODE_PAUSE_ON_IDLE: &[u8; 19] = b"node.pause-on-idle\0";
pub const SPA_KEY_NODE_MONITOR: &[u8; 13] = b"node.monitor\0";
pub const SPA_KEY_PORT_NAME: &[u8; 10] = b"port.name\0";
pub const SPA_KEY_PORT_ALIAS: &[u8; 11] = b"port.alias\0";
pub const SPA_KEY_PORT_MONITOR: &[u8; 13] = b"port.monitor\0";
pub const SPA_KEY_PORT_IGNORE_LATENCY: &[u8; 20] = b"port.ignore-latency\0";
pub const SPA_KEY_PORT_GROUP: &[u8; 11] = b"port.group\0";
pub const SPA_AUDIO_DSD_FLAG_NONE: u32 = 0;
pub const _UNISTD_H: u32 = 1;
pub const _POSIX_VERSION: u32 = 200809;
pub const __POSIX2_THIS_VERSION: u32 = 200809;
pub const _POSIX2_VERSION: u32 = 200809;
pub const _POSIX2_C_VERSION: u32 = 200809;
pub const _POSIX2_C_BIND: u32 = 200809;
pub const _POSIX2_C_DEV: u32 = 200809;
pub const _POSIX2_SW_DEV: u32 = 200809;
pub const _POSIX2_LOCALEDEF: u32 = 200809;
pub const _XOPEN_VERSION: u32 = 700;
pub const _XOPEN_XCU_VERSION: u32 = 4;
pub const _XOPEN_XPG2: u32 = 1;
pub const _XOPEN_XPG3: u32 = 1;
pub const _XOPEN_XPG4: u32 = 1;
pub const _XOPEN_UNIX: u32 = 1;
pub const _XOPEN_ENH_I18N: u32 = 1;
pub const _XOPEN_LEGACY: u32 = 1;
pub const _BITS_POSIX_OPT_H: u32 = 1;
pub const _POSIX_JOB_CONTROL: u32 = 1;
pub const _POSIX_SAVED_IDS: u32 = 1;
pub const _POSIX_PRIORITY_SCHEDULING: u32 = 200809;
pub const _POSIX_SYNCHRONIZED_IO: u32 = 200809;
pub const _POSIX_FSYNC: u32 = 200809;
pub const _POSIX_MAPPED_FILES: u32 = 200809;
pub const _POSIX_MEMLOCK: u32 = 200809;
pub const _POSIX_MEMLOCK_RANGE: u32 = 200809;
pub const _POSIX_MEMORY_PROTECTION: u32 = 200809;
pub const _POSIX_CHOWN_RESTRICTED: u32 = 0;
pub const _POSIX_VDISABLE: u8 = 0u8;
pub const _POSIX_NO_TRUNC: u32 = 1;
pub const _XOPEN_REALTIME: u32 = 1;
pub const _XOPEN_REALTIME_THREADS: u32 = 1;
pub const _XOPEN_SHM: u32 = 1;
pub const _POSIX_THREADS: u32 = 200809;
pub const _POSIX_REENTRANT_FUNCTIONS: u32 = 1;
pub const _POSIX_THREAD_SAFE_FUNCTIONS: u32 = 200809;
pub const _POSIX_THREAD_PRIORITY_SCHEDULING: u32 = 200809;
pub const _POSIX_THREAD_ATTR_STACKSIZE: u32 = 200809;
pub const _POSIX_THREAD_ATTR_STACKADDR: u32 = 200809;
pub const _POSIX_THREAD_PRIO_INHERIT: u32 = 200809;
pub const _POSIX_THREAD_PRIO_PROTECT: u32 = 200809;
pub const _POSIX_THREAD_ROBUST_PRIO_INHERIT: u32 = 200809;
pub const _POSIX_THREAD_ROBUST_PRIO_PROTECT: i32 = -1;
pub const _POSIX_SEMAPHORES: u32 = 200809;
pub const _POSIX_REALTIME_SIGNALS: u32 = 200809;
pub const _POSIX_ASYNCHRONOUS_IO: u32 = 200809;
pub const _POSIX_ASYNC_IO: u32 = 1;
pub const _LFS_ASYNCHRONOUS_IO: u32 = 1;
pub const _POSIX_PRIORITIZED_IO: u32 = 200809;
pub const _LFS64_ASYNCHRONOUS_IO: u32 = 1;
pub const _LFS_LARGEFILE: u32 = 1;
pub const _LFS64_LARGEFILE: u32 = 1;
pub const _LFS64_STDIO: u32 = 1;
pub const _POSIX_SHARED_MEMORY_OBJECTS: u32 = 200809;
pub const _POSIX_CPUTIME: u32 = 0;
pub const _POSIX_THREAD_CPUTIME: u32 = 0;
pub const _POSIX_REGEXP: u32 = 1;
pub const _POSIX_READER_WRITER_LOCKS: u32 = 200809;
pub const _POSIX_SHELL: u32 = 1;
pub const _POSIX_TIMEOUTS: u32 = 200809;
pub const _POSIX_SPIN_LOCKS: u32 = 200809;
pub const _POSIX_SPAWN: u32 = 200809;
pub const _POSIX_TIMERS: u32 = 200809;
pub const _POSIX_BARRIERS: u32 = 200809;
pub const _POSIX_MESSAGE_PASSING: u32 = 200809;
pub const _POSIX_THREAD_PROCESS_SHARED: u32 = 200809;
pub const _POSIX_MONOTONIC_CLOCK: u32 = 0;
pub const _POSIX_CLOCK_SELECTION: u32 = 200809;
pub const _POSIX_ADVISORY_INFO: u32 = 200809;
pub const _POSIX_IPV6: u32 = 200809;
pub const _POSIX_RAW_SOCKETS: u32 = 200809;
pub const _POSIX2_CHAR_TERM: u32 = 200809;
pub const _POSIX_SPORADIC_SERVER: i32 = -1;
pub const _POSIX_THREAD_SPORADIC_SERVER: i32 = -1;
pub const _POSIX_TRACE: i32 = -1;
pub const _POSIX_TRACE_EVENT_FILTER: i32 = -1;
pub const _POSIX_TRACE_INHERIT: i32 = -1;
pub const _POSIX_TRACE_LOG: i32 = -1;
pub const _POSIX_TYPED_MEMORY_OBJECTS: i32 = -1;
pub const _POSIX_V7_LPBIG_OFFBIG: i32 = -1;
pub const _POSIX_V6_LPBIG_OFFBIG: i32 = -1;
pub const _XBS5_LPBIG_OFFBIG: i32 = -1;
pub const _POSIX_V7_LP64_OFF64: u32 = 1;
pub const _POSIX_V6_LP64_OFF64: u32 = 1;
pub const _XBS5_LP64_OFF64: u32 = 1;
pub const __ILP32_OFF32_CFLAGS: &[u8; 5] = b"-m32\0";
pub const __ILP32_OFF32_LDFLAGS: &[u8; 5] = b"-m32\0";
pub const __ILP32_OFFBIG_CFLAGS: &[u8; 48] = b"-m32 -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64\0";
pub const __ILP32_OFFBIG_LDFLAGS: &[u8; 5] = b"-m32\0";
pub const __LP64_OFF64_CFLAGS: &[u8; 5] = b"-m64\0";
pub const __LP64_OFF64_LDFLAGS: &[u8; 5] = b"-m64\0";
pub const STDIN_FILENO: u32 = 0;
pub const STDOUT_FILENO: u32 = 1;
pub const STDERR_FILENO: u32 = 2;
pub const R_OK: u32 = 4;
pub const W_OK: u32 = 2;
pub const X_OK: u32 = 1;
pub const F_OK: u32 = 0;
pub const L_SET: u32 = 0;
pub const L_INCR: u32 = 1;
pub const L_XTND: u32 = 2;
pub const _GETOPT_POSIX_H: u32 = 1;
pub const _GETOPT_CORE_H: u32 = 1;
pub const F_ULOCK: u32 = 0;
pub const F_LOCK: u32 = 1;
pub const F_TLOCK: u32 = 2;
pub const F_TEST: u32 = 3;
pub const _DIRENT_H: u32 = 1;
pub const _DIRENT_MATCHES_DIRENT64: u32 = 1;
pub const _BITS_POSIX1_LIM_H: u32 = 1;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const PTHREAD_KEYS_MAX: u32 = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const AIO_PRIO_DELTA_MAX: u32 = 20;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const DELAYTIMER_MAX: u32 = 2147483647;
pub const TTY_NAME_MAX: u32 = 32;
pub const LOGIN_NAME_MAX: u32 = 256;
pub const HOST_NAME_MAX: u32 = 64;
pub const MQ_PRIO_MAX: u32 = 32768;
pub const SEM_VALUE_MAX: u32 = 2147483647;
pub const MAXNAMLEN: u32 = 255;
pub const SPA_TYPE_INTERFACE_CPU: &[u8; 26] = b"Spa:Pointer:Interface:CPU\0";
pub const SPA_VERSION_CPU: u32 = 0;
pub const SPA_CPU_FLAG_MMX: u32 = 1;
pub const SPA_CPU_FLAG_MMXEXT: u32 = 2;
pub const SPA_CPU_FLAG_3DNOW: u32 = 4;
pub const SPA_CPU_FLAG_SSE: u32 = 8;
pub const SPA_CPU_FLAG_SSE2: u32 = 16;
pub const SPA_CPU_FLAG_3DNOWEXT: u32 = 32;
pub const SPA_CPU_FLAG_SSE3: u32 = 64;
pub const SPA_CPU_FLAG_SSSE3: u32 = 128;
pub const SPA_CPU_FLAG_SSE41: u32 = 256;
pub const SPA_CPU_FLAG_SSE42: u32 = 512;
pub const SPA_CPU_FLAG_AESNI: u32 = 1024;
pub const SPA_CPU_FLAG_AVX: u32 = 2048;
pub const SPA_CPU_FLAG_XOP: u32 = 4096;
pub const SPA_CPU_FLAG_FMA4: u32 = 8192;
pub const SPA_CPU_FLAG_CMOV: u32 = 16384;
pub const SPA_CPU_FLAG_AVX2: u32 = 32768;
pub const SPA_CPU_FLAG_FMA3: u32 = 65536;
pub const SPA_CPU_FLAG_BMI1: u32 = 131072;
pub const SPA_CPU_FLAG_BMI2: u32 = 262144;
pub const SPA_CPU_FLAG_AVX512: u32 = 524288;
pub const SPA_CPU_FLAG_SLOW_UNALIGNED: u32 = 1048576;
pub const SPA_CPU_FLAG_ALTIVEC: u32 = 1;
pub const SPA_CPU_FLAG_VSX: u32 = 2;
pub const SPA_CPU_FLAG_POWER8: u32 = 4;
pub const SPA_CPU_FLAG_ARMV5TE: u32 = 1;
pub const SPA_CPU_FLAG_ARMV6: u32 = 2;
pub const SPA_CPU_FLAG_ARMV6T2: u32 = 4;
pub const SPA_CPU_FLAG_VFP: u32 = 8;
pub const SPA_CPU_FLAG_VFPV3: u32 = 16;
pub const SPA_CPU_FLAG_NEON: u32 = 32;
pub const SPA_CPU_FLAG_ARMV8: u32 = 64;
pub const SPA_CPU_FLAG_RISCV_V: u32 = 1;
pub const SPA_CPU_VM_NONE: u32 = 0;
pub const SPA_CPU_VM_OTHER: u32 = 1;
pub const SPA_CPU_VM_KVM: u32 = 2;
pub const SPA_CPU_VM_QEMU: u32 = 4;
pub const SPA_CPU_VM_BOCHS: u32 = 8;
pub const SPA_CPU_VM_XEN: u32 = 16;
pub const SPA_CPU_VM_UML: u32 = 32;
pub const SPA_CPU_VM_VMWARE: u32 = 64;
pub const SPA_CPU_VM_ORACLE: u32 = 128;
pub const SPA_CPU_VM_MICROSOFT: u32 = 256;
pub const SPA_CPU_VM_ZVM: u32 = 512;
pub const SPA_CPU_VM_PARALLELS: u32 = 1024;
pub const SPA_CPU_VM_BHYVE: u32 = 2048;
pub const SPA_CPU_VM_QNX: u32 = 4096;
pub const SPA_CPU_VM_ACRN: u32 = 8192;
pub const SPA_CPU_VM_POWERVM: u32 = 16384;
pub const SPA_VERSION_CPU_METHODS: u32 = 2;
pub const SPA_KEY_CPU_FORCE: &[u8; 10] = b"cpu.force\0";
pub const SPA_KEY_CPU_VM_TYPE: &[u8; 12] = b"cpu.vm.type\0";
pub const SPA_KEY_CPU_ZERO_DENORMALS: &[u8; 19] = b"cpu.zero.denormals\0";
pub const _TIME_H: u32 = 1;
pub const _BITS_TIME_H: u32 = 1;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_MONOTONIC: u32 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 3;
pub const CLOCK_MONOTONIC_RAW: u32 = 4;
pub const CLOCK_REALTIME_COARSE: u32 = 5;
pub const CLOCK_MONOTONIC_COARSE: u32 = 6;
pub const CLOCK_BOOTTIME: u32 = 7;
pub const CLOCK_REALTIME_ALARM: u32 = 8;
pub const CLOCK_BOOTTIME_ALARM: u32 = 9;
pub const CLOCK_TAI: u32 = 11;
pub const TIMER_ABSTIME: u32 = 1;
pub const __struct_tm_defined: u32 = 1;
pub const __itimerspec_defined: u32 = 1;
pub const TIME_UTC: u32 = 1;
pub const SPA_TYPE_INTERFACE_System: &[u8; 29] = b"Spa:Pointer:Interface:System\0";
pub const SPA_TYPE_INTERFACE_DataSystem: &[u8; 33] = b"Spa:Pointer:Interface:DataSystem\0";
pub const SPA_VERSION_SYSTEM: u32 = 0;
pub const SPA_IO_IN: u32 = 1;
pub const SPA_IO_OUT: u32 = 4;
pub const SPA_IO_ERR: u32 = 8;
pub const SPA_IO_HUP: u32 = 16;
pub const SPA_FD_CLOEXEC: u32 = 1;
pub const SPA_FD_NONBLOCK: u32 = 2;
pub const SPA_FD_EVENT_SEMAPHORE: u32 = 4;
pub const SPA_FD_TIMER_ABSTIME: u32 = 8;
pub const SPA_FD_TIMER_CANCEL_ON_SET: u32 = 16;
pub const SPA_VERSION_SYSTEM_METHODS: u32 = 0;
pub const SPA_TYPE_INTERFACE_Loop: &[u8; 27] = b"Spa:Pointer:Interface:Loop\0";
pub const SPA_TYPE_INTERFACE_DataLoop: &[u8; 31] = b"Spa:Pointer:Interface:DataLoop\0";
pub const SPA_VERSION_LOOP: u32 = 0;
pub const SPA_TYPE_INTERFACE_LoopControl: &[u8; 34] = b"Spa:Pointer:Interface:LoopControl\0";
pub const SPA_VERSION_LOOP_CONTROL: u32 = 1;
pub const SPA_TYPE_INTERFACE_LoopUtils: &[u8; 32] = b"Spa:Pointer:Interface:LoopUtils\0";
pub const SPA_VERSION_LOOP_UTILS: u32 = 0;
pub const SPA_VERSION_LOOP_METHODS: u32 = 0;
pub const SPA_VERSION_LOOP_CONTROL_HOOKS: u32 = 0;
pub const SPA_VERSION_LOOP_CONTROL_METHODS: u32 = 1;
pub const SPA_VERSION_LOOP_UTILS_METHODS: u32 = 0;
pub const SPA_TYPE_INTERFACE_DBus: &[u8; 27] = b"Spa:Pointer:Interface:DBus\0";
pub const SPA_VERSION_DBUS: u32 = 0;
pub const SPA_DBUS_CONNECTION_EVENT_DESTROY: u32 = 0;
pub const SPA_DBUS_CONNECTION_EVENT_DISCONNECTED: u32 = 1;
pub const SPA_DBUS_CONNECTION_EVENT_NUM: u32 = 2;
pub const SPA_VERSION_DBUS_CONNECTION_EVENTS: u32 = 0;
pub const SPA_VERSION_DBUS_CONNECTION: u32 = 1;
pub const SPA_VERSION_DBUS_METHODS: u32 = 0;
pub const SPA_TYPE_INTERFACE_I18N: &[u8; 27] = b"Spa:Pointer:Interface:I18N\0";
pub const SPA_VERSION_I18N: u32 = 0;
pub const SPA_VERSION_I18N_METHODS: u32 = 0;
pub const SPA_VERSION_HANDLE: u32 = 0;
pub const SPA_VERSION_HANDLE_FACTORY: u32 = 1;
pub const SPA_HANDLE_FACTORY_ENUM_FUNC_NAME: &[u8; 24] = b"spa_handle_factory_enum\0";
pub const SPA_KEY_FACTORY_NAME: &[u8; 13] = b"factory.name\0";
pub const SPA_KEY_FACTORY_AUTHOR: &[u8; 15] = b"factory.author\0";
pub const SPA_KEY_FACTORY_DESCRIPTION: &[u8; 20] = b"factory.description\0";
pub const SPA_KEY_FACTORY_USAGE: &[u8; 14] = b"factory.usage\0";
pub const SPA_KEY_LIBRARY_NAME: &[u8; 13] = b"library.name\0";
pub const SPA_TYPE_INTERFACE_PluginLoader: &[u8; 35] = b"Spa:Pointer:Interface:PluginLoader\0";
pub const SPA_VERSION_PLUGIN_LOADER: u32 = 0;
pub const SPA_VERSION_PLUGIN_LOADER_METHODS: u32 = 0;
pub const SPA_TYPE_INFO_Thread: &[u8; 19] = b"Spa:Pointer:Thread\0";
pub const SPA_TYPE_INTERFACE_ThreadUtils: &[u8; 34] = b"Spa:Pointer:Interface:ThreadUtils\0";
pub const SPA_VERSION_THREAD_UTILS: u32 = 0;
pub const SPA_VERSION_THREAD_UTILS_METHODS: u32 = 0;
pub const SPA_KEY_THREAD_NAME: &[u8; 12] = b"thread.name\0";
pub const SPA_KEY_THREAD_STACK_SIZE: &[u8; 18] = b"thread.stack-size\0";
pub const SPA_KEY_THREAD_AFFINITY: &[u8; 16] = b"thread.affinity\0";
pub const SPA_KEY_THREAD_CREATOR: &[u8; 15] = b"thread.creator\0";
pub const SPA_ANSI_RESET: &[u8; 5] = b"\x1B[0m\0";
pub const SPA_ANSI_BOLD: &[u8; 5] = b"\x1B[1m\0";
pub const SPA_ANSI_ITALIC: &[u8; 5] = b"\x1B[3m\0";
pub const SPA_ANSI_UNDERLINE: &[u8; 5] = b"\x1B[4m\0";
pub const SPA_ANSI_BLACK: &[u8; 8] = b"\x1B[0;30m\0";
pub const SPA_ANSI_RED: &[u8; 8] = b"\x1B[0;31m\0";
pub const SPA_ANSI_GREEN: &[u8; 8] = b"\x1B[0;32m\0";
pub const SPA_ANSI_YELLOW: &[u8; 8] = b"\x1B[0;33m\0";
pub const SPA_ANSI_BLUE: &[u8; 8] = b"\x1B[0;34m\0";
pub const SPA_ANSI_MAGENTA: &[u8; 8] = b"\x1B[0;35m\0";
pub const SPA_ANSI_CYAN: &[u8; 8] = b"\x1B[0;36m\0";
pub const SPA_ANSI_WHITE: &[u8; 8] = b"\x1B[0;37m\0";
pub const SPA_ANSI_BRIGHT_BLACK: &[u8; 6] = b"\x1B[90m\0";
pub const SPA_ANSI_BRIGHT_RED: &[u8; 6] = b"\x1B[91m\0";
pub const SPA_ANSI_BRIGHT_GREEN: &[u8; 6] = b"\x1B[92m\0";
pub const SPA_ANSI_BRIGHT_YELLOW: &[u8; 6] = b"\x1B[93m\0";
pub const SPA_ANSI_BRIGHT_BLUE: &[u8; 6] = b"\x1B[94m\0";
pub const SPA_ANSI_BRIGHT_MAGENTA: &[u8; 6] = b"\x1B[95m\0";
pub const SPA_ANSI_BRIGHT_CYAN: &[u8; 6] = b"\x1B[96m\0";
pub const SPA_ANSI_BRIGHT_WHITE: &[u8; 6] = b"\x1B[97m\0";
pub const SPA_ANSI_BOLD_BLACK: &[u8; 8] = b"\x1B[1;30m\0";
pub const SPA_ANSI_BOLD_RED: &[u8; 8] = b"\x1B[1;31m\0";
pub const SPA_ANSI_BOLD_GREEN: &[u8; 8] = b"\x1B[1;32m\0";
pub const SPA_ANSI_BOLD_YELLOW: &[u8; 8] = b"\x1B[1;33m\0";
pub const SPA_ANSI_BOLD_BLUE: &[u8; 8] = b"\x1B[1;34m\0";
pub const SPA_ANSI_BOLD_MAGENTA: &[u8; 8] = b"\x1B[1;35m\0";
pub const SPA_ANSI_BOLD_CYAN: &[u8; 8] = b"\x1B[1;36m\0";
pub const SPA_ANSI_BOLD_WHITE: &[u8; 8] = b"\x1B[1;37m\0";
pub const SPA_ANSI_DARK_BLACK: &[u8; 8] = b"\x1B[2;30m\0";
pub const SPA_ANSI_DARK_RED: &[u8; 8] = b"\x1B[2;31m\0";
pub const SPA_ANSI_DARK_GREEN: &[u8; 8] = b"\x1B[2;32m\0";
pub const SPA_ANSI_DARK_YELLOW: &[u8; 8] = b"\x1B[2;33m\0";
pub const SPA_ANSI_DARK_BLUE: &[u8; 8] = b"\x1B[2;34m\0";
pub const SPA_ANSI_DARK_MAGENTA: &[u8; 8] = b"\x1B[2;35m\0";
pub const SPA_ANSI_DARK_CYAN: &[u8; 8] = b"\x1B[2;36m\0";
pub const SPA_ANSI_DARK_WHITE: &[u8; 8] = b"\x1B[2;37m\0";
pub const SPA_ANSI_BG_BLACK: &[u8; 8] = b"\x1B[0;40m\0";
pub const SPA_ANSI_BG_RED: &[u8; 8] = b"\x1B[0;41m\0";
pub const SPA_ANSI_BG_GREEN: &[u8; 8] = b"\x1B[0;42m\0";
pub const SPA_ANSI_BG_YELLOW: &[u8; 8] = b"\x1B[0;43m\0";
pub const SPA_ANSI_BG_BLUE: &[u8; 8] = b"\x1B[0;44m\0";
pub const SPA_ANSI_BG_MAGENTA: &[u8; 8] = b"\x1B[0;45m\0";
pub const SPA_ANSI_BG_CYAN: &[u8; 8] = b"\x1B[0;46m\0";
pub const SPA_ANSI_BG_WHITE: &[u8; 8] = b"\x1B[0;47m\0";
pub const SPA_ANSI_BG_BRIGHT_BLACK: &[u8; 7] = b"\x1B[100m\0";
pub const SPA_ANSI_BG_BRIGHT_RED: &[u8; 7] = b"\x1B[101m\0";
pub const SPA_ANSI_BG_BRIGHT_GREEN: &[u8; 7] = b"\x1B[102m\0";
pub const SPA_ANSI_BG_BRIGHT_YELLOW: &[u8; 7] = b"\x1B[103m\0";
pub const SPA_ANSI_BG_BRIGHT_BLUE: &[u8; 7] = b"\x1B[104m\0";
pub const SPA_ANSI_BG_BRIGHT_MAGENTA: &[u8; 7] = b"\x1B[105m\0";
pub const SPA_ANSI_BG_BRIGHT_CYAN: &[u8; 7] = b"\x1B[106m\0";
pub const SPA_ANSI_BG_BRIGHT_WHITE: &[u8; 7] = b"\x1B[107m\0";
pub const _MATH_H: u32 = 1;
pub const _BITS_LIBM_SIMD_DECL_STUBS_H: u32 = 1;
pub const __FP_LOGB0_IS_MIN: u32 = 1;
pub const __FP_LOGBNAN_IS_MIN: u32 = 1;
pub const FP_ILOGB0: i32 = -2147483648;
pub const FP_ILOGBNAN: i32 = -2147483648;
pub const __MATH_DECLARING_DOUBLE: u32 = 1;
pub const __MATH_DECLARING_FLOATN: u32 = 0;
pub const __MATH_DECLARE_LDOUBLE: u32 = 1;
pub const FP_NAN: u32 = 0;
pub const FP_INFINITE: u32 = 1;
pub const FP_ZERO: u32 = 2;
pub const FP_SUBNORMAL: u32 = 3;
pub const FP_NORMAL: u32 = 4;
pub const MATH_ERRNO: u32 = 1;
pub const MATH_ERREXCEPT: u32 = 2;
pub const math_errhandling: u32 = 3;
pub const M_E: f64 = 2.718281828459045;
pub const M_LOG2E: f64 = 1.4426950408889634;
pub const M_LOG10E: f64 = 0.4342944819032518;
pub const M_LN2: f64 = 0.6931471805599453;
pub const M_LN10: f64 = 2.302585092994046;
pub const M_PI: f64 = 3.141592653589793;
pub const M_PI_2: f64 = 1.5707963267948966;
pub const M_PI_4: f64 = 0.7853981633974483;
pub const M_1_PI: f64 = 0.3183098861837907;
pub const M_2_PI: f64 = 0.6366197723675814;
pub const M_2_SQRTPI: f64 = 1.1283791670955126;
pub const M_SQRT2: f64 = 1.4142135623730951;
pub const M_SQRT1_2: f64 = 0.7071067811865476;
pub const SPA_DLL_BW_MAX: f64 = 0.128;
pub const SPA_DLL_BW_MIN: f64 = 0.016;
pub const SPA_JSON_ERROR_FLAG: u32 = 256;
pub const SPA_KEY_OBJECT_PATH: &[u8; 12] = b"object.path\0";
pub const SPA_KEY_MEDIA_CLASS: &[u8; 12] = b"media.class\0";
pub const SPA_KEY_MEDIA_ROLE: &[u8; 11] = b"media.role\0";
pub const SPA_KEY_API_UDEV: &[u8; 9] = b"api.udev\0";
pub const SPA_KEY_API_UDEV_MATCH: &[u8; 15] = b"api.udev.match\0";
pub const SPA_KEY_API_ALSA: &[u8; 9] = b"api.alsa\0";
pub const SPA_KEY_API_ALSA_PATH: &[u8; 14] = b"api.alsa.path\0";
pub const SPA_KEY_API_ALSA_CARD: &[u8; 14] = b"api.alsa.card\0";
pub const SPA_KEY_API_ALSA_USE_UCM: &[u8; 17] = b"api.alsa.use-ucm\0";
pub const SPA_KEY_API_ALSA_IGNORE_DB: &[u8; 19] = b"api.alsa.ignore-dB\0";
pub const SPA_KEY_API_ALSA_OPEN_UCM: &[u8; 18] = b"api.alsa.open.ucm\0";
pub const SPA_KEY_API_ALSA_DISABLE_LONGNAME: &[u8; 26] = b"api.alsa.disable-longname\0";
pub const SPA_KEY_API_ALSA_BIND_CTLS: &[u8; 19] = b"api.alsa.bind-ctls\0";
pub const SPA_KEY_API_ALSA_SPLIT_ENABLE: &[u8; 22] = b"api.alsa.split-enable\0";
pub const SPA_KEY_API_ALSA_SPLIT_PARENT: &[u8; 22] = b"api.alsa.split.parent\0";
pub const SPA_KEY_API_ALSA_CARD_ID: &[u8; 17] = b"api.alsa.card.id\0";
pub const SPA_KEY_API_ALSA_CARD_COMPONENTS: &[u8; 25] = b"api.alsa.card.components\0";
pub const SPA_KEY_API_ALSA_CARD_DRIVER: &[u8; 21] = b"api.alsa.card.driver\0";
pub const SPA_KEY_API_ALSA_CARD_NAME: &[u8; 19] = b"api.alsa.card.name\0";
pub const SPA_KEY_API_ALSA_CARD_LONGNAME: &[u8; 23] = b"api.alsa.card.longname\0";
pub const SPA_KEY_API_ALSA_CARD_MIXERNAME: &[u8; 24] = b"api.alsa.card.mixername\0";
pub const SPA_KEY_API_ALSA_PCM_ID: &[u8; 16] = b"api.alsa.pcm.id\0";
pub const SPA_KEY_API_ALSA_PCM_CARD: &[u8; 18] = b"api.alsa.pcm.card\0";
pub const SPA_KEY_API_ALSA_PCM_NAME: &[u8; 18] = b"api.alsa.pcm.name\0";
pub const SPA_KEY_API_ALSA_PCM_SUBNAME: &[u8; 21] = b"api.alsa.pcm.subname\0";
pub const SPA_KEY_API_ALSA_PCM_STREAM: &[u8; 20] = b"api.alsa.pcm.stream\0";
pub const SPA_KEY_API_ALSA_PCM_CLASS: &[u8; 19] = b"api.alsa.pcm.class\0";
pub const SPA_KEY_API_ALSA_PCM_DEVICE: &[u8; 20] = b"api.alsa.pcm.device\0";
pub const SPA_KEY_API_ALSA_PCM_SUBDEVICE: &[u8; 23] = b"api.alsa.pcm.subdevice\0";
pub const SPA_KEY_API_ALSA_PCM_SUBCLASS: &[u8; 22] = b"api.alsa.pcm.subclass\0";
pub const SPA_KEY_API_ALSA_PCM_SYNC_ID: &[u8; 21] = b"api.alsa.pcm.sync-id\0";
pub const SPA_KEY_API_ALSA_SPLIT_POSITION: &[u8; 24] = b"api.alsa.split.position\0";
pub const SPA_KEY_API_ALSA_SPLIT_HW_POSITION: &[u8; 27] = b"api.alsa.split.hw-position\0";
pub const SPA_KEY_API_V4L2: &[u8; 9] = b"api.v4l2\0";
pub const SPA_KEY_API_V4L2_PATH: &[u8; 14] = b"api.v4l2.path\0";
pub const SPA_KEY_API_LIBCAMERA: &[u8; 14] = b"api.libcamera\0";
pub const SPA_KEY_API_LIBCAMERA_PATH: &[u8; 19] = b"api.libcamera.path\0";
pub const SPA_KEY_API_LIBCAMERA_LOCATION: &[u8; 23] = b"api.libcamera.location\0";
pub const SPA_KEY_API_LIBCAMERA_ROTATION: &[u8; 23] = b"api.libcamera.rotation\0";
pub const SPA_KEY_API_LIBCAMERA_CAP_DRIVER: &[u8; 25] = b"api.libcamera.cap.driver\0";
pub const SPA_KEY_API_LIBCAMERA_CAP_CARD: &[u8; 23] = b"api.libcamera.cap.card\0";
pub const SPA_KEY_API_LIBCAMERA_CAP_BUS_INFO: &[u8; 27] = b"api.libcamera.cap.bus_info\0";
pub const SPA_KEY_API_LIBCAMERA_CAP_VERSION: &[u8; 26] = b"api.libcamera.cap.version\0";
pub const SPA_KEY_API_LIBCAMERA_CAP_CAPABILITIES: &[u8; 31] = b"api.libcamera.cap.capabilities\0";
pub const SPA_KEY_API_LIBCAMERA_CAP_DEVICE_CAPS: &[u8; 30] = b"api.libcamera.cap.device-caps\0";
pub const SPA_KEY_API_V4L2_CAP_DRIVER: &[u8; 20] = b"api.v4l2.cap.driver\0";
pub const SPA_KEY_API_V4L2_CAP_CARD: &[u8; 18] = b"api.v4l2.cap.card\0";
pub const SPA_KEY_API_V4L2_CAP_BUS_INFO: &[u8; 22] = b"api.v4l2.cap.bus_info\0";
pub const SPA_KEY_API_V4L2_CAP_VERSION: &[u8; 21] = b"api.v4l2.cap.version\0";
pub const SPA_KEY_API_V4L2_CAP_CAPABILITIES: &[u8; 26] = b"api.v4l2.cap.capabilities\0";
pub const SPA_KEY_API_V4L2_CAP_DEVICE_CAPS: &[u8; 25] = b"api.v4l2.cap.device-caps\0";
pub const SPA_KEY_API_BLUEZ5: &[u8; 11] = b"api.bluez5\0";
pub const SPA_KEY_API_BLUEZ5_PATH: &[u8; 16] = b"api.bluez5.path\0";
pub const SPA_KEY_API_BLUEZ5_DEVICE: &[u8; 18] = b"api.bluez5.device\0";
pub const SPA_KEY_API_BLUEZ5_CONNECTION: &[u8; 22] = b"api.bluez5.connection\0";
pub const SPA_KEY_API_BLUEZ5_TRANSPORT: &[u8; 21] = b"api.bluez5.transport\0";
pub const SPA_KEY_API_BLUEZ5_PROFILE: &[u8; 19] = b"api.bluez5.profile\0";
pub const SPA_KEY_API_BLUEZ5_ADDRESS: &[u8; 19] = b"api.bluez5.address\0";
pub const SPA_KEY_API_BLUEZ5_CODEC: &[u8; 17] = b"api.bluez5.codec\0";
pub const SPA_KEY_API_BLUEZ5_CLASS: &[u8; 17] = b"api.bluez5.class\0";
pub const SPA_KEY_API_BLUEZ5_ICON: &[u8; 16] = b"api.bluez5.icon\0";
pub const SPA_KEY_API_BLUEZ5_ROLE: &[u8; 16] = b"api.bluez5.role\0";
pub const SPA_KEY_API_JACK: &[u8; 9] = b"api.jack\0";
pub const SPA_KEY_API_JACK_SERVER: &[u8; 16] = b"api.jack.server\0";
pub const SPA_KEY_API_JACK_CLIENT: &[u8; 16] = b"api.jack.client\0";
pub const SPA_KEY_API_GLIB_MAINLOOP: &[u8; 18] = b"api.glib.mainloop\0";
pub const SPA_NAME_SUPPORT_CPU: &[u8; 12] = b"support.cpu\0";
pub const SPA_NAME_SUPPORT_DBUS: &[u8; 13] = b"support.dbus\0";
pub const SPA_NAME_SUPPORT_LOG: &[u8; 12] = b"support.log\0";
pub const SPA_NAME_SUPPORT_LOOP: &[u8; 13] = b"support.loop\0";
pub const SPA_NAME_SUPPORT_SYSTEM: &[u8; 15] = b"support.system\0";
pub const SPA_NAME_SUPPORT_NODE_DRIVER: &[u8; 20] = b"support.node.driver\0";
pub const SPA_NAME_CONTROL_MIXER: &[u8; 14] = b"control.mixer\0";
pub const SPA_NAME_AUDIO_MIXER: &[u8; 12] = b"audio.mixer\0";
pub const SPA_NAME_AUDIO_MIXER_DSP: &[u8; 16] = b"audio.mixer.dsp\0";
pub const SPA_NAME_AUDIO_PROCESS_FORMAT: &[u8; 21] = b"audio.process.format\0";
pub const SPA_NAME_AUDIO_PROCESS_CHANNELMIX: &[u8; 25] = b"audio.process.channelmix\0";
pub const SPA_NAME_AUDIO_PROCESS_RESAMPLE: &[u8; 23] = b"audio.process.resample\0";
pub const SPA_NAME_AUDIO_PROCESS_DEINTERLEAVE: &[u8; 27] = b"audio.process.deinterleave\0";
pub const SPA_NAME_AUDIO_PROCESS_INTERLEAVE: &[u8; 25] = b"audio.process.interleave\0";
pub const SPA_NAME_AUDIO_CONVERT: &[u8; 14] = b"audio.convert\0";
pub const SPA_NAME_AUDIO_ADAPT: &[u8; 12] = b"audio.adapt\0";
pub const SPA_NAME_AEC: &[u8; 10] = b"audio.aec\0";
pub const SPA_NAME_VIDEO_PROCESS_FORMAT: &[u8; 21] = b"video.process.format\0";
pub const SPA_NAME_VIDEO_PROCESS_SCALE: &[u8; 20] = b"video.process.scale\0";
pub const SPA_NAME_VIDEO_CONVERT: &[u8; 14] = b"video.convert\0";
pub const SPA_NAME_VIDEO_CONVERT_DUMMY: &[u8; 20] = b"video.convert.dummy\0";
pub const SPA_NAME_VIDEO_ADAPT: &[u8; 12] = b"video.adapt\0";
pub const SPA_NAME_API_ALSA_ENUM_UDEV: &[u8; 19] = b"api.alsa.enum.udev\0";
pub const SPA_NAME_API_ALSA_PCM_DEVICE: &[u8; 20] = b"api.alsa.pcm.device\0";
pub const SPA_NAME_API_ALSA_PCM_SOURCE: &[u8; 20] = b"api.alsa.pcm.source\0";
pub const SPA_NAME_API_ALSA_PCM_SINK: &[u8; 18] = b"api.alsa.pcm.sink\0";
pub const SPA_NAME_API_ALSA_SEQ_DEVICE: &[u8; 20] = b"api.alsa.seq.device\0";
pub const SPA_NAME_API_ALSA_SEQ_SOURCE: &[u8; 20] = b"api.alsa.seq.source\0";
pub const SPA_NAME_API_ALSA_SEQ_SINK: &[u8; 18] = b"api.alsa.seq.sink\0";
pub const SPA_NAME_API_ALSA_SEQ_BRIDGE: &[u8; 20] = b"api.alsa.seq.bridge\0";
pub const SPA_NAME_API_ALSA_ACP_DEVICE: &[u8; 20] = b"api.alsa.acp.device\0";
pub const SPA_NAME_API_ALSA_COMPRESS_OFFLOAD_DEVICE: &[u8; 33] =
    b"api.alsa.compress.offload.device\0";
pub const SPA_NAME_API_ALSA_COMPRESS_OFFLOAD_SINK: &[u8; 31] = b"api.alsa.compress.offload.sink\0";
pub const SPA_NAME_API_BLUEZ5_ENUM_DBUS: &[u8; 21] = b"api.bluez5.enum.dbus\0";
pub const SPA_NAME_API_BLUEZ5_DEVICE: &[u8; 18] = b"api.bluez5.device\0";
pub const SPA_NAME_API_BLUEZ5_MEDIA_SINK: &[u8; 22] = b"api.bluez5.media.sink\0";
pub const SPA_NAME_API_BLUEZ5_MEDIA_SOURCE: &[u8; 24] = b"api.bluez5.media.source\0";
pub const SPA_NAME_API_BLUEZ5_A2DP_SINK: &[u8; 21] = b"api.bluez5.a2dp.sink\0";
pub const SPA_NAME_API_BLUEZ5_A2DP_SOURCE: &[u8; 23] = b"api.bluez5.a2dp.source\0";
pub const SPA_NAME_API_BLUEZ5_SCO_SINK: &[u8; 20] = b"api.bluez5.sco.sink\0";
pub const SPA_NAME_API_BLUEZ5_SCO_SOURCE: &[u8; 22] = b"api.bluez5.sco.source\0";
pub const SPA_NAME_API_BLUEZ5_MIDI_ENUM: &[u8; 21] = b"api.bluez5.midi.enum\0";
pub const SPA_NAME_API_BLUEZ5_MIDI_NODE: &[u8; 21] = b"api.bluez5.midi.node\0";
pub const SPA_NAME_API_CODEC_BLUEZ5_MEDIA: &[u8; 23] = b"api.codec.bluez5.media\0";
pub const SPA_NAME_API_V4L2_ENUM_UDEV: &[u8; 19] = b"api.v4l2.enum.udev\0";
pub const SPA_NAME_API_V4L2_DEVICE: &[u8; 16] = b"api.v4l2.device\0";
pub const SPA_NAME_API_V4L2_SOURCE: &[u8; 16] = b"api.v4l2.source\0";
pub const SPA_NAME_API_LIBCAMERA_ENUM_CLIENT: &[u8; 26] = b"api.libcamera.enum.client\0";
pub const SPA_NAME_API_LIBCAMERA_ENUM_MANAGER: &[u8; 27] = b"api.libcamera.enum.manager\0";
pub const SPA_NAME_API_LIBCAMERA_DEVICE: &[u8; 21] = b"api.libcamera.device\0";
pub const SPA_NAME_API_LIBCAMERA_SOURCE: &[u8; 21] = b"api.libcamera.source\0";
pub const SPA_NAME_API_JACK_DEVICE: &[u8; 16] = b"api.jack.device\0";
pub const SPA_NAME_API_JACK_SOURCE: &[u8; 16] = b"api.jack.source\0";
pub const SPA_NAME_API_JACK_SINK: &[u8; 14] = b"api.jack.sink\0";
pub const SPA_NAME_API_VULKAN_COMPUTE_SOURCE: &[u8; 26] = b"api.vulkan.compute.source\0";
pub const SPA_NAME_API_VULKAN_COMPUTE_FILTER: &[u8; 26] = b"api.vulkan.compute.filter\0";
pub const SPA_NAME_API_VULKAN_BLIT_FILTER: &[u8; 23] = b"api.vulkan.blit.filter\0";
pub const SPA_NAME_API_VULKAN_BLIT_DSP_FILTER: &[u8; 27] = b"api.vulkan.blit.dsp-filter\0";
pub const SPA_ASYNC_BIT: u32 = 1073741824;
pub const SPA_ASYNC_SEQ_MASK: u32 = 1073741823;
pub const SPA_ASYNC_MASK: i32 = -1073741824;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __fsid_t"][::std::mem::size_of::<__fsid_t>() - 8usize];
    ["Alignment of __fsid_t"][::std::mem::align_of::<__fsid_t>() - 4usize];
    ["Offset of field: __fsid_t::__val"][::std::mem::offset_of!(__fsid_t, __val) - 0usize];
};
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type __gwchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of imaxdiv_t"][::std::mem::size_of::<imaxdiv_t>() - 16usize];
    ["Alignment of imaxdiv_t"][::std::mem::align_of::<imaxdiv_t>() - 8usize];
    ["Offset of field: imaxdiv_t::quot"][::std::mem::offset_of!(imaxdiv_t, quot) - 0usize];
    ["Offset of field: imaxdiv_t::rem"][::std::mem::offset_of!(imaxdiv_t, rem) - 8usize];
};
unsafe extern "C" {
    pub fn imaxabs(__n: intmax_t) -> intmax_t;
}
unsafe extern "C" {
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
}
unsafe extern "C" {
    pub fn strtoimax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
unsafe extern "C" {
    pub fn strtoumax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
unsafe extern "C" {
    pub fn wcstoimax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
unsafe extern "C" {
    pub fn wcstoumax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
pub type sig_atomic_t = __sig_atomic_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __sigset_t"][::std::mem::size_of::<__sigset_t>() - 128usize];
    ["Alignment of __sigset_t"][::std::mem::align_of::<__sigset_t>() - 8usize];
    ["Offset of field: __sigset_t::__val"][::std::mem::offset_of!(__sigset_t, __val) - 0usize];
};
pub type sigset_t = __sigset_t;
pub type pid_t = __pid_t;
pub type uid_t = __uid_t;
pub type time_t = __time_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of timespec"][::std::mem::size_of::<timespec>() - 16usize];
    ["Alignment of timespec"][::std::mem::align_of::<timespec>() - 8usize];
    ["Offset of field: timespec::tv_sec"][::std::mem::offset_of!(timespec, tv_sec) - 0usize];
    ["Offset of field: timespec::tv_nsec"][::std::mem::offset_of!(timespec, tv_nsec) - 8usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigval {
    pub sival_int: ::std::os::raw::c_int,
    pub sival_ptr: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sigval"][::std::mem::size_of::<sigval>() - 8usize];
    ["Alignment of sigval"][::std::mem::align_of::<sigval>() - 8usize];
    ["Offset of field: sigval::sival_int"][::std::mem::offset_of!(sigval, sival_int) - 0usize];
    ["Offset of field: sigval::sival_ptr"][::std::mem::offset_of!(sigval, sival_ptr) - 0usize];
};
pub type __sigval_t = sigval;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t {
    pub si_signo: ::std::os::raw::c_int,
    pub si_errno: ::std::os::raw::c_int,
    pub si_code: ::std::os::raw::c_int,
    pub __pad0: ::std::os::raw::c_int,
    pub _sifields: siginfo_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union siginfo_t__bindgen_ty_1 {
    pub _pad: [::std::os::raw::c_int; 28usize],
    pub _kill: siginfo_t__bindgen_ty_1__bindgen_ty_1,
    pub _timer: siginfo_t__bindgen_ty_1__bindgen_ty_2,
    pub _rt: siginfo_t__bindgen_ty_1__bindgen_ty_3,
    pub _sigchld: siginfo_t__bindgen_ty_1__bindgen_ty_4,
    pub _sigfault: siginfo_t__bindgen_ty_1__bindgen_ty_5,
    pub _sigpoll: siginfo_t__bindgen_ty_1__bindgen_ty_6,
    pub _sigsys: siginfo_t__bindgen_ty_1__bindgen_ty_7,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_1 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of siginfo_t__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_1>() - 8usize];
    ["Alignment of siginfo_t__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_1>() - 4usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_1::si_pid"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_1, si_pid) - 0usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_1::si_uid"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_1, si_uid) - 4usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_2 {
    pub si_tid: ::std::os::raw::c_int,
    pub si_overrun: ::std::os::raw::c_int,
    pub si_sigval: __sigval_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of siginfo_t__bindgen_ty_1__bindgen_ty_2"]
        [::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_2>() - 16usize];
    ["Alignment of siginfo_t__bindgen_ty_1__bindgen_ty_2"]
        [::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_2>() - 8usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_2::si_tid"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_2, si_tid) - 0usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_2::si_overrun"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_2, si_overrun) - 4usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_2::si_sigval"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_2, si_sigval) - 8usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_3 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
    pub si_sigval: __sigval_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of siginfo_t__bindgen_ty_1__bindgen_ty_3"]
        [::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_3>() - 16usize];
    ["Alignment of siginfo_t__bindgen_ty_1__bindgen_ty_3"]
        [::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_3>() - 8usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_3::si_pid"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_3, si_pid) - 0usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_3::si_uid"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_3, si_uid) - 4usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_3::si_sigval"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_3, si_sigval) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_4 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
    pub si_status: ::std::os::raw::c_int,
    pub si_utime: __clock_t,
    pub si_stime: __clock_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of siginfo_t__bindgen_ty_1__bindgen_ty_4"]
        [::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_4>() - 32usize];
    ["Alignment of siginfo_t__bindgen_ty_1__bindgen_ty_4"]
        [::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_4>() - 8usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_4::si_pid"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_4, si_pid) - 0usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_4::si_uid"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_4, si_uid) - 4usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_4::si_status"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_4, si_status) - 8usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_4::si_utime"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_4, si_utime) - 16usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_4::si_stime"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_4, si_stime) - 24usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_5 {
    pub si_addr: *mut ::std::os::raw::c_void,
    pub si_addr_lsb: ::std::os::raw::c_short,
    pub _bounds: siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 {
    pub _addr_bnd: siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1,
    pub _pkey: __uint32_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 {
    pub _lower: *mut ::std::os::raw::c_void,
    pub _upper: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1>(
        ) - 16usize];
    ["Alignment of siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1>(
        ) - 8usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1::_lower"] [:: std :: mem :: offset_of ! (siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 , _lower) - 0usize] ;
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1::_upper"] [:: std :: mem :: offset_of ! (siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 , _upper) - 8usize] ;
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1"]
        [::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1>() - 16usize];
    ["Alignment of siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1"]
        [::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1>() - 8usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1::_addr_bnd"][::std::mem::offset_of!(
        siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1,
        _addr_bnd
    ) - 0usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1::_pkey"][::std::mem::offset_of!(
        siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1,
        _pkey
    ) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of siginfo_t__bindgen_ty_1__bindgen_ty_5"]
        [::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5>() - 32usize];
    ["Alignment of siginfo_t__bindgen_ty_1__bindgen_ty_5"]
        [::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5>() - 8usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_5::si_addr"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_5, si_addr) - 0usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_5::si_addr_lsb"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_5, si_addr_lsb) - 8usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_5::_bounds"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_5, _bounds) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_6 {
    pub si_band: ::std::os::raw::c_long,
    pub si_fd: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of siginfo_t__bindgen_ty_1__bindgen_ty_6"]
        [::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_6>() - 16usize];
    ["Alignment of siginfo_t__bindgen_ty_1__bindgen_ty_6"]
        [::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_6>() - 8usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_6::si_band"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_6, si_band) - 0usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_6::si_fd"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_6, si_fd) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_7 {
    pub _call_addr: *mut ::std::os::raw::c_void,
    pub _syscall: ::std::os::raw::c_int,
    pub _arch: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of siginfo_t__bindgen_ty_1__bindgen_ty_7"]
        [::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_7>() - 16usize];
    ["Alignment of siginfo_t__bindgen_ty_1__bindgen_ty_7"]
        [::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_7>() - 8usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_7::_call_addr"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_7, _call_addr) - 0usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_7::_syscall"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_7, _syscall) - 8usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_7::_arch"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_7, _arch) - 12usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of siginfo_t__bindgen_ty_1"]
        [::std::mem::size_of::<siginfo_t__bindgen_ty_1>() - 112usize];
    ["Alignment of siginfo_t__bindgen_ty_1"]
        [::std::mem::align_of::<siginfo_t__bindgen_ty_1>() - 8usize];
    ["Offset of field: siginfo_t__bindgen_ty_1::_pad"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1, _pad) - 0usize];
    ["Offset of field: siginfo_t__bindgen_ty_1::_kill"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1, _kill) - 0usize];
    ["Offset of field: siginfo_t__bindgen_ty_1::_timer"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1, _timer) - 0usize];
    ["Offset of field: siginfo_t__bindgen_ty_1::_rt"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1, _rt) - 0usize];
    ["Offset of field: siginfo_t__bindgen_ty_1::_sigchld"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1, _sigchld) - 0usize];
    ["Offset of field: siginfo_t__bindgen_ty_1::_sigfault"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1, _sigfault) - 0usize];
    ["Offset of field: siginfo_t__bindgen_ty_1::_sigpoll"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1, _sigpoll) - 0usize];
    ["Offset of field: siginfo_t__bindgen_ty_1::_sigsys"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1, _sigsys) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of siginfo_t"][::std::mem::size_of::<siginfo_t>() - 128usize];
    ["Alignment of siginfo_t"][::std::mem::align_of::<siginfo_t>() - 8usize];
    ["Offset of field: siginfo_t::si_signo"][::std::mem::offset_of!(siginfo_t, si_signo) - 0usize];
    ["Offset of field: siginfo_t::si_errno"][::std::mem::offset_of!(siginfo_t, si_errno) - 4usize];
    ["Offset of field: siginfo_t::si_code"][::std::mem::offset_of!(siginfo_t, si_code) - 8usize];
    ["Offset of field: siginfo_t::__pad0"][::std::mem::offset_of!(siginfo_t, __pad0) - 12usize];
    ["Offset of field: siginfo_t::_sifields"]
        [::std::mem::offset_of!(siginfo_t, _sifields) - 16usize];
};
pub const SI_ASYNCNL: _bindgen_ty_1 = -60;
pub const SI_DETHREAD: _bindgen_ty_1 = -7;
pub const SI_TKILL: _bindgen_ty_1 = -6;
pub const SI_SIGIO: _bindgen_ty_1 = -5;
pub const SI_ASYNCIO: _bindgen_ty_1 = -4;
pub const SI_MESGQ: _bindgen_ty_1 = -3;
pub const SI_TIMER: _bindgen_ty_1 = -2;
pub const SI_QUEUE: _bindgen_ty_1 = -1;
pub const SI_USER: _bindgen_ty_1 = 0;
pub const SI_KERNEL: _bindgen_ty_1 = 128;
pub type _bindgen_ty_1 = ::std::os::raw::c_int;
pub const ILL_ILLOPC: _bindgen_ty_2 = 1;
pub const ILL_ILLOPN: _bindgen_ty_2 = 2;
pub const ILL_ILLADR: _bindgen_ty_2 = 3;
pub const ILL_ILLTRP: _bindgen_ty_2 = 4;
pub const ILL_PRVOPC: _bindgen_ty_2 = 5;
pub const ILL_PRVREG: _bindgen_ty_2 = 6;
pub const ILL_COPROC: _bindgen_ty_2 = 7;
pub const ILL_BADSTK: _bindgen_ty_2 = 8;
pub const ILL_BADIADDR: _bindgen_ty_2 = 9;
pub type _bindgen_ty_2 = ::std::os::raw::c_uint;
pub const FPE_INTDIV: _bindgen_ty_3 = 1;
pub const FPE_INTOVF: _bindgen_ty_3 = 2;
pub const FPE_FLTDIV: _bindgen_ty_3 = 3;
pub const FPE_FLTOVF: _bindgen_ty_3 = 4;
pub const FPE_FLTUND: _bindgen_ty_3 = 5;
pub const FPE_FLTRES: _bindgen_ty_3 = 6;
pub const FPE_FLTINV: _bindgen_ty_3 = 7;
pub const FPE_FLTSUB: _bindgen_ty_3 = 8;
pub const FPE_FLTUNK: _bindgen_ty_3 = 14;
pub const FPE_CONDTRAP: _bindgen_ty_3 = 15;
pub type _bindgen_ty_3 = ::std::os::raw::c_uint;
pub const SEGV_MAPERR: _bindgen_ty_4 = 1;
pub const SEGV_ACCERR: _bindgen_ty_4 = 2;
pub const SEGV_BNDERR: _bindgen_ty_4 = 3;
pub const SEGV_PKUERR: _bindgen_ty_4 = 4;
pub const SEGV_ACCADI: _bindgen_ty_4 = 5;
pub const SEGV_ADIDERR: _bindgen_ty_4 = 6;
pub const SEGV_ADIPERR: _bindgen_ty_4 = 7;
pub const SEGV_MTEAERR: _bindgen_ty_4 = 8;
pub const SEGV_MTESERR: _bindgen_ty_4 = 9;
pub const SEGV_CPERR: _bindgen_ty_4 = 10;
pub type _bindgen_ty_4 = ::std::os::raw::c_uint;
pub const BUS_ADRALN: _bindgen_ty_5 = 1;
pub const BUS_ADRERR: _bindgen_ty_5 = 2;
pub const BUS_OBJERR: _bindgen_ty_5 = 3;
pub const BUS_MCEERR_AR: _bindgen_ty_5 = 4;
pub const BUS_MCEERR_AO: _bindgen_ty_5 = 5;
pub type _bindgen_ty_5 = ::std::os::raw::c_uint;
pub const CLD_EXITED: _bindgen_ty_6 = 1;
pub const CLD_KILLED: _bindgen_ty_6 = 2;
pub const CLD_DUMPED: _bindgen_ty_6 = 3;
pub const CLD_TRAPPED: _bindgen_ty_6 = 4;
pub const CLD_STOPPED: _bindgen_ty_6 = 5;
pub const CLD_CONTINUED: _bindgen_ty_6 = 6;
pub type _bindgen_ty_6 = ::std::os::raw::c_uint;
pub const POLL_IN: _bindgen_ty_7 = 1;
pub const POLL_OUT: _bindgen_ty_7 = 2;
pub const POLL_MSG: _bindgen_ty_7 = 3;
pub const POLL_ERR: _bindgen_ty_7 = 4;
pub const POLL_PRI: _bindgen_ty_7 = 5;
pub const POLL_HUP: _bindgen_ty_7 = 6;
pub type _bindgen_ty_7 = ::std::os::raw::c_uint;
pub type sigval_t = __sigval_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigevent {
    pub sigev_value: __sigval_t,
    pub sigev_signo: ::std::os::raw::c_int,
    pub sigev_notify: ::std::os::raw::c_int,
    pub _sigev_un: sigevent__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigevent__bindgen_ty_1 {
    pub _pad: [::std::os::raw::c_int; 12usize],
    pub _tid: __pid_t,
    pub _sigev_thread: sigevent__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent__bindgen_ty_1__bindgen_ty_1 {
    pub _function: ::std::option::Option<unsafe extern "C" fn(arg1: __sigval_t)>,
    pub _attribute: *mut pthread_attr_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sigevent__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::size_of::<sigevent__bindgen_ty_1__bindgen_ty_1>() - 16usize];
    ["Alignment of sigevent__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::align_of::<sigevent__bindgen_ty_1__bindgen_ty_1>() - 8usize];
    ["Offset of field: sigevent__bindgen_ty_1__bindgen_ty_1::_function"]
        [::std::mem::offset_of!(sigevent__bindgen_ty_1__bindgen_ty_1, _function) - 0usize];
    ["Offset of field: sigevent__bindgen_ty_1__bindgen_ty_1::_attribute"]
        [::std::mem::offset_of!(sigevent__bindgen_ty_1__bindgen_ty_1, _attribute) - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sigevent__bindgen_ty_1"][::std::mem::size_of::<sigevent__bindgen_ty_1>() - 48usize];
    ["Alignment of sigevent__bindgen_ty_1"]
        [::std::mem::align_of::<sigevent__bindgen_ty_1>() - 8usize];
    ["Offset of field: sigevent__bindgen_ty_1::_pad"]
        [::std::mem::offset_of!(sigevent__bindgen_ty_1, _pad) - 0usize];
    ["Offset of field: sigevent__bindgen_ty_1::_tid"]
        [::std::mem::offset_of!(sigevent__bindgen_ty_1, _tid) - 0usize];
    ["Offset of field: sigevent__bindgen_ty_1::_sigev_thread"]
        [::std::mem::offset_of!(sigevent__bindgen_ty_1, _sigev_thread) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sigevent"][::std::mem::size_of::<sigevent>() - 64usize];
    ["Alignment of sigevent"][::std::mem::align_of::<sigevent>() - 8usize];
    ["Offset of field: sigevent::sigev_value"]
        [::std::mem::offset_of!(sigevent, sigev_value) - 0usize];
    ["Offset of field: sigevent::sigev_signo"]
        [::std::mem::offset_of!(sigevent, sigev_signo) - 8usize];
    ["Offset of field: sigevent::sigev_notify"]
        [::std::mem::offset_of!(sigevent, sigev_notify) - 12usize];
    ["Offset of field: sigevent::_sigev_un"][::std::mem::offset_of!(sigevent, _sigev_un) - 16usize];
};
pub type sigevent_t = sigevent;
pub const SIGEV_SIGNAL: _bindgen_ty_8 = 0;
pub const SIGEV_NONE: _bindgen_ty_8 = 1;
pub const SIGEV_THREAD: _bindgen_ty_8 = 2;
pub const SIGEV_THREAD_ID: _bindgen_ty_8 = 4;
pub type _bindgen_ty_8 = ::std::os::raw::c_uint;
pub type __sighandler_t = ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
unsafe extern "C" {
    pub fn __sysv_signal(__sig: ::std::os::raw::c_int, __handler: __sighandler_t)
        -> __sighandler_t;
}
unsafe extern "C" {
    pub fn signal(__sig: ::std::os::raw::c_int, __handler: __sighandler_t) -> __sighandler_t;
}
unsafe extern "C" {
    pub fn kill(__pid: __pid_t, __sig: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn killpg(__pgrp: __pid_t, __sig: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn raise(__sig: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ssignal(__sig: ::std::os::raw::c_int, __handler: __sighandler_t) -> __sighandler_t;
}
unsafe extern "C" {
    pub fn gsignal(__sig: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn psignal(__sig: ::std::os::raw::c_int, __s: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn psiginfo(__pinfo: *const siginfo_t, __s: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn sigblock(__mask: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sigsetmask(__mask: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn siggetmask() -> ::std::os::raw::c_int;
}
pub type sig_t = __sighandler_t;
unsafe extern "C" {
    pub fn sigemptyset(__set: *mut sigset_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sigfillset(__set: *mut sigset_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sigaddset(__set: *mut sigset_t, __signo: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sigdelset(__set: *mut sigset_t, __signo: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sigismember(
        __set: *const sigset_t,
        __signo: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigaction {
    pub __sigaction_handler: sigaction__bindgen_ty_1,
    pub sa_mask: __sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
    pub sa_restorer: ::std::option::Option<unsafe extern "C" fn()>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigaction__bindgen_ty_1 {
    pub sa_handler: __sighandler_t,
    pub sa_sigaction: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut siginfo_t,
            arg3: *mut ::std::os::raw::c_void,
        ),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sigaction__bindgen_ty_1"][::std::mem::size_of::<sigaction__bindgen_ty_1>() - 8usize];
    ["Alignment of sigaction__bindgen_ty_1"]
        [::std::mem::align_of::<sigaction__bindgen_ty_1>() - 8usize];
    ["Offset of field: sigaction__bindgen_ty_1::sa_handler"]
        [::std::mem::offset_of!(sigaction__bindgen_ty_1, sa_handler) - 0usize];
    ["Offset of field: sigaction__bindgen_ty_1::sa_sigaction"]
        [::std::mem::offset_of!(sigaction__bindgen_ty_1, sa_sigaction) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sigaction"][::std::mem::size_of::<sigaction>() - 152usize];
    ["Alignment of sigaction"][::std::mem::align_of::<sigaction>() - 8usize];
    ["Offset of field: sigaction::__sigaction_handler"]
        [::std::mem::offset_of!(sigaction, __sigaction_handler) - 0usize];
    ["Offset of field: sigaction::sa_mask"][::std::mem::offset_of!(sigaction, sa_mask) - 8usize];
    ["Offset of field: sigaction::sa_flags"]
        [::std::mem::offset_of!(sigaction, sa_flags) - 136usize];
    ["Offset of field: sigaction::sa_restorer"]
        [::std::mem::offset_of!(sigaction, sa_restorer) - 144usize];
};
unsafe extern "C" {
    pub fn sigprocmask(
        __how: ::std::os::raw::c_int,
        __set: *const sigset_t,
        __oset: *mut sigset_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sigsuspend(__set: *const sigset_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sigaction(
        __sig: ::std::os::raw::c_int,
        __act: *const sigaction,
        __oact: *mut sigaction,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sigpending(__set: *mut sigset_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sigwait(
        __set: *const sigset_t,
        __sig: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sigwaitinfo(__set: *const sigset_t, __info: *mut siginfo_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sigtimedwait(
        __set: *const sigset_t,
        __info: *mut siginfo_t,
        __timeout: *const timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sigqueue(
        __pid: __pid_t,
        __sig: ::std::os::raw::c_int,
        __val: sigval,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fpx_sw_bytes {
    pub magic1: __uint32_t,
    pub extended_size: __uint32_t,
    pub xstate_bv: __uint64_t,
    pub xstate_size: __uint32_t,
    pub __glibc_reserved1: [__uint32_t; 7usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _fpx_sw_bytes"][::std::mem::size_of::<_fpx_sw_bytes>() - 48usize];
    ["Alignment of _fpx_sw_bytes"][::std::mem::align_of::<_fpx_sw_bytes>() - 8usize];
    ["Offset of field: _fpx_sw_bytes::magic1"]
        [::std::mem::offset_of!(_fpx_sw_bytes, magic1) - 0usize];
    ["Offset of field: _fpx_sw_bytes::extended_size"]
        [::std::mem::offset_of!(_fpx_sw_bytes, extended_size) - 4usize];
    ["Offset of field: _fpx_sw_bytes::xstate_bv"]
        [::std::mem::offset_of!(_fpx_sw_bytes, xstate_bv) - 8usize];
    ["Offset of field: _fpx_sw_bytes::xstate_size"]
        [::std::mem::offset_of!(_fpx_sw_bytes, xstate_size) - 16usize];
    ["Offset of field: _fpx_sw_bytes::__glibc_reserved1"]
        [::std::mem::offset_of!(_fpx_sw_bytes, __glibc_reserved1) - 20usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fpreg {
    pub significand: [::std::os::raw::c_ushort; 4usize],
    pub exponent: ::std::os::raw::c_ushort,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _fpreg"][::std::mem::size_of::<_fpreg>() - 10usize];
    ["Alignment of _fpreg"][::std::mem::align_of::<_fpreg>() - 2usize];
    ["Offset of field: _fpreg::significand"][::std::mem::offset_of!(_fpreg, significand) - 0usize];
    ["Offset of field: _fpreg::exponent"][::std::mem::offset_of!(_fpreg, exponent) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fpxreg {
    pub significand: [::std::os::raw::c_ushort; 4usize],
    pub exponent: ::std::os::raw::c_ushort,
    pub __glibc_reserved1: [::std::os::raw::c_ushort; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _fpxreg"][::std::mem::size_of::<_fpxreg>() - 16usize];
    ["Alignment of _fpxreg"][::std::mem::align_of::<_fpxreg>() - 2usize];
    ["Offset of field: _fpxreg::significand"]
        [::std::mem::offset_of!(_fpxreg, significand) - 0usize];
    ["Offset of field: _fpxreg::exponent"][::std::mem::offset_of!(_fpxreg, exponent) - 8usize];
    ["Offset of field: _fpxreg::__glibc_reserved1"]
        [::std::mem::offset_of!(_fpxreg, __glibc_reserved1) - 10usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmmreg {
    pub element: [__uint32_t; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _xmmreg"][::std::mem::size_of::<_xmmreg>() - 16usize];
    ["Alignment of _xmmreg"][::std::mem::align_of::<_xmmreg>() - 4usize];
    ["Offset of field: _xmmreg::element"][::std::mem::offset_of!(_xmmreg, element) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fpstate {
    pub cwd: __uint16_t,
    pub swd: __uint16_t,
    pub ftw: __uint16_t,
    pub fop: __uint16_t,
    pub rip: __uint64_t,
    pub rdp: __uint64_t,
    pub mxcsr: __uint32_t,
    pub mxcr_mask: __uint32_t,
    pub _st: [_fpxreg; 8usize],
    pub _xmm: [_xmmreg; 16usize],
    pub __glibc_reserved1: [__uint32_t; 24usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _fpstate"][::std::mem::size_of::<_fpstate>() - 512usize];
    ["Alignment of _fpstate"][::std::mem::align_of::<_fpstate>() - 8usize];
    ["Offset of field: _fpstate::cwd"][::std::mem::offset_of!(_fpstate, cwd) - 0usize];
    ["Offset of field: _fpstate::swd"][::std::mem::offset_of!(_fpstate, swd) - 2usize];
    ["Offset of field: _fpstate::ftw"][::std::mem::offset_of!(_fpstate, ftw) - 4usize];
    ["Offset of field: _fpstate::fop"][::std::mem::offset_of!(_fpstate, fop) - 6usize];
    ["Offset of field: _fpstate::rip"][::std::mem::offset_of!(_fpstate, rip) - 8usize];
    ["Offset of field: _fpstate::rdp"][::std::mem::offset_of!(_fpstate, rdp) - 16usize];
    ["Offset of field: _fpstate::mxcsr"][::std::mem::offset_of!(_fpstate, mxcsr) - 24usize];
    ["Offset of field: _fpstate::mxcr_mask"][::std::mem::offset_of!(_fpstate, mxcr_mask) - 28usize];
    ["Offset of field: _fpstate::_st"][::std::mem::offset_of!(_fpstate, _st) - 32usize];
    ["Offset of field: _fpstate::_xmm"][::std::mem::offset_of!(_fpstate, _xmm) - 160usize];
    ["Offset of field: _fpstate::__glibc_reserved1"]
        [::std::mem::offset_of!(_fpstate, __glibc_reserved1) - 416usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigcontext {
    pub r8: __uint64_t,
    pub r9: __uint64_t,
    pub r10: __uint64_t,
    pub r11: __uint64_t,
    pub r12: __uint64_t,
    pub r13: __uint64_t,
    pub r14: __uint64_t,
    pub r15: __uint64_t,
    pub rdi: __uint64_t,
    pub rsi: __uint64_t,
    pub rbp: __uint64_t,
    pub rbx: __uint64_t,
    pub rdx: __uint64_t,
    pub rax: __uint64_t,
    pub rcx: __uint64_t,
    pub rsp: __uint64_t,
    pub rip: __uint64_t,
    pub eflags: __uint64_t,
    pub cs: ::std::os::raw::c_ushort,
    pub gs: ::std::os::raw::c_ushort,
    pub fs: ::std::os::raw::c_ushort,
    pub __pad0: ::std::os::raw::c_ushort,
    pub err: __uint64_t,
    pub trapno: __uint64_t,
    pub oldmask: __uint64_t,
    pub cr2: __uint64_t,
    pub __bindgen_anon_1: sigcontext__bindgen_ty_1,
    pub __reserved1: [__uint64_t; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigcontext__bindgen_ty_1 {
    pub fpstate: *mut _fpstate,
    pub __fpstate_word: __uint64_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sigcontext__bindgen_ty_1"]
        [::std::mem::size_of::<sigcontext__bindgen_ty_1>() - 8usize];
    ["Alignment of sigcontext__bindgen_ty_1"]
        [::std::mem::align_of::<sigcontext__bindgen_ty_1>() - 8usize];
    ["Offset of field: sigcontext__bindgen_ty_1::fpstate"]
        [::std::mem::offset_of!(sigcontext__bindgen_ty_1, fpstate) - 0usize];
    ["Offset of field: sigcontext__bindgen_ty_1::__fpstate_word"]
        [::std::mem::offset_of!(sigcontext__bindgen_ty_1, __fpstate_word) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sigcontext"][::std::mem::size_of::<sigcontext>() - 256usize];
    ["Alignment of sigcontext"][::std::mem::align_of::<sigcontext>() - 8usize];
    ["Offset of field: sigcontext::r8"][::std::mem::offset_of!(sigcontext, r8) - 0usize];
    ["Offset of field: sigcontext::r9"][::std::mem::offset_of!(sigcontext, r9) - 8usize];
    ["Offset of field: sigcontext::r10"][::std::mem::offset_of!(sigcontext, r10) - 16usize];
    ["Offset of field: sigcontext::r11"][::std::mem::offset_of!(sigcontext, r11) - 24usize];
    ["Offset of field: sigcontext::r12"][::std::mem::offset_of!(sigcontext, r12) - 32usize];
    ["Offset of field: sigcontext::r13"][::std::mem::offset_of!(sigcontext, r13) - 40usize];
    ["Offset of field: sigcontext::r14"][::std::mem::offset_of!(sigcontext, r14) - 48usize];
    ["Offset of field: sigcontext::r15"][::std::mem::offset_of!(sigcontext, r15) - 56usize];
    ["Offset of field: sigcontext::rdi"][::std::mem::offset_of!(sigcontext, rdi) - 64usize];
    ["Offset of field: sigcontext::rsi"][::std::mem::offset_of!(sigcontext, rsi) - 72usize];
    ["Offset of field: sigcontext::rbp"][::std::mem::offset_of!(sigcontext, rbp) - 80usize];
    ["Offset of field: sigcontext::rbx"][::std::mem::offset_of!(sigcontext, rbx) - 88usize];
    ["Offset of field: sigcontext::rdx"][::std::mem::offset_of!(sigcontext, rdx) - 96usize];
    ["Offset of field: sigcontext::rax"][::std::mem::offset_of!(sigcontext, rax) - 104usize];
    ["Offset of field: sigcontext::rcx"][::std::mem::offset_of!(sigcontext, rcx) - 112usize];
    ["Offset of field: sigcontext::rsp"][::std::mem::offset_of!(sigcontext, rsp) - 120usize];
    ["Offset of field: sigcontext::rip"][::std::mem::offset_of!(sigcontext, rip) - 128usize];
    ["Offset of field: sigcontext::eflags"][::std::mem::offset_of!(sigcontext, eflags) - 136usize];
    ["Offset of field: sigcontext::cs"][::std::mem::offset_of!(sigcontext, cs) - 144usize];
    ["Offset of field: sigcontext::gs"][::std::mem::offset_of!(sigcontext, gs) - 146usize];
    ["Offset of field: sigcontext::fs"][::std::mem::offset_of!(sigcontext, fs) - 148usize];
    ["Offset of field: sigcontext::__pad0"][::std::mem::offset_of!(sigcontext, __pad0) - 150usize];
    ["Offset of field: sigcontext::err"][::std::mem::offset_of!(sigcontext, err) - 152usize];
    ["Offset of field: sigcontext::trapno"][::std::mem::offset_of!(sigcontext, trapno) - 160usize];
    ["Offset of field: sigcontext::oldmask"]
        [::std::mem::offset_of!(sigcontext, oldmask) - 168usize];
    ["Offset of field: sigcontext::cr2"][::std::mem::offset_of!(sigcontext, cr2) - 176usize];
    ["Offset of field: sigcontext::__reserved1"]
        [::std::mem::offset_of!(sigcontext, __reserved1) - 192usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xsave_hdr {
    pub xstate_bv: __uint64_t,
    pub __glibc_reserved1: [__uint64_t; 2usize],
    pub __glibc_reserved2: [__uint64_t; 5usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _xsave_hdr"][::std::mem::size_of::<_xsave_hdr>() - 64usize];
    ["Alignment of _xsave_hdr"][::std::mem::align_of::<_xsave_hdr>() - 8usize];
    ["Offset of field: _xsave_hdr::xstate_bv"]
        [::std::mem::offset_of!(_xsave_hdr, xstate_bv) - 0usize];
    ["Offset of field: _xsave_hdr::__glibc_reserved1"]
        [::std::mem::offset_of!(_xsave_hdr, __glibc_reserved1) - 8usize];
    ["Offset of field: _xsave_hdr::__glibc_reserved2"]
        [::std::mem::offset_of!(_xsave_hdr, __glibc_reserved2) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ymmh_state {
    pub ymmh_space: [__uint32_t; 64usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ymmh_state"][::std::mem::size_of::<_ymmh_state>() - 256usize];
    ["Alignment of _ymmh_state"][::std::mem::align_of::<_ymmh_state>() - 4usize];
    ["Offset of field: _ymmh_state::ymmh_space"]
        [::std::mem::offset_of!(_ymmh_state, ymmh_space) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xstate {
    pub fpstate: _fpstate,
    pub xstate_hdr: _xsave_hdr,
    pub ymmh: _ymmh_state,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _xstate"][::std::mem::size_of::<_xstate>() - 832usize];
    ["Alignment of _xstate"][::std::mem::align_of::<_xstate>() - 8usize];
    ["Offset of field: _xstate::fpstate"][::std::mem::offset_of!(_xstate, fpstate) - 0usize];
    ["Offset of field: _xstate::xstate_hdr"]
        [::std::mem::offset_of!(_xstate, xstate_hdr) - 512usize];
    ["Offset of field: _xstate::ymmh"][::std::mem::offset_of!(_xstate, ymmh) - 576usize];
};
unsafe extern "C" {
    pub fn sigreturn(__scp: *mut sigcontext) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_t {
    pub ss_sp: *mut ::std::os::raw::c_void,
    pub ss_flags: ::std::os::raw::c_int,
    pub ss_size: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of stack_t"][::std::mem::size_of::<stack_t>() - 24usize];
    ["Alignment of stack_t"][::std::mem::align_of::<stack_t>() - 8usize];
    ["Offset of field: stack_t::ss_sp"][::std::mem::offset_of!(stack_t, ss_sp) - 0usize];
    ["Offset of field: stack_t::ss_flags"][::std::mem::offset_of!(stack_t, ss_flags) - 8usize];
    ["Offset of field: stack_t::ss_size"][::std::mem::offset_of!(stack_t, ss_size) - 16usize];
};
pub type greg_t = ::std::os::raw::c_longlong;
pub type gregset_t = [greg_t; 23usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _libc_fpxreg {
    pub significand: [::std::os::raw::c_ushort; 4usize],
    pub exponent: ::std::os::raw::c_ushort,
    pub __glibc_reserved1: [::std::os::raw::c_ushort; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _libc_fpxreg"][::std::mem::size_of::<_libc_fpxreg>() - 16usize];
    ["Alignment of _libc_fpxreg"][::std::mem::align_of::<_libc_fpxreg>() - 2usize];
    ["Offset of field: _libc_fpxreg::significand"]
        [::std::mem::offset_of!(_libc_fpxreg, significand) - 0usize];
    ["Offset of field: _libc_fpxreg::exponent"]
        [::std::mem::offset_of!(_libc_fpxreg, exponent) - 8usize];
    ["Offset of field: _libc_fpxreg::__glibc_reserved1"]
        [::std::mem::offset_of!(_libc_fpxreg, __glibc_reserved1) - 10usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _libc_xmmreg {
    pub element: [__uint32_t; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _libc_xmmreg"][::std::mem::size_of::<_libc_xmmreg>() - 16usize];
    ["Alignment of _libc_xmmreg"][::std::mem::align_of::<_libc_xmmreg>() - 4usize];
    ["Offset of field: _libc_xmmreg::element"]
        [::std::mem::offset_of!(_libc_xmmreg, element) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _libc_fpstate {
    pub cwd: __uint16_t,
    pub swd: __uint16_t,
    pub ftw: __uint16_t,
    pub fop: __uint16_t,
    pub rip: __uint64_t,
    pub rdp: __uint64_t,
    pub mxcsr: __uint32_t,
    pub mxcr_mask: __uint32_t,
    pub _st: [_libc_fpxreg; 8usize],
    pub _xmm: [_libc_xmmreg; 16usize],
    pub __glibc_reserved1: [__uint32_t; 24usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _libc_fpstate"][::std::mem::size_of::<_libc_fpstate>() - 512usize];
    ["Alignment of _libc_fpstate"][::std::mem::align_of::<_libc_fpstate>() - 8usize];
    ["Offset of field: _libc_fpstate::cwd"][::std::mem::offset_of!(_libc_fpstate, cwd) - 0usize];
    ["Offset of field: _libc_fpstate::swd"][::std::mem::offset_of!(_libc_fpstate, swd) - 2usize];
    ["Offset of field: _libc_fpstate::ftw"][::std::mem::offset_of!(_libc_fpstate, ftw) - 4usize];
    ["Offset of field: _libc_fpstate::fop"][::std::mem::offset_of!(_libc_fpstate, fop) - 6usize];
    ["Offset of field: _libc_fpstate::rip"][::std::mem::offset_of!(_libc_fpstate, rip) - 8usize];
    ["Offset of field: _libc_fpstate::rdp"][::std::mem::offset_of!(_libc_fpstate, rdp) - 16usize];
    ["Offset of field: _libc_fpstate::mxcsr"]
        [::std::mem::offset_of!(_libc_fpstate, mxcsr) - 24usize];
    ["Offset of field: _libc_fpstate::mxcr_mask"]
        [::std::mem::offset_of!(_libc_fpstate, mxcr_mask) - 28usize];
    ["Offset of field: _libc_fpstate::_st"][::std::mem::offset_of!(_libc_fpstate, _st) - 32usize];
    ["Offset of field: _libc_fpstate::_xmm"]
        [::std::mem::offset_of!(_libc_fpstate, _xmm) - 160usize];
    ["Offset of field: _libc_fpstate::__glibc_reserved1"]
        [::std::mem::offset_of!(_libc_fpstate, __glibc_reserved1) - 416usize];
};
pub type fpregset_t = *mut _libc_fpstate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mcontext_t {
    pub gregs: gregset_t,
    pub fpregs: fpregset_t,
    pub __reserved1: [::std::os::raw::c_ulonglong; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of mcontext_t"][::std::mem::size_of::<mcontext_t>() - 256usize];
    ["Alignment of mcontext_t"][::std::mem::align_of::<mcontext_t>() - 8usize];
    ["Offset of field: mcontext_t::gregs"][::std::mem::offset_of!(mcontext_t, gregs) - 0usize];
    ["Offset of field: mcontext_t::fpregs"][::std::mem::offset_of!(mcontext_t, fpregs) - 184usize];
    ["Offset of field: mcontext_t::__reserved1"]
        [::std::mem::offset_of!(mcontext_t, __reserved1) - 192usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucontext_t {
    pub uc_flags: ::std::os::raw::c_ulong,
    pub uc_link: *mut ucontext_t,
    pub uc_stack: stack_t,
    pub uc_mcontext: mcontext_t,
    pub uc_sigmask: sigset_t,
    pub __fpregs_mem: _libc_fpstate,
    pub __ssp: [::std::os::raw::c_ulonglong; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ucontext_t"][::std::mem::size_of::<ucontext_t>() - 968usize];
    ["Alignment of ucontext_t"][::std::mem::align_of::<ucontext_t>() - 8usize];
    ["Offset of field: ucontext_t::uc_flags"]
        [::std::mem::offset_of!(ucontext_t, uc_flags) - 0usize];
    ["Offset of field: ucontext_t::uc_link"][::std::mem::offset_of!(ucontext_t, uc_link) - 8usize];
    ["Offset of field: ucontext_t::uc_stack"]
        [::std::mem::offset_of!(ucontext_t, uc_stack) - 16usize];
    ["Offset of field: ucontext_t::uc_mcontext"]
        [::std::mem::offset_of!(ucontext_t, uc_mcontext) - 40usize];
    ["Offset of field: ucontext_t::uc_sigmask"]
        [::std::mem::offset_of!(ucontext_t, uc_sigmask) - 296usize];
    ["Offset of field: ucontext_t::__fpregs_mem"]
        [::std::mem::offset_of!(ucontext_t, __fpregs_mem) - 424usize];
    ["Offset of field: ucontext_t::__ssp"][::std::mem::offset_of!(ucontext_t, __ssp) - 936usize];
};
unsafe extern "C" {
    pub fn siginterrupt(
        __sig: ::std::os::raw::c_int,
        __interrupt: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub const SS_ONSTACK: _bindgen_ty_9 = 1;
pub const SS_DISABLE: _bindgen_ty_9 = 2;
pub type _bindgen_ty_9 = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn sigaltstack(__ss: *const stack_t, __oss: *mut stack_t) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigstack {
    pub ss_sp: *mut ::std::os::raw::c_void,
    pub ss_onstack: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sigstack"][::std::mem::size_of::<sigstack>() - 16usize];
    ["Alignment of sigstack"][::std::mem::align_of::<sigstack>() - 8usize];
    ["Offset of field: sigstack::ss_sp"][::std::mem::offset_of!(sigstack, ss_sp) - 0usize];
    ["Offset of field: sigstack::ss_onstack"]
        [::std::mem::offset_of!(sigstack, ss_onstack) - 8usize];
};
unsafe extern "C" {
    pub fn sigstack(__ss: *mut sigstack, __oss: *mut sigstack) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __atomic_wide_counter {
    pub __value64: ::std::os::raw::c_ulonglong,
    pub __value32: __atomic_wide_counter__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __atomic_wide_counter__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __atomic_wide_counter__bindgen_ty_1"]
        [::std::mem::size_of::<__atomic_wide_counter__bindgen_ty_1>() - 8usize];
    ["Alignment of __atomic_wide_counter__bindgen_ty_1"]
        [::std::mem::align_of::<__atomic_wide_counter__bindgen_ty_1>() - 4usize];
    ["Offset of field: __atomic_wide_counter__bindgen_ty_1::__low"]
        [::std::mem::offset_of!(__atomic_wide_counter__bindgen_ty_1, __low) - 0usize];
    ["Offset of field: __atomic_wide_counter__bindgen_ty_1::__high"]
        [::std::mem::offset_of!(__atomic_wide_counter__bindgen_ty_1, __high) - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __atomic_wide_counter"][::std::mem::size_of::<__atomic_wide_counter>() - 8usize];
    ["Alignment of __atomic_wide_counter"]
        [::std::mem::align_of::<__atomic_wide_counter>() - 8usize];
    ["Offset of field: __atomic_wide_counter::__value64"]
        [::std::mem::offset_of!(__atomic_wide_counter, __value64) - 0usize];
    ["Offset of field: __atomic_wide_counter::__value32"]
        [::std::mem::offset_of!(__atomic_wide_counter, __value32) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_internal_list"][::std::mem::size_of::<__pthread_internal_list>() - 16usize];
    ["Alignment of __pthread_internal_list"]
        [::std::mem::align_of::<__pthread_internal_list>() - 8usize];
    ["Offset of field: __pthread_internal_list::__prev"]
        [::std::mem::offset_of!(__pthread_internal_list, __prev) - 0usize];
    ["Offset of field: __pthread_internal_list::__next"]
        [::std::mem::offset_of!(__pthread_internal_list, __next) - 8usize];
};
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_internal_slist"]
        [::std::mem::size_of::<__pthread_internal_slist>() - 8usize];
    ["Alignment of __pthread_internal_slist"]
        [::std::mem::align_of::<__pthread_internal_slist>() - 8usize];
    ["Offset of field: __pthread_internal_slist::__next"]
        [::std::mem::offset_of!(__pthread_internal_slist, __next) - 0usize];
};
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_mutex_s"][::std::mem::size_of::<__pthread_mutex_s>() - 40usize];
    ["Alignment of __pthread_mutex_s"][::std::mem::align_of::<__pthread_mutex_s>() - 8usize];
    ["Offset of field: __pthread_mutex_s::__lock"]
        [::std::mem::offset_of!(__pthread_mutex_s, __lock) - 0usize];
    ["Offset of field: __pthread_mutex_s::__count"]
        [::std::mem::offset_of!(__pthread_mutex_s, __count) - 4usize];
    ["Offset of field: __pthread_mutex_s::__owner"]
        [::std::mem::offset_of!(__pthread_mutex_s, __owner) - 8usize];
    ["Offset of field: __pthread_mutex_s::__nusers"]
        [::std::mem::offset_of!(__pthread_mutex_s, __nusers) - 12usize];
    ["Offset of field: __pthread_mutex_s::__kind"]
        [::std::mem::offset_of!(__pthread_mutex_s, __kind) - 16usize];
    ["Offset of field: __pthread_mutex_s::__spins"]
        [::std::mem::offset_of!(__pthread_mutex_s, __spins) - 20usize];
    ["Offset of field: __pthread_mutex_s::__elision"]
        [::std::mem::offset_of!(__pthread_mutex_s, __elision) - 22usize];
    ["Offset of field: __pthread_mutex_s::__list"]
        [::std::mem::offset_of!(__pthread_mutex_s, __list) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_rwlock_arch_t"][::std::mem::size_of::<__pthread_rwlock_arch_t>() - 56usize];
    ["Alignment of __pthread_rwlock_arch_t"]
        [::std::mem::align_of::<__pthread_rwlock_arch_t>() - 8usize];
    ["Offset of field: __pthread_rwlock_arch_t::__readers"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __readers) - 0usize];
    ["Offset of field: __pthread_rwlock_arch_t::__writers"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __writers) - 4usize];
    ["Offset of field: __pthread_rwlock_arch_t::__wrphase_futex"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __wrphase_futex) - 8usize];
    ["Offset of field: __pthread_rwlock_arch_t::__writers_futex"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __writers_futex) - 12usize];
    ["Offset of field: __pthread_rwlock_arch_t::__pad3"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __pad3) - 16usize];
    ["Offset of field: __pthread_rwlock_arch_t::__pad4"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __pad4) - 20usize];
    ["Offset of field: __pthread_rwlock_arch_t::__cur_writer"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __cur_writer) - 24usize];
    ["Offset of field: __pthread_rwlock_arch_t::__shared"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __shared) - 28usize];
    ["Offset of field: __pthread_rwlock_arch_t::__rwelision"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __rwelision) - 32usize];
    ["Offset of field: __pthread_rwlock_arch_t::__pad1"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __pad1) - 33usize];
    ["Offset of field: __pthread_rwlock_arch_t::__pad2"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __pad2) - 40usize];
    ["Offset of field: __pthread_rwlock_arch_t::__flags"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __flags) - 48usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __wseq: __atomic_wide_counter,
    pub __g1_start: __atomic_wide_counter,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_cond_s"][::std::mem::size_of::<__pthread_cond_s>() - 48usize];
    ["Alignment of __pthread_cond_s"][::std::mem::align_of::<__pthread_cond_s>() - 8usize];
    ["Offset of field: __pthread_cond_s::__wseq"]
        [::std::mem::offset_of!(__pthread_cond_s, __wseq) - 0usize];
    ["Offset of field: __pthread_cond_s::__g1_start"]
        [::std::mem::offset_of!(__pthread_cond_s, __g1_start) - 8usize];
    ["Offset of field: __pthread_cond_s::__g_refs"]
        [::std::mem::offset_of!(__pthread_cond_s, __g_refs) - 16usize];
    ["Offset of field: __pthread_cond_s::__g_size"]
        [::std::mem::offset_of!(__pthread_cond_s, __g_size) - 24usize];
    ["Offset of field: __pthread_cond_s::__g1_orig_size"]
        [::std::mem::offset_of!(__pthread_cond_s, __g1_orig_size) - 32usize];
    ["Offset of field: __pthread_cond_s::__wrefs"]
        [::std::mem::offset_of!(__pthread_cond_s, __wrefs) - 36usize];
    ["Offset of field: __pthread_cond_s::__g_signals"]
        [::std::mem::offset_of!(__pthread_cond_s, __g_signals) - 40usize];
};
pub type __tss_t = ::std::os::raw::c_uint;
pub type __thrd_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __once_flag {
    pub __data: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __once_flag"][::std::mem::size_of::<__once_flag>() - 4usize];
    ["Alignment of __once_flag"][::std::mem::align_of::<__once_flag>() - 4usize];
    ["Offset of field: __once_flag::__data"][::std::mem::offset_of!(__once_flag, __data) - 0usize];
};
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_mutexattr_t"][::std::mem::size_of::<pthread_mutexattr_t>() - 4usize];
    ["Alignment of pthread_mutexattr_t"][::std::mem::align_of::<pthread_mutexattr_t>() - 4usize];
    ["Offset of field: pthread_mutexattr_t::__size"]
        [::std::mem::offset_of!(pthread_mutexattr_t, __size) - 0usize];
    ["Offset of field: pthread_mutexattr_t::__align"]
        [::std::mem::offset_of!(pthread_mutexattr_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_condattr_t"][::std::mem::size_of::<pthread_condattr_t>() - 4usize];
    ["Alignment of pthread_condattr_t"][::std::mem::align_of::<pthread_condattr_t>() - 4usize];
    ["Offset of field: pthread_condattr_t::__size"]
        [::std::mem::offset_of!(pthread_condattr_t, __size) - 0usize];
    ["Offset of field: pthread_condattr_t::__align"]
        [::std::mem::offset_of!(pthread_condattr_t, __align) - 0usize];
};
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_attr_t"][::std::mem::size_of::<pthread_attr_t>() - 56usize];
    ["Alignment of pthread_attr_t"][::std::mem::align_of::<pthread_attr_t>() - 8usize];
    ["Offset of field: pthread_attr_t::__size"]
        [::std::mem::offset_of!(pthread_attr_t, __size) - 0usize];
    ["Offset of field: pthread_attr_t::__align"]
        [::std::mem::offset_of!(pthread_attr_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_mutex_t"][::std::mem::size_of::<pthread_mutex_t>() - 40usize];
    ["Alignment of pthread_mutex_t"][::std::mem::align_of::<pthread_mutex_t>() - 8usize];
    ["Offset of field: pthread_mutex_t::__data"]
        [::std::mem::offset_of!(pthread_mutex_t, __data) - 0usize];
    ["Offset of field: pthread_mutex_t::__size"]
        [::std::mem::offset_of!(pthread_mutex_t, __size) - 0usize];
    ["Offset of field: pthread_mutex_t::__align"]
        [::std::mem::offset_of!(pthread_mutex_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_cond_t"][::std::mem::size_of::<pthread_cond_t>() - 48usize];
    ["Alignment of pthread_cond_t"][::std::mem::align_of::<pthread_cond_t>() - 8usize];
    ["Offset of field: pthread_cond_t::__data"]
        [::std::mem::offset_of!(pthread_cond_t, __data) - 0usize];
    ["Offset of field: pthread_cond_t::__size"]
        [::std::mem::offset_of!(pthread_cond_t, __size) - 0usize];
    ["Offset of field: pthread_cond_t::__align"]
        [::std::mem::offset_of!(pthread_cond_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_rwlock_t"][::std::mem::size_of::<pthread_rwlock_t>() - 56usize];
    ["Alignment of pthread_rwlock_t"][::std::mem::align_of::<pthread_rwlock_t>() - 8usize];
    ["Offset of field: pthread_rwlock_t::__data"]
        [::std::mem::offset_of!(pthread_rwlock_t, __data) - 0usize];
    ["Offset of field: pthread_rwlock_t::__size"]
        [::std::mem::offset_of!(pthread_rwlock_t, __size) - 0usize];
    ["Offset of field: pthread_rwlock_t::__align"]
        [::std::mem::offset_of!(pthread_rwlock_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_rwlockattr_t"][::std::mem::size_of::<pthread_rwlockattr_t>() - 8usize];
    ["Alignment of pthread_rwlockattr_t"][::std::mem::align_of::<pthread_rwlockattr_t>() - 8usize];
    ["Offset of field: pthread_rwlockattr_t::__size"]
        [::std::mem::offset_of!(pthread_rwlockattr_t, __size) - 0usize];
    ["Offset of field: pthread_rwlockattr_t::__align"]
        [::std::mem::offset_of!(pthread_rwlockattr_t, __align) - 0usize];
};
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_barrier_t"][::std::mem::size_of::<pthread_barrier_t>() - 32usize];
    ["Alignment of pthread_barrier_t"][::std::mem::align_of::<pthread_barrier_t>() - 8usize];
    ["Offset of field: pthread_barrier_t::__size"]
        [::std::mem::offset_of!(pthread_barrier_t, __size) - 0usize];
    ["Offset of field: pthread_barrier_t::__align"]
        [::std::mem::offset_of!(pthread_barrier_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_barrierattr_t"][::std::mem::size_of::<pthread_barrierattr_t>() - 4usize];
    ["Alignment of pthread_barrierattr_t"]
        [::std::mem::align_of::<pthread_barrierattr_t>() - 4usize];
    ["Offset of field: pthread_barrierattr_t::__size"]
        [::std::mem::offset_of!(pthread_barrierattr_t, __size) - 0usize];
    ["Offset of field: pthread_barrierattr_t::__align"]
        [::std::mem::offset_of!(pthread_barrierattr_t, __align) - 0usize];
};
unsafe extern "C" {
    pub fn pthread_sigmask(
        __how: ::std::os::raw::c_int,
        __newmask: *const __sigset_t,
        __oldmask: *mut __sigset_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_kill(
        __threadid: pthread_t,
        __signo: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __libc_current_sigrtmin() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __libc_current_sigrtmax() -> ::std::os::raw::c_int;
}
pub type wchar_t = ::std::os::raw::c_int;
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of div_t"][::std::mem::size_of::<div_t>() - 8usize];
    ["Alignment of div_t"][::std::mem::align_of::<div_t>() - 4usize];
    ["Offset of field: div_t::quot"][::std::mem::offset_of!(div_t, quot) - 0usize];
    ["Offset of field: div_t::rem"][::std::mem::offset_of!(div_t, rem) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ldiv_t"][::std::mem::size_of::<ldiv_t>() - 16usize];
    ["Alignment of ldiv_t"][::std::mem::align_of::<ldiv_t>() - 8usize];
    ["Offset of field: ldiv_t::quot"][::std::mem::offset_of!(ldiv_t, quot) - 0usize];
    ["Offset of field: ldiv_t::rem"][::std::mem::offset_of!(ldiv_t, rem) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of lldiv_t"][::std::mem::size_of::<lldiv_t>() - 16usize];
    ["Alignment of lldiv_t"][::std::mem::align_of::<lldiv_t>() - 8usize];
    ["Offset of field: lldiv_t::quot"][::std::mem::offset_of!(lldiv_t, quot) - 0usize];
    ["Offset of field: lldiv_t::rem"][::std::mem::offset_of!(lldiv_t, rem) - 8usize];
};
unsafe extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
unsafe extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
unsafe extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn strtod(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
unsafe extern "C" {
    pub fn strtof(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
unsafe extern "C" {
    pub fn strtold(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> u128;
}
unsafe extern "C" {
    pub fn strtol(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn strtoul(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strtoq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn strtouq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
unsafe extern "C" {
    pub fn strtoll(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn strtoull(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
unsafe extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type off_t = __off_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of timeval"][::std::mem::size_of::<timeval>() - 16usize];
    ["Alignment of timeval"][::std::mem::align_of::<timeval>() - 8usize];
    ["Offset of field: timeval::tv_sec"][::std::mem::offset_of!(timeval, tv_sec) - 0usize];
    ["Offset of field: timeval::tv_usec"][::std::mem::offset_of!(timeval, tv_usec) - 8usize];
};
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of fd_set"][::std::mem::size_of::<fd_set>() - 128usize];
    ["Alignment of fd_set"][::std::mem::align_of::<fd_set>() - 8usize];
    ["Offset of field: fd_set::__fds_bits"][::std::mem::offset_of!(fd_set, __fds_bits) - 0usize];
};
pub type fd_mask = __fd_mask;
unsafe extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
unsafe extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    pub fn initstate(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of random_data"][::std::mem::size_of::<random_data>() - 48usize];
    ["Alignment of random_data"][::std::mem::align_of::<random_data>() - 8usize];
    ["Offset of field: random_data::fptr"][::std::mem::offset_of!(random_data, fptr) - 0usize];
    ["Offset of field: random_data::rptr"][::std::mem::offset_of!(random_data, rptr) - 8usize];
    ["Offset of field: random_data::state"][::std::mem::offset_of!(random_data, state) - 16usize];
    ["Offset of field: random_data::rand_type"]
        [::std::mem::offset_of!(random_data, rand_type) - 24usize];
    ["Offset of field: random_data::rand_deg"]
        [::std::mem::offset_of!(random_data, rand_deg) - 28usize];
    ["Offset of field: random_data::rand_sep"]
        [::std::mem::offset_of!(random_data, rand_sep) - 32usize];
    ["Offset of field: random_data::end_ptr"]
        [::std::mem::offset_of!(random_data, end_ptr) - 40usize];
};
unsafe extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn srandom_r(
        __seed: ::std::os::raw::c_uint,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn initstate_r(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setstate_r(
        __statebuf: *mut ::std::os::raw::c_char,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn drand48() -> f64;
}
unsafe extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
unsafe extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
unsafe extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
unsafe extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of drand48_data"][::std::mem::size_of::<drand48_data>() - 24usize];
    ["Alignment of drand48_data"][::std::mem::align_of::<drand48_data>() - 8usize];
    ["Offset of field: drand48_data::__x"][::std::mem::offset_of!(drand48_data, __x) - 0usize];
    ["Offset of field: drand48_data::__old_x"]
        [::std::mem::offset_of!(drand48_data, __old_x) - 6usize];
    ["Offset of field: drand48_data::__c"][::std::mem::offset_of!(drand48_data, __c) - 12usize];
    ["Offset of field: drand48_data::__init"]
        [::std::mem::offset_of!(drand48_data, __init) - 14usize];
    ["Offset of field: drand48_data::__a"][::std::mem::offset_of!(drand48_data, __a) - 16usize];
};
unsafe extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn erand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn lrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn srand48_r(
        __seedval: ::std::os::raw::c_long,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn seed48_r(
        __seed16v: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn lcong48_r(
        __param: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn arc4random() -> __uint32_t;
}
unsafe extern "C" {
    pub fn arc4random_buf(__buf: *mut ::std::os::raw::c_void, __size: usize);
}
unsafe extern "C" {
    pub fn arc4random_uniform(__upper_bound: __uint32_t) -> __uint32_t;
}
unsafe extern "C" {
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn calloc(
        __nmemb: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn reallocarray(
        __ptr: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn alloca(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn valloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: usize,
        __size: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aligned_alloc(
        __alignment: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn abort() -> !;
}
unsafe extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn at_quick_exit(
        __func: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn on_exit(
        __func: ::std::option::Option<
            unsafe extern "C" fn(
                __status: ::std::os::raw::c_int,
                __arg: *mut ::std::os::raw::c_void,
            ),
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int) -> !;
}
unsafe extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int) -> !;
}
unsafe extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int) -> !;
}
unsafe extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __replace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mkstemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn realpath(
        __name: *const ::std::os::raw::c_char,
        __resolved: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
unsafe extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    );
}
unsafe extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
}
unsafe extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
}
unsafe extern "C" {
    pub fn lldiv(
        __numer: ::std::os::raw::c_longlong,
        __denom: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
unsafe extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn gcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn qecvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn qfcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn qgcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn qecvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn qfcvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mbtowc(
        __pwc: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const ::std::os::raw::c_char, __n: usize) -> usize;
}
unsafe extern "C" {
    pub fn wcstombs(__s: *mut ::std::os::raw::c_char, __pwcs: *const wchar_t, __n: usize) -> usize;
}
unsafe extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut ::std::os::raw::c_char,
        __tokens: *const *mut ::std::os::raw::c_char,
        __valuep: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn memcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn memmove(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn memccpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn memset(
        __s: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __memcmpeq(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn memchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn strcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strcat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strncat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strxfrm(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __locale_struct"][::std::mem::size_of::<__locale_struct>() - 232usize];
    ["Alignment of __locale_struct"][::std::mem::align_of::<__locale_struct>() - 8usize];
    ["Offset of field: __locale_struct::__locales"]
        [::std::mem::offset_of!(__locale_struct, __locales) - 0usize];
    ["Offset of field: __locale_struct::__ctype_b"]
        [::std::mem::offset_of!(__locale_struct, __ctype_b) - 104usize];
    ["Offset of field: __locale_struct::__ctype_tolower"]
        [::std::mem::offset_of!(__locale_struct, __ctype_tolower) - 112usize];
    ["Offset of field: __locale_struct::__ctype_toupper"]
        [::std::mem::offset_of!(__locale_struct, __ctype_toupper) - 120usize];
    ["Offset of field: __locale_struct::__names"]
        [::std::mem::offset_of!(__locale_struct, __names) - 128usize];
};
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
unsafe extern "C" {
    pub fn strcoll_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __l: locale_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strxfrm_l(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
        __l: locale_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn strdup(__s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strndup(
        __string: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strrchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strchrnul(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __reject: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strpbrk(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strstr(
        __haystack: *const ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strtok(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn __strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strcasestr(
        __haystack: *const ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn memmem(
        __haystack: *const ::std::os::raw::c_void,
        __haystacklen: usize,
        __needle: *const ::std::os::raw::c_void,
        __needlelen: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn __mempcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn mempcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strnlen(__string: *const ::std::os::raw::c_char, __maxlen: usize) -> usize;
}
unsafe extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strerror_l(
        __errnum: ::std::os::raw::c_int,
        __l: locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn bcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn bcopy(
        __src: *const ::std::os::raw::c_void,
        __dest: *mut ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    );
}
unsafe extern "C" {
    pub fn bzero(__s: *mut ::std::os::raw::c_void, __n: ::std::os::raw::c_ulong);
}
unsafe extern "C" {
    pub fn index(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn rindex(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ffs(__i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ffsl(__l: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ffsll(__ll: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strcasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strncasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strcasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strncasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: usize,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn explicit_bzero(__s: *mut ::std::os::raw::c_void, __n: usize);
}
unsafe extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn __stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn __stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strlcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strlcat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of max_align_t"][::std::mem::size_of::<max_align_t>() - 32usize];
    ["Alignment of max_align_t"][::std::mem::align_of::<max_align_t>() - 16usize];
    ["Offset of field: max_align_t::__clang_max_align_nonce1"]
        [::std::mem::offset_of!(max_align_t, __clang_max_align_nonce1) - 0usize];
    ["Offset of field: max_align_t::__clang_max_align_nonce2"]
        [::std::mem::offset_of!(max_align_t, __clang_max_align_nonce2) - 16usize];
};
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __mbstate_t__bindgen_ty_1"]
        [::std::mem::size_of::<__mbstate_t__bindgen_ty_1>() - 4usize];
    ["Alignment of __mbstate_t__bindgen_ty_1"]
        [::std::mem::align_of::<__mbstate_t__bindgen_ty_1>() - 4usize];
    ["Offset of field: __mbstate_t__bindgen_ty_1::__wch"]
        [::std::mem::offset_of!(__mbstate_t__bindgen_ty_1, __wch) - 0usize];
    ["Offset of field: __mbstate_t__bindgen_ty_1::__wchb"]
        [::std::mem::offset_of!(__mbstate_t__bindgen_ty_1, __wchb) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __mbstate_t"][::std::mem::size_of::<__mbstate_t>() - 8usize];
    ["Alignment of __mbstate_t"][::std::mem::align_of::<__mbstate_t>() - 4usize];
    ["Offset of field: __mbstate_t::__count"]
        [::std::mem::offset_of!(__mbstate_t, __count) - 0usize];
    ["Offset of field: __mbstate_t::__value"]
        [::std::mem::offset_of!(__mbstate_t, __value) - 4usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _G_fpos_t"][::std::mem::size_of::<_G_fpos_t>() - 16usize];
    ["Alignment of _G_fpos_t"][::std::mem::align_of::<_G_fpos_t>() - 8usize];
    ["Offset of field: _G_fpos_t::__pos"][::std::mem::offset_of!(_G_fpos_t, __pos) - 0usize];
    ["Offset of field: _G_fpos_t::__state"][::std::mem::offset_of!(_G_fpos_t, __state) - 8usize];
};
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _G_fpos64_t"][::std::mem::size_of::<_G_fpos64_t>() - 16usize];
    ["Alignment of _G_fpos64_t"][::std::mem::align_of::<_G_fpos64_t>() - 8usize];
    ["Offset of field: _G_fpos64_t::__pos"][::std::mem::offset_of!(_G_fpos64_t, __pos) - 0usize];
    ["Offset of field: _G_fpos64_t::__state"]
        [::std::mem::offset_of!(_G_fpos64_t, __state) - 8usize];
};
pub type __fpos64_t = _G_fpos64_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub _prevchain: *mut *mut _IO_FILE,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _IO_FILE"][::std::mem::size_of::<_IO_FILE>() - 216usize];
    ["Alignment of _IO_FILE"][::std::mem::align_of::<_IO_FILE>() - 8usize];
    ["Offset of field: _IO_FILE::_flags"][::std::mem::offset_of!(_IO_FILE, _flags) - 0usize];
    ["Offset of field: _IO_FILE::_IO_read_ptr"]
        [::std::mem::offset_of!(_IO_FILE, _IO_read_ptr) - 8usize];
    ["Offset of field: _IO_FILE::_IO_read_end"]
        [::std::mem::offset_of!(_IO_FILE, _IO_read_end) - 16usize];
    ["Offset of field: _IO_FILE::_IO_read_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_read_base) - 24usize];
    ["Offset of field: _IO_FILE::_IO_write_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_write_base) - 32usize];
    ["Offset of field: _IO_FILE::_IO_write_ptr"]
        [::std::mem::offset_of!(_IO_FILE, _IO_write_ptr) - 40usize];
    ["Offset of field: _IO_FILE::_IO_write_end"]
        [::std::mem::offset_of!(_IO_FILE, _IO_write_end) - 48usize];
    ["Offset of field: _IO_FILE::_IO_buf_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_buf_base) - 56usize];
    ["Offset of field: _IO_FILE::_IO_buf_end"]
        [::std::mem::offset_of!(_IO_FILE, _IO_buf_end) - 64usize];
    ["Offset of field: _IO_FILE::_IO_save_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_save_base) - 72usize];
    ["Offset of field: _IO_FILE::_IO_backup_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_backup_base) - 80usize];
    ["Offset of field: _IO_FILE::_IO_save_end"]
        [::std::mem::offset_of!(_IO_FILE, _IO_save_end) - 88usize];
    ["Offset of field: _IO_FILE::_markers"][::std::mem::offset_of!(_IO_FILE, _markers) - 96usize];
    ["Offset of field: _IO_FILE::_chain"][::std::mem::offset_of!(_IO_FILE, _chain) - 104usize];
    ["Offset of field: _IO_FILE::_fileno"][::std::mem::offset_of!(_IO_FILE, _fileno) - 112usize];
    ["Offset of field: _IO_FILE::_flags2"][::std::mem::offset_of!(_IO_FILE, _flags2) - 116usize];
    ["Offset of field: _IO_FILE::_old_offset"]
        [::std::mem::offset_of!(_IO_FILE, _old_offset) - 120usize];
    ["Offset of field: _IO_FILE::_cur_column"]
        [::std::mem::offset_of!(_IO_FILE, _cur_column) - 128usize];
    ["Offset of field: _IO_FILE::_vtable_offset"]
        [::std::mem::offset_of!(_IO_FILE, _vtable_offset) - 130usize];
    ["Offset of field: _IO_FILE::_shortbuf"]
        [::std::mem::offset_of!(_IO_FILE, _shortbuf) - 131usize];
    ["Offset of field: _IO_FILE::_lock"][::std::mem::offset_of!(_IO_FILE, _lock) - 136usize];
    ["Offset of field: _IO_FILE::_offset"][::std::mem::offset_of!(_IO_FILE, _offset) - 144usize];
    ["Offset of field: _IO_FILE::_codecvt"][::std::mem::offset_of!(_IO_FILE, _codecvt) - 152usize];
    ["Offset of field: _IO_FILE::_wide_data"]
        [::std::mem::offset_of!(_IO_FILE, _wide_data) - 160usize];
    ["Offset of field: _IO_FILE::_freeres_list"]
        [::std::mem::offset_of!(_IO_FILE, _freeres_list) - 168usize];
    ["Offset of field: _IO_FILE::_freeres_buf"]
        [::std::mem::offset_of!(_IO_FILE, _freeres_buf) - 176usize];
    ["Offset of field: _IO_FILE::_prevchain"]
        [::std::mem::offset_of!(_IO_FILE, _prevchain) - 184usize];
    ["Offset of field: _IO_FILE::_mode"][::std::mem::offset_of!(_IO_FILE, _mode) - 192usize];
    ["Offset of field: _IO_FILE::_unused2"][::std::mem::offset_of!(_IO_FILE, _unused2) - 196usize];
};
pub type cookie_read_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *mut ::std::os::raw::c_char,
        __nbytes: usize,
    ) -> __ssize_t,
>;
pub type cookie_write_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *const ::std::os::raw::c_char,
        __nbytes: usize,
    ) -> __ssize_t,
>;
pub type cookie_seek_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __pos: *mut __off64_t,
        __w: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type cookie_close_function_t = ::std::option::Option<
    unsafe extern "C" fn(__cookie: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_cookie_io_functions_t {
    pub read: cookie_read_function_t,
    pub write: cookie_write_function_t,
    pub seek: cookie_seek_function_t,
    pub close: cookie_close_function_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _IO_cookie_io_functions_t"]
        [::std::mem::size_of::<_IO_cookie_io_functions_t>() - 32usize];
    ["Alignment of _IO_cookie_io_functions_t"]
        [::std::mem::align_of::<_IO_cookie_io_functions_t>() - 8usize];
    ["Offset of field: _IO_cookie_io_functions_t::read"]
        [::std::mem::offset_of!(_IO_cookie_io_functions_t, read) - 0usize];
    ["Offset of field: _IO_cookie_io_functions_t::write"]
        [::std::mem::offset_of!(_IO_cookie_io_functions_t, write) - 8usize];
    ["Offset of field: _IO_cookie_io_functions_t::seek"]
        [::std::mem::offset_of!(_IO_cookie_io_functions_t, seek) - 16usize];
    ["Offset of field: _IO_cookie_io_functions_t::close"]
        [::std::mem::offset_of!(_IO_cookie_io_functions_t, close) - 24usize];
};
pub type cookie_io_functions_t = _IO_cookie_io_functions_t;
pub type va_list = __gnuc_va_list;
pub type fpos_t = __fpos_t;
unsafe extern "C" {
    pub static mut stdin: *mut FILE;
}
unsafe extern "C" {
    pub static mut stdout: *mut FILE;
}
unsafe extern "C" {
    pub static mut stderr: *mut FILE;
}
unsafe extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
unsafe extern "C" {
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
        -> *mut FILE;
}
unsafe extern "C" {
    pub fn fopencookie(
        __magic_cookie: *mut ::std::os::raw::c_void,
        __modes: *const ::std::os::raw::c_char,
        __io_funcs: cookie_io_functions_t,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn fmemopen(
        __s: *mut ::std::os::raw::c_void,
        __len: usize,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut usize,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: usize);
}
unsafe extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
unsafe extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vasprintf(
        __ptr: *mut *mut ::std::os::raw::c_char,
        __f: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __asprintf(
        __ptr: *mut *mut ::std::os::raw::c_char,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn asprintf(
        __ptr: *mut *mut ::std::os::raw::c_char,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
        -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
unsafe extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
unsafe extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
unsafe extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __s: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
unsafe extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
unsafe extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
unsafe extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
unsafe extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
unsafe extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
unsafe extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
unsafe extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
unsafe extern "C" {
    pub fn __uflow(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __overflow(arg1: *mut FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
pub const spa_direction_SPA_DIRECTION_INPUT: spa_direction = 0;
pub const spa_direction_SPA_DIRECTION_OUTPUT: spa_direction = 1;
pub type spa_direction = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_rectangle {
    pub width: u32,
    pub height: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_rectangle"][::std::mem::size_of::<spa_rectangle>() - 8usize];
    ["Alignment of spa_rectangle"][::std::mem::align_of::<spa_rectangle>() - 4usize];
    ["Offset of field: spa_rectangle::width"]
        [::std::mem::offset_of!(spa_rectangle, width) - 0usize];
    ["Offset of field: spa_rectangle::height"]
        [::std::mem::offset_of!(spa_rectangle, height) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_point {
    pub x: i32,
    pub y: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_point"][::std::mem::size_of::<spa_point>() - 8usize];
    ["Alignment of spa_point"][::std::mem::align_of::<spa_point>() - 4usize];
    ["Offset of field: spa_point::x"][::std::mem::offset_of!(spa_point, x) - 0usize];
    ["Offset of field: spa_point::y"][::std::mem::offset_of!(spa_point, y) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_region {
    pub position: spa_point,
    pub size: spa_rectangle,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_region"][::std::mem::size_of::<spa_region>() - 16usize];
    ["Alignment of spa_region"][::std::mem::align_of::<spa_region>() - 4usize];
    ["Offset of field: spa_region::position"]
        [::std::mem::offset_of!(spa_region, position) - 0usize];
    ["Offset of field: spa_region::size"][::std::mem::offset_of!(spa_region, size) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_fraction {
    pub num: u32,
    pub denom: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_fraction"][::std::mem::size_of::<spa_fraction>() - 8usize];
    ["Alignment of spa_fraction"][::std::mem::align_of::<spa_fraction>() - 4usize];
    ["Offset of field: spa_fraction::num"][::std::mem::offset_of!(spa_fraction, num) - 0usize];
    ["Offset of field: spa_fraction::denom"][::std::mem::offset_of!(spa_fraction, denom) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_error_location {
    pub line: ::std::os::raw::c_int,
    pub col: ::std::os::raw::c_int,
    pub len: usize,
    pub location: *const ::std::os::raw::c_char,
    pub reason: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_error_location"][::std::mem::size_of::<spa_error_location>() - 32usize];
    ["Alignment of spa_error_location"][::std::mem::align_of::<spa_error_location>() - 8usize];
    ["Offset of field: spa_error_location::line"]
        [::std::mem::offset_of!(spa_error_location, line) - 0usize];
    ["Offset of field: spa_error_location::col"]
        [::std::mem::offset_of!(spa_error_location, col) - 4usize];
    ["Offset of field: spa_error_location::len"]
        [::std::mem::offset_of!(spa_error_location, len) - 8usize];
    ["Offset of field: spa_error_location::location"]
        [::std::mem::offset_of!(spa_error_location, location) - 16usize];
    ["Offset of field: spa_error_location::reason"]
        [::std::mem::offset_of!(spa_error_location, reason) - 24usize];
};
unsafe extern "C" {
    pub fn __errno_location() -> *mut ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lconv {
    pub decimal_point: *mut ::std::os::raw::c_char,
    pub thousands_sep: *mut ::std::os::raw::c_char,
    pub grouping: *mut ::std::os::raw::c_char,
    pub int_curr_symbol: *mut ::std::os::raw::c_char,
    pub currency_symbol: *mut ::std::os::raw::c_char,
    pub mon_decimal_point: *mut ::std::os::raw::c_char,
    pub mon_thousands_sep: *mut ::std::os::raw::c_char,
    pub mon_grouping: *mut ::std::os::raw::c_char,
    pub positive_sign: *mut ::std::os::raw::c_char,
    pub negative_sign: *mut ::std::os::raw::c_char,
    pub int_frac_digits: ::std::os::raw::c_char,
    pub frac_digits: ::std::os::raw::c_char,
    pub p_cs_precedes: ::std::os::raw::c_char,
    pub p_sep_by_space: ::std::os::raw::c_char,
    pub n_cs_precedes: ::std::os::raw::c_char,
    pub n_sep_by_space: ::std::os::raw::c_char,
    pub p_sign_posn: ::std::os::raw::c_char,
    pub n_sign_posn: ::std::os::raw::c_char,
    pub int_p_cs_precedes: ::std::os::raw::c_char,
    pub int_p_sep_by_space: ::std::os::raw::c_char,
    pub int_n_cs_precedes: ::std::os::raw::c_char,
    pub int_n_sep_by_space: ::std::os::raw::c_char,
    pub int_p_sign_posn: ::std::os::raw::c_char,
    pub int_n_sign_posn: ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of lconv"][::std::mem::size_of::<lconv>() - 96usize];
    ["Alignment of lconv"][::std::mem::align_of::<lconv>() - 8usize];
    ["Offset of field: lconv::decimal_point"]
        [::std::mem::offset_of!(lconv, decimal_point) - 0usize];
    ["Offset of field: lconv::thousands_sep"]
        [::std::mem::offset_of!(lconv, thousands_sep) - 8usize];
    ["Offset of field: lconv::grouping"][::std::mem::offset_of!(lconv, grouping) - 16usize];
    ["Offset of field: lconv::int_curr_symbol"]
        [::std::mem::offset_of!(lconv, int_curr_symbol) - 24usize];
    ["Offset of field: lconv::currency_symbol"]
        [::std::mem::offset_of!(lconv, currency_symbol) - 32usize];
    ["Offset of field: lconv::mon_decimal_point"]
        [::std::mem::offset_of!(lconv, mon_decimal_point) - 40usize];
    ["Offset of field: lconv::mon_thousands_sep"]
        [::std::mem::offset_of!(lconv, mon_thousands_sep) - 48usize];
    ["Offset of field: lconv::mon_grouping"][::std::mem::offset_of!(lconv, mon_grouping) - 56usize];
    ["Offset of field: lconv::positive_sign"]
        [::std::mem::offset_of!(lconv, positive_sign) - 64usize];
    ["Offset of field: lconv::negative_sign"]
        [::std::mem::offset_of!(lconv, negative_sign) - 72usize];
    ["Offset of field: lconv::int_frac_digits"]
        [::std::mem::offset_of!(lconv, int_frac_digits) - 80usize];
    ["Offset of field: lconv::frac_digits"][::std::mem::offset_of!(lconv, frac_digits) - 81usize];
    ["Offset of field: lconv::p_cs_precedes"]
        [::std::mem::offset_of!(lconv, p_cs_precedes) - 82usize];
    ["Offset of field: lconv::p_sep_by_space"]
        [::std::mem::offset_of!(lconv, p_sep_by_space) - 83usize];
    ["Offset of field: lconv::n_cs_precedes"]
        [::std::mem::offset_of!(lconv, n_cs_precedes) - 84usize];
    ["Offset of field: lconv::n_sep_by_space"]
        [::std::mem::offset_of!(lconv, n_sep_by_space) - 85usize];
    ["Offset of field: lconv::p_sign_posn"][::std::mem::offset_of!(lconv, p_sign_posn) - 86usize];
    ["Offset of field: lconv::n_sign_posn"][::std::mem::offset_of!(lconv, n_sign_posn) - 87usize];
    ["Offset of field: lconv::int_p_cs_precedes"]
        [::std::mem::offset_of!(lconv, int_p_cs_precedes) - 88usize];
    ["Offset of field: lconv::int_p_sep_by_space"]
        [::std::mem::offset_of!(lconv, int_p_sep_by_space) - 89usize];
    ["Offset of field: lconv::int_n_cs_precedes"]
        [::std::mem::offset_of!(lconv, int_n_cs_precedes) - 90usize];
    ["Offset of field: lconv::int_n_sep_by_space"]
        [::std::mem::offset_of!(lconv, int_n_sep_by_space) - 91usize];
    ["Offset of field: lconv::int_p_sign_posn"]
        [::std::mem::offset_of!(lconv, int_p_sign_posn) - 92usize];
    ["Offset of field: lconv::int_n_sign_posn"]
        [::std::mem::offset_of!(lconv, int_n_sign_posn) - 93usize];
};
unsafe extern "C" {
    pub fn setlocale(
        __category: ::std::os::raw::c_int,
        __locale: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn localeconv() -> *mut lconv;
}
unsafe extern "C" {
    pub fn newlocale(
        __category_mask: ::std::os::raw::c_int,
        __locale: *const ::std::os::raw::c_char,
        __base: locale_t,
    ) -> locale_t;
}
unsafe extern "C" {
    pub fn duplocale(__dataset: locale_t) -> locale_t;
}
unsafe extern "C" {
    pub fn freelocale(__dataset: locale_t);
}
unsafe extern "C" {
    pub fn uselocale(__dataset: locale_t) -> locale_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_strbuf {
    pub buffer: *mut ::std::os::raw::c_char,
    pub maxsize: usize,
    pub pos: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_strbuf"][::std::mem::size_of::<spa_strbuf>() - 24usize];
    ["Alignment of spa_strbuf"][::std::mem::align_of::<spa_strbuf>() - 8usize];
    ["Offset of field: spa_strbuf::buffer"][::std::mem::offset_of!(spa_strbuf, buffer) - 0usize];
    ["Offset of field: spa_strbuf::maxsize"][::std::mem::offset_of!(spa_strbuf, maxsize) - 8usize];
    ["Offset of field: spa_strbuf::pos"][::std::mem::offset_of!(spa_strbuf, pos) - 16usize];
};
pub const SPA_TYPE_START: _bindgen_ty_10 = 0;
pub const SPA_TYPE_None: _bindgen_ty_10 = 1;
pub const SPA_TYPE_Bool: _bindgen_ty_10 = 2;
pub const SPA_TYPE_Id: _bindgen_ty_10 = 3;
pub const SPA_TYPE_Int: _bindgen_ty_10 = 4;
pub const SPA_TYPE_Long: _bindgen_ty_10 = 5;
pub const SPA_TYPE_Float: _bindgen_ty_10 = 6;
pub const SPA_TYPE_Double: _bindgen_ty_10 = 7;
pub const SPA_TYPE_String: _bindgen_ty_10 = 8;
pub const SPA_TYPE_Bytes: _bindgen_ty_10 = 9;
pub const SPA_TYPE_Rectangle: _bindgen_ty_10 = 10;
pub const SPA_TYPE_Fraction: _bindgen_ty_10 = 11;
pub const SPA_TYPE_Bitmap: _bindgen_ty_10 = 12;
pub const SPA_TYPE_Array: _bindgen_ty_10 = 13;
pub const SPA_TYPE_Struct: _bindgen_ty_10 = 14;
pub const SPA_TYPE_Object: _bindgen_ty_10 = 15;
pub const SPA_TYPE_Sequence: _bindgen_ty_10 = 16;
pub const SPA_TYPE_Pointer: _bindgen_ty_10 = 17;
pub const SPA_TYPE_Fd: _bindgen_ty_10 = 18;
pub const SPA_TYPE_Choice: _bindgen_ty_10 = 19;
pub const SPA_TYPE_Pod: _bindgen_ty_10 = 20;
#[doc = "< not part of ABI"]
pub const _SPA_TYPE_LAST: _bindgen_ty_10 = 21;
pub const SPA_TYPE_POINTER_START: _bindgen_ty_10 = 65536;
pub const SPA_TYPE_POINTER_Buffer: _bindgen_ty_10 = 65537;
pub const SPA_TYPE_POINTER_Meta: _bindgen_ty_10 = 65538;
pub const SPA_TYPE_POINTER_Dict: _bindgen_ty_10 = 65539;
#[doc = "< not part of ABI"]
pub const _SPA_TYPE_POINTER_LAST: _bindgen_ty_10 = 65540;
pub const SPA_TYPE_EVENT_START: _bindgen_ty_10 = 131072;
pub const SPA_TYPE_EVENT_Device: _bindgen_ty_10 = 131073;
pub const SPA_TYPE_EVENT_Node: _bindgen_ty_10 = 131074;
#[doc = "< not part of ABI"]
pub const _SPA_TYPE_EVENT_LAST: _bindgen_ty_10 = 131075;
pub const SPA_TYPE_COMMAND_START: _bindgen_ty_10 = 196608;
pub const SPA_TYPE_COMMAND_Device: _bindgen_ty_10 = 196609;
pub const SPA_TYPE_COMMAND_Node: _bindgen_ty_10 = 196610;
#[doc = "< not part of ABI"]
pub const _SPA_TYPE_COMMAND_LAST: _bindgen_ty_10 = 196611;
pub const SPA_TYPE_OBJECT_START: _bindgen_ty_10 = 262144;
pub const SPA_TYPE_OBJECT_PropInfo: _bindgen_ty_10 = 262145;
pub const SPA_TYPE_OBJECT_Props: _bindgen_ty_10 = 262146;
pub const SPA_TYPE_OBJECT_Format: _bindgen_ty_10 = 262147;
pub const SPA_TYPE_OBJECT_ParamBuffers: _bindgen_ty_10 = 262148;
pub const SPA_TYPE_OBJECT_ParamMeta: _bindgen_ty_10 = 262149;
pub const SPA_TYPE_OBJECT_ParamIO: _bindgen_ty_10 = 262150;
pub const SPA_TYPE_OBJECT_ParamProfile: _bindgen_ty_10 = 262151;
pub const SPA_TYPE_OBJECT_ParamPortConfig: _bindgen_ty_10 = 262152;
pub const SPA_TYPE_OBJECT_ParamRoute: _bindgen_ty_10 = 262153;
pub const SPA_TYPE_OBJECT_Profiler: _bindgen_ty_10 = 262154;
pub const SPA_TYPE_OBJECT_ParamLatency: _bindgen_ty_10 = 262155;
pub const SPA_TYPE_OBJECT_ParamProcessLatency: _bindgen_ty_10 = 262156;
pub const SPA_TYPE_OBJECT_ParamTag: _bindgen_ty_10 = 262157;
#[doc = "< not part of ABI"]
pub const _SPA_TYPE_OBJECT_LAST: _bindgen_ty_10 = 262158;
pub const SPA_TYPE_VENDOR_PipeWire: _bindgen_ty_10 = 33554432;
pub const SPA_TYPE_VENDOR_Other: _bindgen_ty_10 = 2130706432;
#[doc = " \\addtogroup spa_types\n \\{"]
pub type _bindgen_ty_10 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_type_info {
    pub type_: u32,
    pub parent: u32,
    pub name: *const ::std::os::raw::c_char,
    pub values: *const spa_type_info,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_type_info"][::std::mem::size_of::<spa_type_info>() - 24usize];
    ["Alignment of spa_type_info"][::std::mem::align_of::<spa_type_info>() - 8usize];
    ["Offset of field: spa_type_info::type_"]
        [::std::mem::offset_of!(spa_type_info, type_) - 0usize];
    ["Offset of field: spa_type_info::parent"]
        [::std::mem::offset_of!(spa_type_info, parent) - 4usize];
    ["Offset of field: spa_type_info::name"][::std::mem::offset_of!(spa_type_info, name) - 8usize];
    ["Offset of field: spa_type_info::values"]
        [::std::mem::offset_of!(spa_type_info, values) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_pod {
    pub size: u32,
    pub type_: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod"][::std::mem::size_of::<spa_pod>() - 8usize];
    ["Alignment of spa_pod"][::std::mem::align_of::<spa_pod>() - 4usize];
    ["Offset of field: spa_pod::size"][::std::mem::offset_of!(spa_pod, size) - 0usize];
    ["Offset of field: spa_pod::type_"][::std::mem::offset_of!(spa_pod, type_) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_pod_bool {
    pub pod: spa_pod,
    pub value: i32,
    pub _padding: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_bool"][::std::mem::size_of::<spa_pod_bool>() - 16usize];
    ["Alignment of spa_pod_bool"][::std::mem::align_of::<spa_pod_bool>() - 4usize];
    ["Offset of field: spa_pod_bool::pod"][::std::mem::offset_of!(spa_pod_bool, pod) - 0usize];
    ["Offset of field: spa_pod_bool::value"][::std::mem::offset_of!(spa_pod_bool, value) - 8usize];
    ["Offset of field: spa_pod_bool::_padding"]
        [::std::mem::offset_of!(spa_pod_bool, _padding) - 12usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_pod_id {
    pub pod: spa_pod,
    pub value: u32,
    pub _padding: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_id"][::std::mem::size_of::<spa_pod_id>() - 16usize];
    ["Alignment of spa_pod_id"][::std::mem::align_of::<spa_pod_id>() - 4usize];
    ["Offset of field: spa_pod_id::pod"][::std::mem::offset_of!(spa_pod_id, pod) - 0usize];
    ["Offset of field: spa_pod_id::value"][::std::mem::offset_of!(spa_pod_id, value) - 8usize];
    ["Offset of field: spa_pod_id::_padding"]
        [::std::mem::offset_of!(spa_pod_id, _padding) - 12usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_pod_int {
    pub pod: spa_pod,
    pub value: i32,
    pub _padding: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_int"][::std::mem::size_of::<spa_pod_int>() - 16usize];
    ["Alignment of spa_pod_int"][::std::mem::align_of::<spa_pod_int>() - 4usize];
    ["Offset of field: spa_pod_int::pod"][::std::mem::offset_of!(spa_pod_int, pod) - 0usize];
    ["Offset of field: spa_pod_int::value"][::std::mem::offset_of!(spa_pod_int, value) - 8usize];
    ["Offset of field: spa_pod_int::_padding"]
        [::std::mem::offset_of!(spa_pod_int, _padding) - 12usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_pod_long {
    pub pod: spa_pod,
    pub value: i64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_long"][::std::mem::size_of::<spa_pod_long>() - 16usize];
    ["Alignment of spa_pod_long"][::std::mem::align_of::<spa_pod_long>() - 8usize];
    ["Offset of field: spa_pod_long::pod"][::std::mem::offset_of!(spa_pod_long, pod) - 0usize];
    ["Offset of field: spa_pod_long::value"][::std::mem::offset_of!(spa_pod_long, value) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_pod_float {
    pub pod: spa_pod,
    pub value: f32,
    pub _padding: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_float"][::std::mem::size_of::<spa_pod_float>() - 16usize];
    ["Alignment of spa_pod_float"][::std::mem::align_of::<spa_pod_float>() - 4usize];
    ["Offset of field: spa_pod_float::pod"][::std::mem::offset_of!(spa_pod_float, pod) - 0usize];
    ["Offset of field: spa_pod_float::value"]
        [::std::mem::offset_of!(spa_pod_float, value) - 8usize];
    ["Offset of field: spa_pod_float::_padding"]
        [::std::mem::offset_of!(spa_pod_float, _padding) - 12usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_pod_double {
    pub pod: spa_pod,
    pub value: f64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_double"][::std::mem::size_of::<spa_pod_double>() - 16usize];
    ["Alignment of spa_pod_double"][::std::mem::align_of::<spa_pod_double>() - 8usize];
    ["Offset of field: spa_pod_double::pod"][::std::mem::offset_of!(spa_pod_double, pod) - 0usize];
    ["Offset of field: spa_pod_double::value"]
        [::std::mem::offset_of!(spa_pod_double, value) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_pod_string {
    pub pod: spa_pod,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_string"][::std::mem::size_of::<spa_pod_string>() - 8usize];
    ["Alignment of spa_pod_string"][::std::mem::align_of::<spa_pod_string>() - 4usize];
    ["Offset of field: spa_pod_string::pod"][::std::mem::offset_of!(spa_pod_string, pod) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_pod_bytes {
    pub pod: spa_pod,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_bytes"][::std::mem::size_of::<spa_pod_bytes>() - 8usize];
    ["Alignment of spa_pod_bytes"][::std::mem::align_of::<spa_pod_bytes>() - 4usize];
    ["Offset of field: spa_pod_bytes::pod"][::std::mem::offset_of!(spa_pod_bytes, pod) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_pod_rectangle {
    pub pod: spa_pod,
    pub value: spa_rectangle,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_rectangle"][::std::mem::size_of::<spa_pod_rectangle>() - 16usize];
    ["Alignment of spa_pod_rectangle"][::std::mem::align_of::<spa_pod_rectangle>() - 4usize];
    ["Offset of field: spa_pod_rectangle::pod"]
        [::std::mem::offset_of!(spa_pod_rectangle, pod) - 0usize];
    ["Offset of field: spa_pod_rectangle::value"]
        [::std::mem::offset_of!(spa_pod_rectangle, value) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_pod_fraction {
    pub pod: spa_pod,
    pub value: spa_fraction,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_fraction"][::std::mem::size_of::<spa_pod_fraction>() - 16usize];
    ["Alignment of spa_pod_fraction"][::std::mem::align_of::<spa_pod_fraction>() - 4usize];
    ["Offset of field: spa_pod_fraction::pod"]
        [::std::mem::offset_of!(spa_pod_fraction, pod) - 0usize];
    ["Offset of field: spa_pod_fraction::value"]
        [::std::mem::offset_of!(spa_pod_fraction, value) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_pod_bitmap {
    pub pod: spa_pod,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_bitmap"][::std::mem::size_of::<spa_pod_bitmap>() - 8usize];
    ["Alignment of spa_pod_bitmap"][::std::mem::align_of::<spa_pod_bitmap>() - 4usize];
    ["Offset of field: spa_pod_bitmap::pod"][::std::mem::offset_of!(spa_pod_bitmap, pod) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_pod_array_body {
    pub child: spa_pod,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_array_body"][::std::mem::size_of::<spa_pod_array_body>() - 8usize];
    ["Alignment of spa_pod_array_body"][::std::mem::align_of::<spa_pod_array_body>() - 4usize];
    ["Offset of field: spa_pod_array_body::child"]
        [::std::mem::offset_of!(spa_pod_array_body, child) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_pod_array {
    pub pod: spa_pod,
    pub body: spa_pod_array_body,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_array"][::std::mem::size_of::<spa_pod_array>() - 16usize];
    ["Alignment of spa_pod_array"][::std::mem::align_of::<spa_pod_array>() - 4usize];
    ["Offset of field: spa_pod_array::pod"][::std::mem::offset_of!(spa_pod_array, pod) - 0usize];
    ["Offset of field: spa_pod_array::body"][::std::mem::offset_of!(spa_pod_array, body) - 8usize];
};
#[doc = "< no choice, first value is current"]
pub const spa_choice_type_SPA_CHOICE_None: spa_choice_type = 0;
#[doc = "< range: default, min, max"]
pub const spa_choice_type_SPA_CHOICE_Range: spa_choice_type = 1;
#[doc = "< range with step: default, min, max, step"]
pub const spa_choice_type_SPA_CHOICE_Step: spa_choice_type = 2;
#[doc = "< list: default, alternative,..."]
pub const spa_choice_type_SPA_CHOICE_Enum: spa_choice_type = 3;
#[doc = "< flags: default, possible flags,..."]
pub const spa_choice_type_SPA_CHOICE_Flags: spa_choice_type = 4;
pub type spa_choice_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_pod_choice_body {
    #[doc = "< type of choice, one of enum spa_choice_type"]
    pub type_: u32,
    #[doc = "< extra flags"]
    pub flags: u32,
    pub child: spa_pod,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_choice_body"][::std::mem::size_of::<spa_pod_choice_body>() - 16usize];
    ["Alignment of spa_pod_choice_body"][::std::mem::align_of::<spa_pod_choice_body>() - 4usize];
    ["Offset of field: spa_pod_choice_body::type_"]
        [::std::mem::offset_of!(spa_pod_choice_body, type_) - 0usize];
    ["Offset of field: spa_pod_choice_body::flags"]
        [::std::mem::offset_of!(spa_pod_choice_body, flags) - 4usize];
    ["Offset of field: spa_pod_choice_body::child"]
        [::std::mem::offset_of!(spa_pod_choice_body, child) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_pod_choice {
    pub pod: spa_pod,
    pub body: spa_pod_choice_body,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_choice"][::std::mem::size_of::<spa_pod_choice>() - 24usize];
    ["Alignment of spa_pod_choice"][::std::mem::align_of::<spa_pod_choice>() - 4usize];
    ["Offset of field: spa_pod_choice::pod"][::std::mem::offset_of!(spa_pod_choice, pod) - 0usize];
    ["Offset of field: spa_pod_choice::body"]
        [::std::mem::offset_of!(spa_pod_choice, body) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_pod_struct {
    pub pod: spa_pod,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_struct"][::std::mem::size_of::<spa_pod_struct>() - 8usize];
    ["Alignment of spa_pod_struct"][::std::mem::align_of::<spa_pod_struct>() - 4usize];
    ["Offset of field: spa_pod_struct::pod"][::std::mem::offset_of!(spa_pod_struct, pod) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_pod_object_body {
    #[doc = "< one of enum spa_type"]
    pub type_: u32,
    #[doc = "< id of the object, depends on the object type"]
    pub id: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_object_body"][::std::mem::size_of::<spa_pod_object_body>() - 8usize];
    ["Alignment of spa_pod_object_body"][::std::mem::align_of::<spa_pod_object_body>() - 4usize];
    ["Offset of field: spa_pod_object_body::type_"]
        [::std::mem::offset_of!(spa_pod_object_body, type_) - 0usize];
    ["Offset of field: spa_pod_object_body::id"]
        [::std::mem::offset_of!(spa_pod_object_body, id) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_pod_object {
    pub pod: spa_pod,
    pub body: spa_pod_object_body,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_object"][::std::mem::size_of::<spa_pod_object>() - 16usize];
    ["Alignment of spa_pod_object"][::std::mem::align_of::<spa_pod_object>() - 4usize];
    ["Offset of field: spa_pod_object::pod"][::std::mem::offset_of!(spa_pod_object, pod) - 0usize];
    ["Offset of field: spa_pod_object::body"]
        [::std::mem::offset_of!(spa_pod_object, body) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_pod_pointer_body {
    #[doc = "< pointer id, one of enum spa_type"]
    pub type_: u32,
    pub _padding: u32,
    pub value: *const ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_pointer_body"][::std::mem::size_of::<spa_pod_pointer_body>() - 16usize];
    ["Alignment of spa_pod_pointer_body"][::std::mem::align_of::<spa_pod_pointer_body>() - 8usize];
    ["Offset of field: spa_pod_pointer_body::type_"]
        [::std::mem::offset_of!(spa_pod_pointer_body, type_) - 0usize];
    ["Offset of field: spa_pod_pointer_body::_padding"]
        [::std::mem::offset_of!(spa_pod_pointer_body, _padding) - 4usize];
    ["Offset of field: spa_pod_pointer_body::value"]
        [::std::mem::offset_of!(spa_pod_pointer_body, value) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_pod_pointer {
    pub pod: spa_pod,
    pub body: spa_pod_pointer_body,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_pointer"][::std::mem::size_of::<spa_pod_pointer>() - 24usize];
    ["Alignment of spa_pod_pointer"][::std::mem::align_of::<spa_pod_pointer>() - 8usize];
    ["Offset of field: spa_pod_pointer::pod"]
        [::std::mem::offset_of!(spa_pod_pointer, pod) - 0usize];
    ["Offset of field: spa_pod_pointer::body"]
        [::std::mem::offset_of!(spa_pod_pointer, body) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_pod_fd {
    pub pod: spa_pod,
    pub value: i64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_fd"][::std::mem::size_of::<spa_pod_fd>() - 16usize];
    ["Alignment of spa_pod_fd"][::std::mem::align_of::<spa_pod_fd>() - 8usize];
    ["Offset of field: spa_pod_fd::pod"][::std::mem::offset_of!(spa_pod_fd, pod) - 0usize];
    ["Offset of field: spa_pod_fd::value"][::std::mem::offset_of!(spa_pod_fd, value) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_pod_prop {
    #[doc = "< key of property, list of valid keys depends on the\n  object type"]
    pub key: u32,
    #[doc = "< flags for property"]
    pub flags: u32,
    pub value: spa_pod,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_prop"][::std::mem::size_of::<spa_pod_prop>() - 16usize];
    ["Alignment of spa_pod_prop"][::std::mem::align_of::<spa_pod_prop>() - 4usize];
    ["Offset of field: spa_pod_prop::key"][::std::mem::offset_of!(spa_pod_prop, key) - 0usize];
    ["Offset of field: spa_pod_prop::flags"][::std::mem::offset_of!(spa_pod_prop, flags) - 4usize];
    ["Offset of field: spa_pod_prop::value"][::std::mem::offset_of!(spa_pod_prop, value) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_pod_control {
    #[doc = "< media offset"]
    pub offset: u32,
    #[doc = "< type of control, enum spa_control_type"]
    pub type_: u32,
    #[doc = "< control value, depends on type"]
    pub value: spa_pod,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_control"][::std::mem::size_of::<spa_pod_control>() - 16usize];
    ["Alignment of spa_pod_control"][::std::mem::align_of::<spa_pod_control>() - 4usize];
    ["Offset of field: spa_pod_control::offset"]
        [::std::mem::offset_of!(spa_pod_control, offset) - 0usize];
    ["Offset of field: spa_pod_control::type_"]
        [::std::mem::offset_of!(spa_pod_control, type_) - 4usize];
    ["Offset of field: spa_pod_control::value"]
        [::std::mem::offset_of!(spa_pod_control, value) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_pod_sequence_body {
    pub unit: u32,
    pub pad: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_sequence_body"][::std::mem::size_of::<spa_pod_sequence_body>() - 8usize];
    ["Alignment of spa_pod_sequence_body"]
        [::std::mem::align_of::<spa_pod_sequence_body>() - 4usize];
    ["Offset of field: spa_pod_sequence_body::unit"]
        [::std::mem::offset_of!(spa_pod_sequence_body, unit) - 0usize];
    ["Offset of field: spa_pod_sequence_body::pad"]
        [::std::mem::offset_of!(spa_pod_sequence_body, pad) - 4usize];
};
#[doc = " a sequence of timed controls"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_pod_sequence {
    pub pod: spa_pod,
    pub body: spa_pod_sequence_body,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_sequence"][::std::mem::size_of::<spa_pod_sequence>() - 16usize];
    ["Alignment of spa_pod_sequence"][::std::mem::align_of::<spa_pod_sequence>() - 4usize];
    ["Offset of field: spa_pod_sequence::pod"]
        [::std::mem::offset_of!(spa_pod_sequence, pod) - 0usize];
    ["Offset of field: spa_pod_sequence::body"]
        [::std::mem::offset_of!(spa_pod_sequence, body) - 8usize];
};
pub const spa_meta_type_SPA_META_Invalid: spa_meta_type = 0;
#[doc = "< struct spa_meta_header"]
pub const spa_meta_type_SPA_META_Header: spa_meta_type = 1;
#[doc = "< struct spa_meta_region with cropping data"]
pub const spa_meta_type_SPA_META_VideoCrop: spa_meta_type = 2;
#[doc = "< array of struct spa_meta_region with damage, where an invalid entry or end-of-array marks the end."]
pub const spa_meta_type_SPA_META_VideoDamage: spa_meta_type = 3;
#[doc = "< struct spa_meta_bitmap"]
pub const spa_meta_type_SPA_META_Bitmap: spa_meta_type = 4;
#[doc = "< struct spa_meta_cursor"]
pub const spa_meta_type_SPA_META_Cursor: spa_meta_type = 5;
#[doc = "< metadata contains a spa_meta_control\n  associated with the data"]
pub const spa_meta_type_SPA_META_Control: spa_meta_type = 6;
#[doc = "< don't write to buffer when count > 0"]
pub const spa_meta_type_SPA_META_Busy: spa_meta_type = 7;
#[doc = "< struct spa_meta_transform"]
pub const spa_meta_type_SPA_META_VideoTransform: spa_meta_type = 8;
#[doc = "< struct spa_meta_sync_timeline"]
pub const spa_meta_type_SPA_META_SyncTimeline: spa_meta_type = 9;
#[doc = "< not part of ABI/API"]
pub const spa_meta_type__SPA_META_LAST: spa_meta_type = 10;
#[doc = " \\addtogroup spa_buffer\n \\{"]
pub type spa_meta_type = ::std::os::raw::c_uint;
#[doc = " A metadata element.\n\n This structure is available on the buffer structure and contains\n the type of the metadata and a pointer/size to the actual metadata\n itself."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_meta {
    #[doc = "< metadata type, one of enum spa_meta_type"]
    pub type_: u32,
    #[doc = "< size of metadata"]
    pub size: u32,
    #[doc = "< pointer to metadata"]
    pub data: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_meta"][::std::mem::size_of::<spa_meta>() - 16usize];
    ["Alignment of spa_meta"][::std::mem::align_of::<spa_meta>() - 8usize];
    ["Offset of field: spa_meta::type_"][::std::mem::offset_of!(spa_meta, type_) - 0usize];
    ["Offset of field: spa_meta::size"][::std::mem::offset_of!(spa_meta, size) - 4usize];
    ["Offset of field: spa_meta::data"][::std::mem::offset_of!(spa_meta, data) - 8usize];
};
#[doc = " Describes essential buffer header metadata such as flags and\n timestamps."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_meta_header {
    #[doc = "< flags"]
    pub flags: u32,
    #[doc = "< offset in current cycle"]
    pub offset: u32,
    #[doc = "< presentation timestamp in nanoseconds"]
    pub pts: i64,
    #[doc = "< decoding timestamp as a difference with pts"]
    pub dts_offset: i64,
    #[doc = "< sequence number, increments with a\n  media specific frequency"]
    pub seq: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_meta_header"][::std::mem::size_of::<spa_meta_header>() - 32usize];
    ["Alignment of spa_meta_header"][::std::mem::align_of::<spa_meta_header>() - 8usize];
    ["Offset of field: spa_meta_header::flags"]
        [::std::mem::offset_of!(spa_meta_header, flags) - 0usize];
    ["Offset of field: spa_meta_header::offset"]
        [::std::mem::offset_of!(spa_meta_header, offset) - 4usize];
    ["Offset of field: spa_meta_header::pts"]
        [::std::mem::offset_of!(spa_meta_header, pts) - 8usize];
    ["Offset of field: spa_meta_header::dts_offset"]
        [::std::mem::offset_of!(spa_meta_header, dts_offset) - 16usize];
    ["Offset of field: spa_meta_header::seq"]
        [::std::mem::offset_of!(spa_meta_header, seq) - 24usize];
};
#[doc = " metadata structure for Region or an array of these for RegionArray"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_meta_region {
    pub region: spa_region,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_meta_region"][::std::mem::size_of::<spa_meta_region>() - 16usize];
    ["Alignment of spa_meta_region"][::std::mem::align_of::<spa_meta_region>() - 4usize];
    ["Offset of field: spa_meta_region::region"]
        [::std::mem::offset_of!(spa_meta_region, region) - 0usize];
};
#[doc = " Bitmap information\n\n This metadata contains a bitmap image in the given format and size.\n It is typically used for cursor images or other small images that are\n better transferred inline."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_meta_bitmap {
    #[doc = "< bitmap video format, one of enum spa_video_format. 0 is\n  and invalid format and should be handled as if there is\n  no new bitmap information."]
    pub format: u32,
    #[doc = "< width and height of bitmap"]
    pub size: spa_rectangle,
    #[doc = "< stride of bitmap data"]
    pub stride: i32,
    #[doc = "< offset of bitmap data in this structure. An offset of\n  0 means no image data (invisible), an offset >=\n  sizeof(struct spa_meta_bitmap) contains valid bitmap\n  info."]
    pub offset: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_meta_bitmap"][::std::mem::size_of::<spa_meta_bitmap>() - 20usize];
    ["Alignment of spa_meta_bitmap"][::std::mem::align_of::<spa_meta_bitmap>() - 4usize];
    ["Offset of field: spa_meta_bitmap::format"]
        [::std::mem::offset_of!(spa_meta_bitmap, format) - 0usize];
    ["Offset of field: spa_meta_bitmap::size"]
        [::std::mem::offset_of!(spa_meta_bitmap, size) - 4usize];
    ["Offset of field: spa_meta_bitmap::stride"]
        [::std::mem::offset_of!(spa_meta_bitmap, stride) - 12usize];
    ["Offset of field: spa_meta_bitmap::offset"]
        [::std::mem::offset_of!(spa_meta_bitmap, offset) - 16usize];
};
#[doc = " Cursor information\n\n Metadata to describe the position and appearance of a pointing device."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_meta_cursor {
    #[doc = "< cursor id. an id of 0 is an invalid id and means that\n  there is no new cursor data"]
    pub id: u32,
    #[doc = "< extra flags"]
    pub flags: u32,
    #[doc = "< position on screen"]
    pub position: spa_point,
    #[doc = "< offsets for hotspot in bitmap, this field has no meaning\n  when there is no valid bitmap (see below)"]
    pub hotspot: spa_point,
    #[doc = "< offset of bitmap meta in this structure. When the offset\n  is 0, there is no new bitmap information. When the offset is\n  >= sizeof(struct spa_meta_cursor) there is a\n  struct spa_meta_bitmap at the offset."]
    pub bitmap_offset: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_meta_cursor"][::std::mem::size_of::<spa_meta_cursor>() - 28usize];
    ["Alignment of spa_meta_cursor"][::std::mem::align_of::<spa_meta_cursor>() - 4usize];
    ["Offset of field: spa_meta_cursor::id"][::std::mem::offset_of!(spa_meta_cursor, id) - 0usize];
    ["Offset of field: spa_meta_cursor::flags"]
        [::std::mem::offset_of!(spa_meta_cursor, flags) - 4usize];
    ["Offset of field: spa_meta_cursor::position"]
        [::std::mem::offset_of!(spa_meta_cursor, position) - 8usize];
    ["Offset of field: spa_meta_cursor::hotspot"]
        [::std::mem::offset_of!(spa_meta_cursor, hotspot) - 16usize];
    ["Offset of field: spa_meta_cursor::bitmap_offset"]
        [::std::mem::offset_of!(spa_meta_cursor, bitmap_offset) - 24usize];
};
#[doc = " a timed set of events associated with the buffer"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_meta_control {
    pub sequence: spa_pod_sequence,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_meta_control"][::std::mem::size_of::<spa_meta_control>() - 16usize];
    ["Alignment of spa_meta_control"][::std::mem::align_of::<spa_meta_control>() - 4usize];
    ["Offset of field: spa_meta_control::sequence"]
        [::std::mem::offset_of!(spa_meta_control, sequence) - 0usize];
};
#[doc = " a busy counter for the buffer"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_meta_busy {
    pub flags: u32,
    #[doc = "< number of users busy with the buffer"]
    pub count: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_meta_busy"][::std::mem::size_of::<spa_meta_busy>() - 8usize];
    ["Alignment of spa_meta_busy"][::std::mem::align_of::<spa_meta_busy>() - 4usize];
    ["Offset of field: spa_meta_busy::flags"]
        [::std::mem::offset_of!(spa_meta_busy, flags) - 0usize];
    ["Offset of field: spa_meta_busy::count"]
        [::std::mem::offset_of!(spa_meta_busy, count) - 4usize];
};
#[doc = "< no transform"]
pub const spa_meta_videotransform_value_SPA_META_TRANSFORMATION_None:
    spa_meta_videotransform_value = 0;
#[doc = "< 90 degree counter-clockwise"]
pub const spa_meta_videotransform_value_SPA_META_TRANSFORMATION_90: spa_meta_videotransform_value =
    1;
#[doc = "< 180 degree counter-clockwise"]
pub const spa_meta_videotransform_value_SPA_META_TRANSFORMATION_180: spa_meta_videotransform_value =
    2;
#[doc = "< 270 degree counter-clockwise"]
pub const spa_meta_videotransform_value_SPA_META_TRANSFORMATION_270: spa_meta_videotransform_value =
    3;
#[doc = "< 180 degree flipped around the vertical axis. Equivalent\n to a reflexion through the vertical line splitting the\n buffer in two equal sized parts"]
pub const spa_meta_videotransform_value_SPA_META_TRANSFORMATION_Flipped:
    spa_meta_videotransform_value = 4;
#[doc = "< flip then rotate around 90 degree counter-clockwise"]
pub const spa_meta_videotransform_value_SPA_META_TRANSFORMATION_Flipped90:
    spa_meta_videotransform_value = 5;
#[doc = "< flip then rotate around 180 degree counter-clockwise"]
pub const spa_meta_videotransform_value_SPA_META_TRANSFORMATION_Flipped180:
    spa_meta_videotransform_value = 6;
#[doc = "< flip then rotate around 270 degree counter-clockwise"]
pub const spa_meta_videotransform_value_SPA_META_TRANSFORMATION_Flipped270:
    spa_meta_videotransform_value = 7;
pub type spa_meta_videotransform_value = ::std::os::raw::c_uint;
#[doc = " a transformation of the buffer"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_meta_videotransform {
    #[doc = "< orientation transformation that was applied to the buffer,\n  one of enum spa_meta_videotransform_value"]
    pub transform: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_meta_videotransform"][::std::mem::size_of::<spa_meta_videotransform>() - 4usize];
    ["Alignment of spa_meta_videotransform"]
        [::std::mem::align_of::<spa_meta_videotransform>() - 4usize];
    ["Offset of field: spa_meta_videotransform::transform"]
        [::std::mem::offset_of!(spa_meta_videotransform, transform) - 0usize];
};
#[doc = " A timeline point for explicit sync\n\n Metadata to describe the time on the timeline when the buffer\n can be acquired and when it can be reused.\n\n This metadata will require negotiation of 2 extra fds for the acquire\n and release timelines respectively.  One way to achieve this is to place\n this metadata as SPA_PARAM_BUFFERS_metaType when negotiating a buffer\n layout with 2 extra fds."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_meta_sync_timeline {
    pub flags: u32,
    pub padding: u32,
    #[doc = "< the timeline acquire point, this is when the data\n  can be accessed."]
    pub acquire_point: u64,
    #[doc = "< the timeline release point, this timeline point should\n  be signaled when the data is no longer accessed."]
    pub release_point: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_meta_sync_timeline"][::std::mem::size_of::<spa_meta_sync_timeline>() - 24usize];
    ["Alignment of spa_meta_sync_timeline"]
        [::std::mem::align_of::<spa_meta_sync_timeline>() - 8usize];
    ["Offset of field: spa_meta_sync_timeline::flags"]
        [::std::mem::offset_of!(spa_meta_sync_timeline, flags) - 0usize];
    ["Offset of field: spa_meta_sync_timeline::padding"]
        [::std::mem::offset_of!(spa_meta_sync_timeline, padding) - 4usize];
    ["Offset of field: spa_meta_sync_timeline::acquire_point"]
        [::std::mem::offset_of!(spa_meta_sync_timeline, acquire_point) - 8usize];
    ["Offset of field: spa_meta_sync_timeline::release_point"]
        [::std::mem::offset_of!(spa_meta_sync_timeline, release_point) - 16usize];
};
pub const spa_data_type_SPA_DATA_Invalid: spa_data_type = 0;
#[doc = "< pointer to memory, the data field in\n  struct spa_data is set."]
pub const spa_data_type_SPA_DATA_MemPtr: spa_data_type = 1;
#[doc = "< memfd, mmap to get to memory."]
pub const spa_data_type_SPA_DATA_MemFd: spa_data_type = 2;
#[doc = "< fd to dmabuf memory. This might not be readily\n  mappable (unless the MAPPABLE flag is set) and should\n  normally be handled with DMABUF apis."]
pub const spa_data_type_SPA_DATA_DmaBuf: spa_data_type = 3;
#[doc = "< memory is identified with an id. The actual memory\n  can be obtained in some other way and can be identified\n  with this id."]
pub const spa_data_type_SPA_DATA_MemId: spa_data_type = 4;
#[doc = "< a syncobj, usually requires a spa_meta_sync_timeline metadata\n  with timeline points."]
pub const spa_data_type_SPA_DATA_SyncObj: spa_data_type = 5;
#[doc = "< not part of ABI"]
pub const spa_data_type__SPA_DATA_LAST: spa_data_type = 6;
#[doc = " \\addtogroup spa_buffer\n \\{"]
pub type spa_data_type = ::std::os::raw::c_uint;
#[doc = " Chunk of memory, can change for each buffer"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_chunk {
    #[doc = "< offset of valid data. Should be taken\n  modulo the data maxsize to get the offset\n  in the data memory."]
    pub offset: u32,
    #[doc = "< size of valid data. Should be clamped to\n  maxsize."]
    pub size: u32,
    #[doc = "< stride of valid data"]
    pub stride: i32,
    #[doc = "< chunk flags"]
    pub flags: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_chunk"][::std::mem::size_of::<spa_chunk>() - 16usize];
    ["Alignment of spa_chunk"][::std::mem::align_of::<spa_chunk>() - 4usize];
    ["Offset of field: spa_chunk::offset"][::std::mem::offset_of!(spa_chunk, offset) - 0usize];
    ["Offset of field: spa_chunk::size"][::std::mem::offset_of!(spa_chunk, size) - 4usize];
    ["Offset of field: spa_chunk::stride"][::std::mem::offset_of!(spa_chunk, stride) - 8usize];
    ["Offset of field: spa_chunk::flags"][::std::mem::offset_of!(spa_chunk, flags) - 12usize];
};
#[doc = " Data for a buffer this stays constant for a buffer"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_data {
    #[doc = "< memory type, one of enum spa_data_type, when\n  allocating memory, the type contains a bitmask\n  of allowed types. SPA_ID_INVALID is a special\n  value for the allocator to indicate that the\n  other side did not explicitly specify any\n  supported data types. It should probably use\n  a memory type that does not require special\n  handling in addition to simple mmap/munmap."]
    pub type_: u32,
    #[doc = "< data flags"]
    pub flags: u32,
    #[doc = "< optional fd for data"]
    pub fd: i64,
    #[doc = "< offset to map fd at, this is page aligned"]
    pub mapoffset: u32,
    #[doc = "< max size of data"]
    pub maxsize: u32,
    #[doc = "< optional data pointer"]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = "< valid chunk of memory"]
    pub chunk: *mut spa_chunk,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_data"][::std::mem::size_of::<spa_data>() - 40usize];
    ["Alignment of spa_data"][::std::mem::align_of::<spa_data>() - 8usize];
    ["Offset of field: spa_data::type_"][::std::mem::offset_of!(spa_data, type_) - 0usize];
    ["Offset of field: spa_data::flags"][::std::mem::offset_of!(spa_data, flags) - 4usize];
    ["Offset of field: spa_data::fd"][::std::mem::offset_of!(spa_data, fd) - 8usize];
    ["Offset of field: spa_data::mapoffset"][::std::mem::offset_of!(spa_data, mapoffset) - 16usize];
    ["Offset of field: spa_data::maxsize"][::std::mem::offset_of!(spa_data, maxsize) - 20usize];
    ["Offset of field: spa_data::data"][::std::mem::offset_of!(spa_data, data) - 24usize];
    ["Offset of field: spa_data::chunk"][::std::mem::offset_of!(spa_data, chunk) - 32usize];
};
#[doc = " A Buffer"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_buffer {
    #[doc = "< number of metadata"]
    pub n_metas: u32,
    #[doc = "< number of data members"]
    pub n_datas: u32,
    #[doc = "< array of metadata"]
    pub metas: *mut spa_meta,
    #[doc = "< array of data members"]
    pub datas: *mut spa_data,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_buffer"][::std::mem::size_of::<spa_buffer>() - 24usize];
    ["Alignment of spa_buffer"][::std::mem::align_of::<spa_buffer>() - 8usize];
    ["Offset of field: spa_buffer::n_metas"][::std::mem::offset_of!(spa_buffer, n_metas) - 0usize];
    ["Offset of field: spa_buffer::n_datas"][::std::mem::offset_of!(spa_buffer, n_datas) - 4usize];
    ["Offset of field: spa_buffer::metas"][::std::mem::offset_of!(spa_buffer, metas) - 8usize];
    ["Offset of field: spa_buffer::datas"][::std::mem::offset_of!(spa_buffer, datas) - 16usize];
};
#[doc = " information about the buffer layout"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_buffer_alloc_info {
    pub flags: u32,
    #[doc = "< max of all alignments"]
    pub max_align: u32,
    pub n_metas: u32,
    pub n_datas: u32,
    pub metas: *mut spa_meta,
    pub datas: *mut spa_data,
    pub data_aligns: *mut u32,
    #[doc = "< size of the struct spa_buffer and inlined meta/chunk/data"]
    pub skel_size: usize,
    #[doc = "< size of the meta if not inlined"]
    pub meta_size: usize,
    #[doc = "< size of the chunk if not inlined"]
    pub chunk_size: usize,
    #[doc = "< size of the data if not inlined"]
    pub data_size: usize,
    #[doc = "< size of the total memory if not inlined"]
    pub mem_size: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_buffer_alloc_info"][::std::mem::size_of::<spa_buffer_alloc_info>() - 80usize];
    ["Alignment of spa_buffer_alloc_info"]
        [::std::mem::align_of::<spa_buffer_alloc_info>() - 8usize];
    ["Offset of field: spa_buffer_alloc_info::flags"]
        [::std::mem::offset_of!(spa_buffer_alloc_info, flags) - 0usize];
    ["Offset of field: spa_buffer_alloc_info::max_align"]
        [::std::mem::offset_of!(spa_buffer_alloc_info, max_align) - 4usize];
    ["Offset of field: spa_buffer_alloc_info::n_metas"]
        [::std::mem::offset_of!(spa_buffer_alloc_info, n_metas) - 8usize];
    ["Offset of field: spa_buffer_alloc_info::n_datas"]
        [::std::mem::offset_of!(spa_buffer_alloc_info, n_datas) - 12usize];
    ["Offset of field: spa_buffer_alloc_info::metas"]
        [::std::mem::offset_of!(spa_buffer_alloc_info, metas) - 16usize];
    ["Offset of field: spa_buffer_alloc_info::datas"]
        [::std::mem::offset_of!(spa_buffer_alloc_info, datas) - 24usize];
    ["Offset of field: spa_buffer_alloc_info::data_aligns"]
        [::std::mem::offset_of!(spa_buffer_alloc_info, data_aligns) - 32usize];
    ["Offset of field: spa_buffer_alloc_info::skel_size"]
        [::std::mem::offset_of!(spa_buffer_alloc_info, skel_size) - 40usize];
    ["Offset of field: spa_buffer_alloc_info::meta_size"]
        [::std::mem::offset_of!(spa_buffer_alloc_info, meta_size) - 48usize];
    ["Offset of field: spa_buffer_alloc_info::chunk_size"]
        [::std::mem::offset_of!(spa_buffer_alloc_info, chunk_size) - 56usize];
    ["Offset of field: spa_buffer_alloc_info::data_size"]
        [::std::mem::offset_of!(spa_buffer_alloc_info, data_size) - 64usize];
    ["Offset of field: spa_buffer_alloc_info::mem_size"]
        [::std::mem::offset_of!(spa_buffer_alloc_info, mem_size) - 72usize];
};
unsafe extern "C" {
    pub static spa_type_data_type: [spa_type_info; 7usize];
}
unsafe extern "C" {
    pub static spa_type_meta_videotransform_type: [spa_type_info; 9usize];
}
unsafe extern "C" {
    pub static spa_type_meta_type: [spa_type_info; 11usize];
}
pub const spa_control_type_SPA_CONTROL_Invalid: spa_control_type = 0;
#[doc = "< SPA_TYPE_OBJECT_Props"]
pub const spa_control_type_SPA_CONTROL_Properties: spa_control_type = 1;
#[doc = "< spa_pod_bytes with raw midi data (deprecated, use SPA_CONTROL_UMP)"]
pub const spa_control_type_SPA_CONTROL_Midi: spa_control_type = 2;
#[doc = "< spa_pod_bytes with an OSC packet"]
pub const spa_control_type_SPA_CONTROL_OSC: spa_control_type = 3;
#[doc = "< spa_pod_bytes with raw UMP (universal MIDI packet)\n  data. The UMP 32 bit words are stored in native endian\n  format."]
pub const spa_control_type_SPA_CONTROL_UMP: spa_control_type = 4;
#[doc = "< not part of ABI"]
pub const spa_control_type__SPA_CONTROL_LAST: spa_control_type = 5;
#[doc = " Different Control types"]
pub type spa_control_type = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub static spa_type_control: [spa_type_info; 6usize];
}
pub const _ISupper: _bindgen_ty_11 = 256;
pub const _ISlower: _bindgen_ty_11 = 512;
pub const _ISalpha: _bindgen_ty_11 = 1024;
pub const _ISdigit: _bindgen_ty_11 = 2048;
pub const _ISxdigit: _bindgen_ty_11 = 4096;
pub const _ISspace: _bindgen_ty_11 = 8192;
pub const _ISprint: _bindgen_ty_11 = 16384;
pub const _ISgraph: _bindgen_ty_11 = 32768;
pub const _ISblank: _bindgen_ty_11 = 1;
pub const _IScntrl: _bindgen_ty_11 = 2;
pub const _ISpunct: _bindgen_ty_11 = 4;
pub const _ISalnum: _bindgen_ty_11 = 8;
pub type _bindgen_ty_11 = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn __ctype_b_loc() -> *mut *const ::std::os::raw::c_ushort;
}
unsafe extern "C" {
    pub fn __ctype_tolower_loc() -> *mut *const __int32_t;
}
unsafe extern "C" {
    pub fn __ctype_toupper_loc() -> *mut *const __int32_t;
}
unsafe extern "C" {
    pub fn isalnum(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isalpha(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn iscntrl(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isdigit(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn islower(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isgraph(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isprint(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ispunct(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isspace(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isupper(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isxdigit(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn tolower(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn toupper(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isblank(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isascii(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn toascii(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _toupper(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _tolower(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isalnum_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isalpha_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn iscntrl_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isdigit_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn islower_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isgraph_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isprint_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ispunct_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isspace_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isupper_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isxdigit_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isblank_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __tolower_l(__c: ::std::os::raw::c_int, __l: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn tolower_l(__c: ::std::os::raw::c_int, __l: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __toupper_l(__c: ::std::os::raw::c_int, __l: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn toupper_l(__c: ::std::os::raw::c_int, __l: locale_t) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_debug_context {
    pub log: ::std::option::Option<
        unsafe extern "C" fn(ctx: *mut spa_debug_context, fmt: *const ::std::os::raw::c_char, ...),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_debug_context"][::std::mem::size_of::<spa_debug_context>() - 8usize];
    ["Alignment of spa_debug_context"][::std::mem::align_of::<spa_debug_context>() - 8usize];
    ["Offset of field: spa_debug_context::log"]
        [::std::mem::offset_of!(spa_debug_context, log) - 0usize];
};
unsafe extern "C" {
    pub static spa_type_direction: [spa_type_info; 3usize];
}
unsafe extern "C" {
    pub static spa_type_choice: [spa_type_info; 6usize];
}
#[doc = " \\addtogroup spa_pod\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_event_body {
    pub body: spa_pod_object_body,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_event_body"][::std::mem::size_of::<spa_event_body>() - 8usize];
    ["Alignment of spa_event_body"][::std::mem::align_of::<spa_event_body>() - 4usize];
    ["Offset of field: spa_event_body::body"]
        [::std::mem::offset_of!(spa_event_body, body) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_event {
    pub pod: spa_pod,
    pub body: spa_event_body,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_event"][::std::mem::size_of::<spa_event>() - 16usize];
    ["Alignment of spa_event"][::std::mem::align_of::<spa_event>() - 4usize];
    ["Offset of field: spa_event::pod"][::std::mem::offset_of!(spa_event, pod) - 0usize];
    ["Offset of field: spa_event::body"][::std::mem::offset_of!(spa_event, body) - 8usize];
};
pub const spa_device_event_SPA_DEVICE_EVENT_ObjectConfig: spa_device_event = 0;
#[doc = " \\addtogroup spa_device\n \\{"]
pub type spa_device_event = ::std::os::raw::c_uint;
pub const spa_event_device_SPA_EVENT_DEVICE_START: spa_event_device = 0;
pub const spa_event_device_SPA_EVENT_DEVICE_Object: spa_event_device = 1;
pub const spa_event_device_SPA_EVENT_DEVICE_Props: spa_event_device = 2;
pub type spa_event_device = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub static spa_type_device_event_id: [spa_type_info; 2usize];
}
unsafe extern "C" {
    pub static spa_type_device_event: [spa_type_info; 4usize];
}
#[doc = " \\addtogroup spa_pod\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_command_body {
    pub body: spa_pod_object_body,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_command_body"][::std::mem::size_of::<spa_command_body>() - 8usize];
    ["Alignment of spa_command_body"][::std::mem::align_of::<spa_command_body>() - 4usize];
    ["Offset of field: spa_command_body::body"]
        [::std::mem::offset_of!(spa_command_body, body) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_command {
    pub pod: spa_pod,
    pub body: spa_command_body,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_command"][::std::mem::size_of::<spa_command>() - 16usize];
    ["Alignment of spa_command"][::std::mem::align_of::<spa_command>() - 4usize];
    ["Offset of field: spa_command::pod"][::std::mem::offset_of!(spa_command, pod) - 0usize];
    ["Offset of field: spa_command::body"][::std::mem::offset_of!(spa_command, body) - 8usize];
};
#[doc = "< suspend a node, this removes all configured\n formats and closes any devices"]
pub const spa_node_command_SPA_NODE_COMMAND_Suspend: spa_node_command = 0;
#[doc = "< pause a node. this makes it stop emitting\n  scheduling events"]
pub const spa_node_command_SPA_NODE_COMMAND_Pause: spa_node_command = 1;
#[doc = "< start a node, this makes it start emitting\n  scheduling events"]
pub const spa_node_command_SPA_NODE_COMMAND_Start: spa_node_command = 2;
pub const spa_node_command_SPA_NODE_COMMAND_Enable: spa_node_command = 3;
pub const spa_node_command_SPA_NODE_COMMAND_Disable: spa_node_command = 4;
pub const spa_node_command_SPA_NODE_COMMAND_Flush: spa_node_command = 5;
pub const spa_node_command_SPA_NODE_COMMAND_Drain: spa_node_command = 6;
pub const spa_node_command_SPA_NODE_COMMAND_Marker: spa_node_command = 7;
#[doc = "< begin a set of parameter enumerations or\n  configuration that require the device to\n  remain opened, like query formats and then\n  set a format"]
pub const spa_node_command_SPA_NODE_COMMAND_ParamBegin: spa_node_command = 8;
#[doc = "< end a transaction"]
pub const spa_node_command_SPA_NODE_COMMAND_ParamEnd: spa_node_command = 9;
#[doc = "< Sent to a driver when some other node emitted\n  the RequestProcess event."]
pub const spa_node_command_SPA_NODE_COMMAND_RequestProcess: spa_node_command = 10;
pub type spa_node_command = ::std::os::raw::c_uint;
pub const spa_node_event_SPA_NODE_EVENT_Error: spa_node_event = 0;
pub const spa_node_event_SPA_NODE_EVENT_Buffering: spa_node_event = 1;
pub const spa_node_event_SPA_NODE_EVENT_RequestRefresh: spa_node_event = 2;
pub const spa_node_event_SPA_NODE_EVENT_RequestProcess: spa_node_event = 3;
pub type spa_node_event = ::std::os::raw::c_uint;
pub const spa_event_node_SPA_EVENT_NODE_START: spa_event_node = 0;
pub type spa_event_node = ::std::os::raw::c_uint;
pub const spa_io_type_SPA_IO_Invalid: spa_io_type = 0;
#[doc = "< area to exchange buffers, struct spa_io_buffers"]
pub const spa_io_type_SPA_IO_Buffers: spa_io_type = 1;
#[doc = "< expected byte range, struct spa_io_range (currently not used in PipeWire)"]
pub const spa_io_type_SPA_IO_Range: spa_io_type = 2;
#[doc = "< area to update clock information, struct spa_io_clock"]
pub const spa_io_type_SPA_IO_Clock: spa_io_type = 3;
#[doc = "< latency reporting, struct spa_io_latency (currently not used in\n PipeWire). \\see spa_param_latency"]
pub const spa_io_type_SPA_IO_Latency: spa_io_type = 4;
#[doc = "< area for control messages, struct spa_io_sequence"]
pub const spa_io_type_SPA_IO_Control: spa_io_type = 5;
#[doc = "< area for notify messages, struct spa_io_sequence"]
pub const spa_io_type_SPA_IO_Notify: spa_io_type = 6;
#[doc = "< position information in the graph, struct spa_io_position"]
pub const spa_io_type_SPA_IO_Position: spa_io_type = 7;
#[doc = "< rate matching between nodes, struct spa_io_rate_match"]
pub const spa_io_type_SPA_IO_RateMatch: spa_io_type = 8;
#[doc = "< memory pointer, struct spa_io_memory (currently not used in PipeWire)"]
pub const spa_io_type_SPA_IO_Memory: spa_io_type = 9;
#[doc = "< async area to exchange buffers, struct spa_io_async_buffers"]
pub const spa_io_type_SPA_IO_AsyncBuffers: spa_io_type = 10;
#[doc = " Different IO area types"]
pub type spa_io_type = ::std::os::raw::c_uint;
#[doc = " IO area to exchange buffers.\n\n A set of buffers should first be configured on the node/port.\n Further references to those buffers will be made by using the\n id of the buffer.\n\n If status is SPA_STATUS_OK, the host should ignore\n the io area.\n\n If status is SPA_STATUS_NEED_DATA, the host should:\n 1) recycle the buffer in buffer_id, if possible\n 2) prepare a new buffer and place the id in buffer_id.\n\n If status is SPA_STATUS_HAVE_DATA, the host should consume\n the buffer in buffer_id and set the state to\n SPA_STATUS_NEED_DATA when new data is requested.\n\n If status is SPA_STATUS_STOPPED, some error occurred on the\n port.\n\n If status is SPA_STATUS_DRAINED, data from the io area was\n used to drain.\n\n Status can also be a negative errno value to indicate errors.\n such as:\n -EINVAL: buffer_id is invalid\n -EPIPE: no more buffers available"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_io_buffers {
    #[doc = "< the status code"]
    pub status: i32,
    #[doc = "< a buffer id"]
    pub buffer_id: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_io_buffers"][::std::mem::size_of::<spa_io_buffers>() - 8usize];
    ["Alignment of spa_io_buffers"][::std::mem::align_of::<spa_io_buffers>() - 4usize];
    ["Offset of field: spa_io_buffers::status"]
        [::std::mem::offset_of!(spa_io_buffers, status) - 0usize];
    ["Offset of field: spa_io_buffers::buffer_id"]
        [::std::mem::offset_of!(spa_io_buffers, buffer_id) - 4usize];
};
#[doc = " IO area to exchange a memory region"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_io_memory {
    #[doc = "< the status code"]
    pub status: i32,
    #[doc = "< the size of \\a data"]
    pub size: u32,
    #[doc = "< a memory pointer"]
    pub data: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_io_memory"][::std::mem::size_of::<spa_io_memory>() - 16usize];
    ["Alignment of spa_io_memory"][::std::mem::align_of::<spa_io_memory>() - 8usize];
    ["Offset of field: spa_io_memory::status"]
        [::std::mem::offset_of!(spa_io_memory, status) - 0usize];
    ["Offset of field: spa_io_memory::size"][::std::mem::offset_of!(spa_io_memory, size) - 4usize];
    ["Offset of field: spa_io_memory::data"][::std::mem::offset_of!(spa_io_memory, data) - 8usize];
};
#[doc = " A range, suitable for input ports that can suggest a range to output ports"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_io_range {
    #[doc = "< offset in range"]
    pub offset: u64,
    #[doc = "< minimum size of data"]
    pub min_size: u32,
    #[doc = "< maximum size of data"]
    pub max_size: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_io_range"][::std::mem::size_of::<spa_io_range>() - 16usize];
    ["Alignment of spa_io_range"][::std::mem::align_of::<spa_io_range>() - 8usize];
    ["Offset of field: spa_io_range::offset"]
        [::std::mem::offset_of!(spa_io_range, offset) - 0usize];
    ["Offset of field: spa_io_range::min_size"]
        [::std::mem::offset_of!(spa_io_range, min_size) - 8usize];
    ["Offset of field: spa_io_range::max_size"]
        [::std::mem::offset_of!(spa_io_range, max_size) - 12usize];
};
#[doc = " Absolute time reporting.\n\n Nodes that can report clocking information will receive this io block.\n The application sets the id. This is usually set as part of the\n position information but can also be set separately.\n\n The clock counts the elapsed time according to the clock provider\n since the provider was last started.\n\n Driver nodes are supposed to update the contents of \\ref SPA_IO_Clock before\n signaling the start of a graph cycle.  These updated clock values become\n visible to other nodes in \\ref SPA_IO_Position. Non-driver nodes do\n not need to update the contents of their \\ref SPA_IO_Clock.\n\n The host generally gives each node a separate \\ref spa_io_clock in \\ref\n SPA_IO_Clock, so that updates made by the driver are not visible in the\n contents of \\ref SPA_IO_Clock of other nodes. Instead, \\ref SPA_IO_Position\n is used to look up the current graph time.\n\n A node is a driver when \\ref spa_io_clock.id in \\ref SPA_IO_Clock and\n \\ref spa_io_position.clock.id in \\ref SPA_IO_Position are the same."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_io_clock {
    #[doc = "< Clock flags"]
    pub flags: u32,
    #[doc = "< Unique clock id, set by host application"]
    pub id: u32,
    #[doc = "< Clock name prefixed with API, set by node when it receives\n  \\ref SPA_IO_Clock. The clock name is unique per clock and\n  can be used to check if nodes share the same clock."]
    pub name: [::std::os::raw::c_char; 64usize],
    #[doc = "< Time in nanoseconds against monotonic clock\n (CLOCK_MONOTONIC). This fields reflects a real time instant\n in the past. The value may have jitter."]
    pub nsec: u64,
    #[doc = "< Rate for position/duration/delay/xrun"]
    pub rate: spa_fraction,
    #[doc = "< Current position, in samples @ \\ref rate"]
    pub position: u64,
    #[doc = "< Duration of current cycle, in samples @ \\ref rate"]
    pub duration: u64,
    #[doc = "< Delay between position and hardware, in samples @ \\ref rate"]
    pub delay: i64,
    #[doc = "< Rate difference between clock and monotonic time, as a ratio of\n  clock speeds."]
    pub rate_diff: f64,
    #[doc = "< Estimated next wakeup time in nanoseconds.\n  This time is a logical start time of the next cycle, and\n  is not necessarily in the future."]
    pub next_nsec: u64,
    #[doc = "< Target rate of next cycle"]
    pub target_rate: spa_fraction,
    #[doc = "< Target duration of next cycle"]
    pub target_duration: u64,
    #[doc = "< Seq counter. must be equal at start and\n  end of read and lower bit must be 0"]
    pub target_seq: u32,
    #[doc = "< incremented each time the graph is started"]
    pub cycle: u32,
    #[doc = "< Estimated accumulated xrun duration"]
    pub xrun: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_io_clock"][::std::mem::size_of::<spa_io_clock>() - 160usize];
    ["Alignment of spa_io_clock"][::std::mem::align_of::<spa_io_clock>() - 8usize];
    ["Offset of field: spa_io_clock::flags"][::std::mem::offset_of!(spa_io_clock, flags) - 0usize];
    ["Offset of field: spa_io_clock::id"][::std::mem::offset_of!(spa_io_clock, id) - 4usize];
    ["Offset of field: spa_io_clock::name"][::std::mem::offset_of!(spa_io_clock, name) - 8usize];
    ["Offset of field: spa_io_clock::nsec"][::std::mem::offset_of!(spa_io_clock, nsec) - 72usize];
    ["Offset of field: spa_io_clock::rate"][::std::mem::offset_of!(spa_io_clock, rate) - 80usize];
    ["Offset of field: spa_io_clock::position"]
        [::std::mem::offset_of!(spa_io_clock, position) - 88usize];
    ["Offset of field: spa_io_clock::duration"]
        [::std::mem::offset_of!(spa_io_clock, duration) - 96usize];
    ["Offset of field: spa_io_clock::delay"]
        [::std::mem::offset_of!(spa_io_clock, delay) - 104usize];
    ["Offset of field: spa_io_clock::rate_diff"]
        [::std::mem::offset_of!(spa_io_clock, rate_diff) - 112usize];
    ["Offset of field: spa_io_clock::next_nsec"]
        [::std::mem::offset_of!(spa_io_clock, next_nsec) - 120usize];
    ["Offset of field: spa_io_clock::target_rate"]
        [::std::mem::offset_of!(spa_io_clock, target_rate) - 128usize];
    ["Offset of field: spa_io_clock::target_duration"]
        [::std::mem::offset_of!(spa_io_clock, target_duration) - 136usize];
    ["Offset of field: spa_io_clock::target_seq"]
        [::std::mem::offset_of!(spa_io_clock, target_seq) - 144usize];
    ["Offset of field: spa_io_clock::cycle"]
        [::std::mem::offset_of!(spa_io_clock, cycle) - 148usize];
    ["Offset of field: spa_io_clock::xrun"][::std::mem::offset_of!(spa_io_clock, xrun) - 152usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_io_video_size {
    #[doc = "< optional flags"]
    pub flags: u32,
    #[doc = "< video stride in bytes"]
    pub stride: u32,
    #[doc = "< the video size"]
    pub size: spa_rectangle,
    #[doc = "< the minimum framerate, the cycle duration is\n  always smaller to ensure there is only one\n  video frame per cycle."]
    pub framerate: spa_fraction,
    pub padding: [u32; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_io_video_size"][::std::mem::size_of::<spa_io_video_size>() - 40usize];
    ["Alignment of spa_io_video_size"][::std::mem::align_of::<spa_io_video_size>() - 4usize];
    ["Offset of field: spa_io_video_size::flags"]
        [::std::mem::offset_of!(spa_io_video_size, flags) - 0usize];
    ["Offset of field: spa_io_video_size::stride"]
        [::std::mem::offset_of!(spa_io_video_size, stride) - 4usize];
    ["Offset of field: spa_io_video_size::size"]
        [::std::mem::offset_of!(spa_io_video_size, size) - 8usize];
    ["Offset of field: spa_io_video_size::framerate"]
        [::std::mem::offset_of!(spa_io_video_size, framerate) - 16usize];
    ["Offset of field: spa_io_video_size::padding"]
        [::std::mem::offset_of!(spa_io_video_size, padding) - 24usize];
};
#[doc = " Latency reporting\n\n Currently not used in PipeWire. Instead, \\see spa_param_latency"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_io_latency {
    #[doc = "< rate for min/max"]
    pub rate: spa_fraction,
    #[doc = "< min latency"]
    pub min: u64,
    #[doc = "< max latency"]
    pub max: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_io_latency"][::std::mem::size_of::<spa_io_latency>() - 24usize];
    ["Alignment of spa_io_latency"][::std::mem::align_of::<spa_io_latency>() - 8usize];
    ["Offset of field: spa_io_latency::rate"]
        [::std::mem::offset_of!(spa_io_latency, rate) - 0usize];
    ["Offset of field: spa_io_latency::min"][::std::mem::offset_of!(spa_io_latency, min) - 8usize];
    ["Offset of field: spa_io_latency::max"][::std::mem::offset_of!(spa_io_latency, max) - 16usize];
};
#[doc = " control stream, io area for SPA_IO_Control and SPA_IO_Notify"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_io_sequence {
    #[doc = "< sequence of timed events"]
    pub sequence: spa_pod_sequence,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_io_sequence"][::std::mem::size_of::<spa_io_sequence>() - 16usize];
    ["Alignment of spa_io_sequence"][::std::mem::align_of::<spa_io_sequence>() - 4usize];
    ["Offset of field: spa_io_sequence::sequence"]
        [::std::mem::offset_of!(spa_io_sequence, sequence) - 0usize];
};
#[doc = " bar and beat segment"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_io_segment_bar {
    #[doc = "< extra flags"]
    pub flags: u32,
    #[doc = "< offset in segment of this beat"]
    pub offset: u32,
    #[doc = "< time signature numerator"]
    pub signature_num: f32,
    #[doc = "< time signature denominator"]
    pub signature_denom: f32,
    #[doc = "< beats per minute"]
    pub bpm: f64,
    #[doc = "< current beat in segment"]
    pub beat: f64,
    pub bar_start_tick: f64,
    pub ticks_per_beat: f64,
    pub padding: [u32; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_io_segment_bar"][::std::mem::size_of::<spa_io_segment_bar>() - 64usize];
    ["Alignment of spa_io_segment_bar"][::std::mem::align_of::<spa_io_segment_bar>() - 8usize];
    ["Offset of field: spa_io_segment_bar::flags"]
        [::std::mem::offset_of!(spa_io_segment_bar, flags) - 0usize];
    ["Offset of field: spa_io_segment_bar::offset"]
        [::std::mem::offset_of!(spa_io_segment_bar, offset) - 4usize];
    ["Offset of field: spa_io_segment_bar::signature_num"]
        [::std::mem::offset_of!(spa_io_segment_bar, signature_num) - 8usize];
    ["Offset of field: spa_io_segment_bar::signature_denom"]
        [::std::mem::offset_of!(spa_io_segment_bar, signature_denom) - 12usize];
    ["Offset of field: spa_io_segment_bar::bpm"]
        [::std::mem::offset_of!(spa_io_segment_bar, bpm) - 16usize];
    ["Offset of field: spa_io_segment_bar::beat"]
        [::std::mem::offset_of!(spa_io_segment_bar, beat) - 24usize];
    ["Offset of field: spa_io_segment_bar::bar_start_tick"]
        [::std::mem::offset_of!(spa_io_segment_bar, bar_start_tick) - 32usize];
    ["Offset of field: spa_io_segment_bar::ticks_per_beat"]
        [::std::mem::offset_of!(spa_io_segment_bar, ticks_per_beat) - 40usize];
    ["Offset of field: spa_io_segment_bar::padding"]
        [::std::mem::offset_of!(spa_io_segment_bar, padding) - 48usize];
};
#[doc = " video frame segment"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_io_segment_video {
    #[doc = "< flags"]
    pub flags: u32,
    #[doc = "< offset in segment"]
    pub offset: u32,
    pub framerate: spa_fraction,
    pub hours: u32,
    pub minutes: u32,
    pub seconds: u32,
    pub frames: u32,
    #[doc = "< 0 for progressive, 1 and 2 for interlaced"]
    pub field_count: u32,
    pub padding: [u32; 11usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_io_segment_video"][::std::mem::size_of::<spa_io_segment_video>() - 80usize];
    ["Alignment of spa_io_segment_video"][::std::mem::align_of::<spa_io_segment_video>() - 4usize];
    ["Offset of field: spa_io_segment_video::flags"]
        [::std::mem::offset_of!(spa_io_segment_video, flags) - 0usize];
    ["Offset of field: spa_io_segment_video::offset"]
        [::std::mem::offset_of!(spa_io_segment_video, offset) - 4usize];
    ["Offset of field: spa_io_segment_video::framerate"]
        [::std::mem::offset_of!(spa_io_segment_video, framerate) - 8usize];
    ["Offset of field: spa_io_segment_video::hours"]
        [::std::mem::offset_of!(spa_io_segment_video, hours) - 16usize];
    ["Offset of field: spa_io_segment_video::minutes"]
        [::std::mem::offset_of!(spa_io_segment_video, minutes) - 20usize];
    ["Offset of field: spa_io_segment_video::seconds"]
        [::std::mem::offset_of!(spa_io_segment_video, seconds) - 24usize];
    ["Offset of field: spa_io_segment_video::frames"]
        [::std::mem::offset_of!(spa_io_segment_video, frames) - 28usize];
    ["Offset of field: spa_io_segment_video::field_count"]
        [::std::mem::offset_of!(spa_io_segment_video, field_count) - 32usize];
    ["Offset of field: spa_io_segment_video::padding"]
        [::std::mem::offset_of!(spa_io_segment_video, padding) - 36usize];
};
#[doc = " A segment converts a running time to a segment (stream) position.\n\n The segment position is valid when the current running time is between\n start and start + duration. The position is then\n calculated as:\n\n   (running time - start) * rate + position;\n\n Support for looping is done by specifying the LOOPING flags with a\n non-zero duration. When the running time reaches start + duration,\n duration is added to start and the loop repeats.\n\n Care has to be taken when the running time + clock.duration extends\n past the start + duration from the segment; the user should correctly\n wrap around and partially repeat the loop in the current cycle.\n\n Extra information can be placed in the segment by setting the valid flags\n and filling up the corresponding structures."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_io_segment {
    pub version: u32,
    #[doc = "< extra flags"]
    pub flags: u32,
    #[doc = "< value of running time when this\n  info is active. Can be in the future for\n  pending changes. It does not have to be in\n  exact multiples of the clock duration."]
    pub start: u64,
    #[doc = "< duration when this info becomes invalid expressed\n  in running time. If the duration is 0, this\n  segment extends to the next segment. If the\n  segment becomes invalid and the looping flag is\n  set, the segment repeats."]
    pub duration: u64,
    #[doc = "< overall rate of the segment, can be negative for\n  backwards time reporting."]
    pub rate: f64,
    #[doc = "< The position when the running time == start.\n  can be invalid when the owner of the extra segment\n  information has not yet made the mapping."]
    pub position: u64,
    pub bar: spa_io_segment_bar,
    pub video: spa_io_segment_video,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_io_segment"][::std::mem::size_of::<spa_io_segment>() - 184usize];
    ["Alignment of spa_io_segment"][::std::mem::align_of::<spa_io_segment>() - 8usize];
    ["Offset of field: spa_io_segment::version"]
        [::std::mem::offset_of!(spa_io_segment, version) - 0usize];
    ["Offset of field: spa_io_segment::flags"]
        [::std::mem::offset_of!(spa_io_segment, flags) - 4usize];
    ["Offset of field: spa_io_segment::start"]
        [::std::mem::offset_of!(spa_io_segment, start) - 8usize];
    ["Offset of field: spa_io_segment::duration"]
        [::std::mem::offset_of!(spa_io_segment, duration) - 16usize];
    ["Offset of field: spa_io_segment::rate"]
        [::std::mem::offset_of!(spa_io_segment, rate) - 24usize];
    ["Offset of field: spa_io_segment::position"]
        [::std::mem::offset_of!(spa_io_segment, position) - 32usize];
    ["Offset of field: spa_io_segment::bar"][::std::mem::offset_of!(spa_io_segment, bar) - 40usize];
    ["Offset of field: spa_io_segment::video"]
        [::std::mem::offset_of!(spa_io_segment, video) - 104usize];
};
pub const spa_io_position_state_SPA_IO_POSITION_STATE_STOPPED: spa_io_position_state = 0;
pub const spa_io_position_state_SPA_IO_POSITION_STATE_STARTING: spa_io_position_state = 1;
pub const spa_io_position_state_SPA_IO_POSITION_STATE_RUNNING: spa_io_position_state = 2;
pub type spa_io_position_state = ::std::os::raw::c_uint;
#[doc = " The position information adds extra meaning to the raw clock times.\n\n It is set on all nodes in \\ref SPA_IO_Position, and the contents of \\ref\n spa_io_position.clock contain the clock updates made by the driving node in\n the graph in its \\ref SPA_IO_Clock.  Also, \\ref spa_io_position.clock.id\n will contain the clock id of the driving node in the graph.\n\n The position clock indicates the logical start time of the current graph\n cycle.\n\n The position information contains 1 or more segments that convert the\n raw clock times to a stream time. They are sorted based on their\n start times, and thus the order in which they will activate in\n the future. This makes it possible to look ahead in the scheduled\n segments and anticipate the changes in the timeline."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_io_position {
    #[doc = "< clock position of driver, always valid and\n  read only"]
    pub clock: spa_io_clock,
    #[doc = "< size of the video in the current cycle"]
    pub video: spa_io_video_size,
    #[doc = "< an offset to subtract from the clock position\n  to get a running time. This is the time that\n  the state has been in the RUNNING state and the\n  time that should be used to compare the segment\n  start values against."]
    pub offset: i64,
    #[doc = "< one of enum spa_io_position_state"]
    pub state: u32,
    #[doc = "< number of segments"]
    pub n_segments: u32,
    #[doc = "< segments"]
    pub segments: [spa_io_segment; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_io_position"][::std::mem::size_of::<spa_io_position>() - 1688usize];
    ["Alignment of spa_io_position"][::std::mem::align_of::<spa_io_position>() - 8usize];
    ["Offset of field: spa_io_position::clock"]
        [::std::mem::offset_of!(spa_io_position, clock) - 0usize];
    ["Offset of field: spa_io_position::video"]
        [::std::mem::offset_of!(spa_io_position, video) - 160usize];
    ["Offset of field: spa_io_position::offset"]
        [::std::mem::offset_of!(spa_io_position, offset) - 200usize];
    ["Offset of field: spa_io_position::state"]
        [::std::mem::offset_of!(spa_io_position, state) - 208usize];
    ["Offset of field: spa_io_position::n_segments"]
        [::std::mem::offset_of!(spa_io_position, n_segments) - 212usize];
    ["Offset of field: spa_io_position::segments"]
        [::std::mem::offset_of!(spa_io_position, segments) - 216usize];
};
#[doc = " Rate matching.\n\n It is usually set on the nodes that process resampled data, by\n the component (audioadapter) that handles resampling between graph\n and node rates. The \\a flags and \\a rate fields may be modified by the node.\n\n The node can request a correction to the resampling rate in its process(), by setting\n \\ref SPA_IO_RATE_MATCH_ACTIVE on \\a flags, and setting \\a rate to the desired rate\n correction.  Usually the rate is obtained from DLL or other adaptive mechanism that\n e.g. drives the node buffer fill level toward a specific value.\n\n When resampling to (graph->node) direction, the number of samples produced\n by the resampler varies on each cycle, as the rates are not commensurate.\n\n When resampling to (node->graph) direction, the number of samples consumed by the\n resampler varies. Node output ports in process() should produce \\a size number of\n samples to match what the resampler needs to produce one graph quantum of output\n samples.\n\n Resampling filters introduce processing delay, given by \\a delay and \\a delay_frac, in\n samples at node rate. The delay varies on each cycle e.g. when resampling between\n noncommensurate rates.\n\n The first sample output (graph->node) or consumed (node->graph) by the resampler is\n offset by \\a delay + \\a delay_frac / 1e9 node samples relative to the nominal graph\n cycle start position:\n\n \\code{.unparsed}\n first_resampled_sample_nsec =\n\tfirst_original_sample_nsec\n\t- (rate_match->delay * SPA_NSEC_PER_SEC + rate_match->delay_frac) / node_rate\n \\endcode"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_io_rate_match {
    #[doc = "< resampling delay, in samples at\n node rate"]
    pub delay: u32,
    #[doc = "< requested input size for resampler"]
    pub size: u32,
    #[doc = "< rate for resampler (set by node)"]
    pub rate: f64,
    #[doc = "< extra flags (set by node)"]
    pub flags: u32,
    #[doc = "< resampling delay fractional part,\n in units of nanosamples (1/10^9 sample) at node rate"]
    pub delay_frac: i32,
    pub padding: [u32; 6usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_io_rate_match"][::std::mem::size_of::<spa_io_rate_match>() - 48usize];
    ["Alignment of spa_io_rate_match"][::std::mem::align_of::<spa_io_rate_match>() - 8usize];
    ["Offset of field: spa_io_rate_match::delay"]
        [::std::mem::offset_of!(spa_io_rate_match, delay) - 0usize];
    ["Offset of field: spa_io_rate_match::size"]
        [::std::mem::offset_of!(spa_io_rate_match, size) - 4usize];
    ["Offset of field: spa_io_rate_match::rate"]
        [::std::mem::offset_of!(spa_io_rate_match, rate) - 8usize];
    ["Offset of field: spa_io_rate_match::flags"]
        [::std::mem::offset_of!(spa_io_rate_match, flags) - 16usize];
    ["Offset of field: spa_io_rate_match::delay_frac"]
        [::std::mem::offset_of!(spa_io_rate_match, delay_frac) - 20usize];
    ["Offset of field: spa_io_rate_match::padding"]
        [::std::mem::offset_of!(spa_io_rate_match, padding) - 24usize];
};
#[doc = " async buffers"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_io_async_buffers {
    #[doc = "< async buffers, writers write to current (cycle+1)&1,\n  readers read from (cycle)&1"]
    pub buffers: [spa_io_buffers; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_io_async_buffers"][::std::mem::size_of::<spa_io_async_buffers>() - 16usize];
    ["Alignment of spa_io_async_buffers"][::std::mem::align_of::<spa_io_async_buffers>() - 4usize];
    ["Offset of field: spa_io_async_buffers::buffers"]
        [::std::mem::offset_of!(spa_io_async_buffers, buffers) - 0usize];
};
unsafe extern "C" {
    pub static spa_type_io: [spa_type_info; 12usize];
}
unsafe extern "C" {
    pub static spa_type_node_event_id: [spa_type_info; 5usize];
}
unsafe extern "C" {
    pub static spa_type_node_event: [spa_type_info; 2usize];
}
unsafe extern "C" {
    pub static spa_type_node_command_id: [spa_type_info; 12usize];
}
unsafe extern "C" {
    pub static spa_type_node_command: [spa_type_info; 2usize];
}
#[doc = "< invalid"]
pub const spa_param_type_SPA_PARAM_Invalid: spa_param_type = 0;
#[doc = "< property information as SPA_TYPE_OBJECT_PropInfo"]
pub const spa_param_type_SPA_PARAM_PropInfo: spa_param_type = 1;
#[doc = "< properties as SPA_TYPE_OBJECT_Props"]
pub const spa_param_type_SPA_PARAM_Props: spa_param_type = 2;
#[doc = "< available formats as SPA_TYPE_OBJECT_Format"]
pub const spa_param_type_SPA_PARAM_EnumFormat: spa_param_type = 3;
#[doc = "< configured format as SPA_TYPE_OBJECT_Format"]
pub const spa_param_type_SPA_PARAM_Format: spa_param_type = 4;
#[doc = "< buffer configurations as SPA_TYPE_OBJECT_ParamBuffers"]
pub const spa_param_type_SPA_PARAM_Buffers: spa_param_type = 5;
#[doc = "< allowed metadata for buffers as SPA_TYPE_OBJECT_ParamMeta"]
pub const spa_param_type_SPA_PARAM_Meta: spa_param_type = 6;
#[doc = "< configurable IO areas as SPA_TYPE_OBJECT_ParamIO"]
pub const spa_param_type_SPA_PARAM_IO: spa_param_type = 7;
#[doc = "< profile enumeration as SPA_TYPE_OBJECT_ParamProfile"]
pub const spa_param_type_SPA_PARAM_EnumProfile: spa_param_type = 8;
#[doc = "< profile configuration as SPA_TYPE_OBJECT_ParamProfile"]
pub const spa_param_type_SPA_PARAM_Profile: spa_param_type = 9;
#[doc = "< port configuration enumeration as SPA_TYPE_OBJECT_ParamPortConfig"]
pub const spa_param_type_SPA_PARAM_EnumPortConfig: spa_param_type = 10;
#[doc = "< port configuration as SPA_TYPE_OBJECT_ParamPortConfig"]
pub const spa_param_type_SPA_PARAM_PortConfig: spa_param_type = 11;
#[doc = "< routing enumeration as SPA_TYPE_OBJECT_ParamRoute"]
pub const spa_param_type_SPA_PARAM_EnumRoute: spa_param_type = 12;
#[doc = "< routing configuration as SPA_TYPE_OBJECT_ParamRoute"]
pub const spa_param_type_SPA_PARAM_Route: spa_param_type = 13;
#[doc = "< Control parameter, a SPA_TYPE_Sequence"]
pub const spa_param_type_SPA_PARAM_Control: spa_param_type = 14;
#[doc = "< latency reporting, a SPA_TYPE_OBJECT_ParamLatency"]
pub const spa_param_type_SPA_PARAM_Latency: spa_param_type = 15;
#[doc = "< processing latency, a SPA_TYPE_OBJECT_ParamProcessLatency"]
pub const spa_param_type_SPA_PARAM_ProcessLatency: spa_param_type = 16;
#[doc = "< tag reporting, a SPA_TYPE_OBJECT_ParamTag. Since 0.3.79"]
pub const spa_param_type_SPA_PARAM_Tag: spa_param_type = 17;
#[doc = " different parameter types that can be queried"]
pub type spa_param_type = ::std::os::raw::c_uint;
#[doc = " information about a parameter"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_param_info {
    #[doc = "< enum spa_param_type"]
    pub id: u32,
    pub flags: u32,
    #[doc = "< private user field. You can use this to keep\n  state."]
    pub user: u32,
    #[doc = "< private seq field. You can use this to keep\n  state of a pending update."]
    pub seq: i32,
    pub padding: [u32; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_param_info"][::std::mem::size_of::<spa_param_info>() - 32usize];
    ["Alignment of spa_param_info"][::std::mem::align_of::<spa_param_info>() - 4usize];
    ["Offset of field: spa_param_info::id"][::std::mem::offset_of!(spa_param_info, id) - 0usize];
    ["Offset of field: spa_param_info::flags"]
        [::std::mem::offset_of!(spa_param_info, flags) - 4usize];
    ["Offset of field: spa_param_info::user"]
        [::std::mem::offset_of!(spa_param_info, user) - 8usize];
    ["Offset of field: spa_param_info::seq"][::std::mem::offset_of!(spa_param_info, seq) - 12usize];
    ["Offset of field: spa_param_info::padding"]
        [::std::mem::offset_of!(spa_param_info, padding) - 16usize];
};
#[doc = "< unknown bitorder"]
pub const spa_param_bitorder_SPA_PARAM_BITORDER_unknown: spa_param_bitorder = 0;
#[doc = "< most significant bit"]
pub const spa_param_bitorder_SPA_PARAM_BITORDER_msb: spa_param_bitorder = 1;
#[doc = "< least significant bit"]
pub const spa_param_bitorder_SPA_PARAM_BITORDER_lsb: spa_param_bitorder = 2;
pub type spa_param_bitorder = ::std::os::raw::c_uint;
#[doc = "< unknown availability"]
pub const spa_param_availability_SPA_PARAM_AVAILABILITY_unknown: spa_param_availability = 0;
#[doc = "< not available"]
pub const spa_param_availability_SPA_PARAM_AVAILABILITY_no: spa_param_availability = 1;
#[doc = "< available"]
pub const spa_param_availability_SPA_PARAM_AVAILABILITY_yes: spa_param_availability = 2;
pub type spa_param_availability = ::std::os::raw::c_uint;
pub const spa_param_buffers_SPA_PARAM_BUFFERS_START: spa_param_buffers = 0;
#[doc = "< number of buffers (Int)"]
pub const spa_param_buffers_SPA_PARAM_BUFFERS_buffers: spa_param_buffers = 1;
#[doc = "< number of data blocks per buffer (Int)"]
pub const spa_param_buffers_SPA_PARAM_BUFFERS_blocks: spa_param_buffers = 2;
#[doc = "< size of a data block memory (Int)"]
pub const spa_param_buffers_SPA_PARAM_BUFFERS_size: spa_param_buffers = 3;
#[doc = "< stride of data block memory (Int)"]
pub const spa_param_buffers_SPA_PARAM_BUFFERS_stride: spa_param_buffers = 4;
#[doc = "< alignment of data block memory (Int)"]
pub const spa_param_buffers_SPA_PARAM_BUFFERS_align: spa_param_buffers = 5;
#[doc = "< possible memory types (flags choice Int, mask of enum spa_data_type)"]
pub const spa_param_buffers_SPA_PARAM_BUFFERS_dataType: spa_param_buffers = 6;
#[doc = "< required meta data types (Int, mask of enum spa_meta_type)"]
pub const spa_param_buffers_SPA_PARAM_BUFFERS_metaType: spa_param_buffers = 7;
#[doc = " properties for SPA_TYPE_OBJECT_ParamBuffers"]
pub type spa_param_buffers = ::std::os::raw::c_uint;
pub const spa_param_meta_SPA_PARAM_META_START: spa_param_meta = 0;
#[doc = "< the metadata, one of enum spa_meta_type (Id enum spa_meta_type)"]
pub const spa_param_meta_SPA_PARAM_META_type: spa_param_meta = 1;
#[doc = "< the expected maximum size the meta (Int)"]
pub const spa_param_meta_SPA_PARAM_META_size: spa_param_meta = 2;
#[doc = " properties for SPA_TYPE_OBJECT_ParamMeta"]
pub type spa_param_meta = ::std::os::raw::c_uint;
pub const spa_param_io_SPA_PARAM_IO_START: spa_param_io = 0;
#[doc = "< type ID, uniquely identifies the io area (Id enum spa_io_type)"]
pub const spa_param_io_SPA_PARAM_IO_id: spa_param_io = 1;
#[doc = "< size of the io area (Int)"]
pub const spa_param_io_SPA_PARAM_IO_size: spa_param_io = 2;
#[doc = " properties for SPA_TYPE_OBJECT_ParamIO"]
pub type spa_param_io = ::std::os::raw::c_uint;
pub const spa_param_profile_SPA_PARAM_PROFILE_START: spa_param_profile = 0;
#[doc = "< profile index (Int)"]
pub const spa_param_profile_SPA_PARAM_PROFILE_index: spa_param_profile = 1;
#[doc = "< profile name (String)"]
pub const spa_param_profile_SPA_PARAM_PROFILE_name: spa_param_profile = 2;
#[doc = "< profile description (String)"]
pub const spa_param_profile_SPA_PARAM_PROFILE_description: spa_param_profile = 3;
#[doc = "< profile priority (Int)"]
pub const spa_param_profile_SPA_PARAM_PROFILE_priority: spa_param_profile = 4;
#[doc = "< availability of the profile\n  (Id enum spa_param_availability)"]
pub const spa_param_profile_SPA_PARAM_PROFILE_available: spa_param_profile = 5;
#[doc = "< info (Struct(\n\t\t  Int : n_items,\n\t\t  (String : key,\n\t\t   String : value)*))"]
pub const spa_param_profile_SPA_PARAM_PROFILE_info: spa_param_profile = 6;
#[doc = "< node classes provided by this profile\n  (Struct(\n\t   Int : number of items following\n        Struct(\n           String : class name (eg. \"Audio/Source\"),\n           Int : number of nodes\n           String : property (eg. \"card.profile.devices\"),\n           Array of Int: device indexes\n         )*))"]
pub const spa_param_profile_SPA_PARAM_PROFILE_classes: spa_param_profile = 7;
#[doc = "< If profile should be saved (Bool)"]
pub const spa_param_profile_SPA_PARAM_PROFILE_save: spa_param_profile = 8;
#[doc = " properties for SPA_TYPE_OBJECT_ParamProfile"]
pub type spa_param_profile = ::std::os::raw::c_uint;
#[doc = "< no configuration"]
pub const spa_param_port_config_mode_SPA_PARAM_PORT_CONFIG_MODE_none: spa_param_port_config_mode =
    0;
#[doc = "< passthrough configuration"]
pub const spa_param_port_config_mode_SPA_PARAM_PORT_CONFIG_MODE_passthrough:
    spa_param_port_config_mode = 1;
#[doc = "< convert configuration"]
pub const spa_param_port_config_mode_SPA_PARAM_PORT_CONFIG_MODE_convert:
    spa_param_port_config_mode = 2;
#[doc = "< dsp configuration, depending on the external\n  format. For audio, ports will be configured for\n  the given number of channels with F32 format."]
pub const spa_param_port_config_mode_SPA_PARAM_PORT_CONFIG_MODE_dsp: spa_param_port_config_mode = 3;
pub type spa_param_port_config_mode = ::std::os::raw::c_uint;
pub const spa_param_port_config_SPA_PARAM_PORT_CONFIG_START: spa_param_port_config = 0;
#[doc = "< (Id enum spa_direction) direction"]
pub const spa_param_port_config_SPA_PARAM_PORT_CONFIG_direction: spa_param_port_config = 1;
#[doc = "< (Id enum spa_param_port_config_mode) mode"]
pub const spa_param_port_config_SPA_PARAM_PORT_CONFIG_mode: spa_param_port_config = 2;
#[doc = "< (Bool) enable monitor output ports on input ports"]
pub const spa_param_port_config_SPA_PARAM_PORT_CONFIG_monitor: spa_param_port_config = 3;
#[doc = "< (Bool) enable control ports"]
pub const spa_param_port_config_SPA_PARAM_PORT_CONFIG_control: spa_param_port_config = 4;
#[doc = "< (Object) format filter"]
pub const spa_param_port_config_SPA_PARAM_PORT_CONFIG_format: spa_param_port_config = 5;
#[doc = " properties for SPA_TYPE_OBJECT_ParamPortConfig"]
pub type spa_param_port_config = ::std::os::raw::c_uint;
pub const spa_param_route_SPA_PARAM_ROUTE_START: spa_param_route = 0;
#[doc = "< index of the routing destination (Int)"]
pub const spa_param_route_SPA_PARAM_ROUTE_index: spa_param_route = 1;
#[doc = "< direction, input/output (Id enum spa_direction)"]
pub const spa_param_route_SPA_PARAM_ROUTE_direction: spa_param_route = 2;
#[doc = "< device id (Int)"]
pub const spa_param_route_SPA_PARAM_ROUTE_device: spa_param_route = 3;
#[doc = "< name of the routing destination (String)"]
pub const spa_param_route_SPA_PARAM_ROUTE_name: spa_param_route = 4;
#[doc = "< description of the destination (String)"]
pub const spa_param_route_SPA_PARAM_ROUTE_description: spa_param_route = 5;
#[doc = "< priority of the destination (Int)"]
pub const spa_param_route_SPA_PARAM_ROUTE_priority: spa_param_route = 6;
#[doc = "< availability of the destination\n  (Id enum spa_param_availability)"]
pub const spa_param_route_SPA_PARAM_ROUTE_available: spa_param_route = 7;
#[doc = "< info (Struct(\n\t\t  Int : n_items,\n\t\t  (String : key,\n\t\t   String : value)*))"]
pub const spa_param_route_SPA_PARAM_ROUTE_info: spa_param_route = 8;
#[doc = "< associated profile indexes (Array of Int)"]
pub const spa_param_route_SPA_PARAM_ROUTE_profiles: spa_param_route = 9;
#[doc = "< properties SPA_TYPE_OBJECT_Props"]
pub const spa_param_route_SPA_PARAM_ROUTE_props: spa_param_route = 10;
#[doc = "< associated device indexes (Array of Int)"]
pub const spa_param_route_SPA_PARAM_ROUTE_devices: spa_param_route = 11;
#[doc = "< profile id (Int)"]
pub const spa_param_route_SPA_PARAM_ROUTE_profile: spa_param_route = 12;
#[doc = "< If route should be saved (Bool)"]
pub const spa_param_route_SPA_PARAM_ROUTE_save: spa_param_route = 13;
#[doc = " properties for SPA_TYPE_OBJECT_ParamRoute"]
pub type spa_param_route = ::std::os::raw::c_uint;
pub const spa_prop_info_SPA_PROP_INFO_START: spa_prop_info = 0;
#[doc = "< associated id of the property"]
pub const spa_prop_info_SPA_PROP_INFO_id: spa_prop_info = 1;
#[doc = "< name of the property"]
pub const spa_prop_info_SPA_PROP_INFO_name: spa_prop_info = 2;
#[doc = "< type and range/enums of property"]
pub const spa_prop_info_SPA_PROP_INFO_type: spa_prop_info = 3;
#[doc = "< labels of property if any, this is a\n  struct with pairs of values, the first one\n  is of the type of the property, the second\n  one is a string with a user readable label\n  for the value."]
pub const spa_prop_info_SPA_PROP_INFO_labels: spa_prop_info = 4;
#[doc = "< type of container if any (Id)"]
pub const spa_prop_info_SPA_PROP_INFO_container: spa_prop_info = 5;
#[doc = "< is part of params property (Bool)"]
pub const spa_prop_info_SPA_PROP_INFO_params: spa_prop_info = 6;
#[doc = "< User readable description"]
pub const spa_prop_info_SPA_PROP_INFO_description: spa_prop_info = 7;
#[doc = " properties of SPA_TYPE_OBJECT_PropInfo"]
pub type spa_prop_info = ::std::os::raw::c_uint;
pub const spa_prop_SPA_PROP_START: spa_prop = 0;
#[doc = "< an unknown property"]
pub const spa_prop_SPA_PROP_unknown: spa_prop = 1;
#[doc = "< device related properties"]
pub const spa_prop_SPA_PROP_START_Device: spa_prop = 256;
pub const spa_prop_SPA_PROP_device: spa_prop = 257;
pub const spa_prop_SPA_PROP_deviceName: spa_prop = 258;
pub const spa_prop_SPA_PROP_deviceFd: spa_prop = 259;
pub const spa_prop_SPA_PROP_card: spa_prop = 260;
pub const spa_prop_SPA_PROP_cardName: spa_prop = 261;
pub const spa_prop_SPA_PROP_minLatency: spa_prop = 262;
pub const spa_prop_SPA_PROP_maxLatency: spa_prop = 263;
pub const spa_prop_SPA_PROP_periods: spa_prop = 264;
pub const spa_prop_SPA_PROP_periodSize: spa_prop = 265;
pub const spa_prop_SPA_PROP_periodEvent: spa_prop = 266;
pub const spa_prop_SPA_PROP_live: spa_prop = 267;
pub const spa_prop_SPA_PROP_rate: spa_prop = 268;
pub const spa_prop_SPA_PROP_quality: spa_prop = 269;
pub const spa_prop_SPA_PROP_bluetoothAudioCodec: spa_prop = 270;
pub const spa_prop_SPA_PROP_bluetoothOffloadActive: spa_prop = 271;
#[doc = "< audio related properties"]
pub const spa_prop_SPA_PROP_START_Audio: spa_prop = 65536;
pub const spa_prop_SPA_PROP_waveType: spa_prop = 65537;
pub const spa_prop_SPA_PROP_frequency: spa_prop = 65538;
#[doc = "< a volume (Float), 0.0 silence, 1.0 no attenutation"]
pub const spa_prop_SPA_PROP_volume: spa_prop = 65539;
#[doc = "< mute (Bool)"]
pub const spa_prop_SPA_PROP_mute: spa_prop = 65540;
pub const spa_prop_SPA_PROP_patternType: spa_prop = 65541;
pub const spa_prop_SPA_PROP_ditherType: spa_prop = 65542;
pub const spa_prop_SPA_PROP_truncate: spa_prop = 65543;
#[doc = "< a volume array, one (linear) volume per channel\n (Array of Float). 0.0 is silence, 1.0 is\n  without attenuation. This is the effective\n  volume that is applied. It can result\n  in a hardware volume and software volume\n  (see softVolumes)"]
pub const spa_prop_SPA_PROP_channelVolumes: spa_prop = 65544;
#[doc = "< a volume base (Float)"]
pub const spa_prop_SPA_PROP_volumeBase: spa_prop = 65545;
#[doc = "< a volume step (Float)"]
pub const spa_prop_SPA_PROP_volumeStep: spa_prop = 65546;
#[doc = "< a channelmap array\n (Array (Id enum spa_audio_channel))"]
pub const spa_prop_SPA_PROP_channelMap: spa_prop = 65547;
#[doc = "< mute (Bool)"]
pub const spa_prop_SPA_PROP_monitorMute: spa_prop = 65548;
#[doc = "< a volume array, one (linear) volume per\n  channel (Array of Float)"]
pub const spa_prop_SPA_PROP_monitorVolumes: spa_prop = 65549;
#[doc = "< delay adjustment"]
pub const spa_prop_SPA_PROP_latencyOffsetNsec: spa_prop = 65550;
#[doc = "< mute (Bool) applied in software"]
pub const spa_prop_SPA_PROP_softMute: spa_prop = 65551;
#[doc = "< a volume array, one (linear) volume per channel\n (Array of Float). 0.0 is silence, 1.0 is without\n attenuation. This is the volume applied in\n software, there might be a part applied in\n hardware."]
pub const spa_prop_SPA_PROP_softVolumes: spa_prop = 65552;
#[doc = "< enabled IEC958 (S/PDIF) codecs,\n  (Array (Id enum spa_audio_iec958_codec)"]
pub const spa_prop_SPA_PROP_iec958Codecs: spa_prop = 65553;
#[doc = "< Samples to ramp the volume over"]
pub const spa_prop_SPA_PROP_volumeRampSamples: spa_prop = 65554;
#[doc = "< Step or incremental Samples to ramp\n  the volume over"]
pub const spa_prop_SPA_PROP_volumeRampStepSamples: spa_prop = 65555;
#[doc = "< Time in millisec to ramp the volume over"]
pub const spa_prop_SPA_PROP_volumeRampTime: spa_prop = 65556;
#[doc = "< Step or incremental Time in nano seconds\n  to ramp the"]
pub const spa_prop_SPA_PROP_volumeRampStepTime: spa_prop = 65557;
#[doc = "< the scale or graph to used to ramp the\n  volume"]
pub const spa_prop_SPA_PROP_volumeRampScale: spa_prop = 65558;
#[doc = "< video related properties"]
pub const spa_prop_SPA_PROP_START_Video: spa_prop = 131072;
pub const spa_prop_SPA_PROP_brightness: spa_prop = 131073;
pub const spa_prop_SPA_PROP_contrast: spa_prop = 131074;
pub const spa_prop_SPA_PROP_saturation: spa_prop = 131075;
pub const spa_prop_SPA_PROP_hue: spa_prop = 131076;
pub const spa_prop_SPA_PROP_gamma: spa_prop = 131077;
pub const spa_prop_SPA_PROP_exposure: spa_prop = 131078;
pub const spa_prop_SPA_PROP_gain: spa_prop = 131079;
pub const spa_prop_SPA_PROP_sharpness: spa_prop = 131080;
#[doc = "< other properties"]
pub const spa_prop_SPA_PROP_START_Other: spa_prop = 524288;
#[doc = "< simple control params\n    (Struct(\n\t  (String : key,\n\t   Pod    : value)*))"]
pub const spa_prop_SPA_PROP_params: spa_prop = 524289;
pub const spa_prop_SPA_PROP_START_CUSTOM: spa_prop = 16777216;
#[doc = " predefined properties for SPA_TYPE_OBJECT_Props"]
pub type spa_prop = ::std::os::raw::c_uint;
pub const spa_media_type_SPA_MEDIA_TYPE_unknown: spa_media_type = 0;
pub const spa_media_type_SPA_MEDIA_TYPE_audio: spa_media_type = 1;
pub const spa_media_type_SPA_MEDIA_TYPE_video: spa_media_type = 2;
pub const spa_media_type_SPA_MEDIA_TYPE_image: spa_media_type = 3;
pub const spa_media_type_SPA_MEDIA_TYPE_binary: spa_media_type = 4;
pub const spa_media_type_SPA_MEDIA_TYPE_stream: spa_media_type = 5;
pub const spa_media_type_SPA_MEDIA_TYPE_application: spa_media_type = 6;
#[doc = " media type for SPA_TYPE_OBJECT_Format"]
pub type spa_media_type = ::std::os::raw::c_uint;
pub const spa_media_subtype_SPA_MEDIA_SUBTYPE_unknown: spa_media_subtype = 0;
pub const spa_media_subtype_SPA_MEDIA_SUBTYPE_raw: spa_media_subtype = 1;
pub const spa_media_subtype_SPA_MEDIA_SUBTYPE_dsp: spa_media_subtype = 2;
pub const spa_media_subtype_SPA_MEDIA_SUBTYPE_iec958: spa_media_subtype = 3;
#[doc = " S/PDIF"]
pub const spa_media_subtype_SPA_MEDIA_SUBTYPE_dsd: spa_media_subtype = 4;
#[doc = " S/PDIF"]
pub const spa_media_subtype_SPA_MEDIA_SUBTYPE_START_Audio: spa_media_subtype = 65536;
#[doc = " S/PDIF"]
pub const spa_media_subtype_SPA_MEDIA_SUBTYPE_mp3: spa_media_subtype = 65537;
#[doc = " S/PDIF"]
pub const spa_media_subtype_SPA_MEDIA_SUBTYPE_aac: spa_media_subtype = 65538;
#[doc = " S/PDIF"]
pub const spa_media_subtype_SPA_MEDIA_SUBTYPE_vorbis: spa_media_subtype = 65539;
#[doc = " S/PDIF"]
pub const spa_media_subtype_SPA_MEDIA_SUBTYPE_wma: spa_media_subtype = 65540;
#[doc = " S/PDIF"]
pub const spa_media_subtype_SPA_MEDIA_SUBTYPE_ra: spa_media_subtype = 65541;
#[doc = " S/PDIF"]
pub const spa_media_subtype_SPA_MEDIA_SUBTYPE_sbc: spa_media_subtype = 65542;
#[doc = " S/PDIF"]
pub const spa_media_subtype_SPA_MEDIA_SUBTYPE_adpcm: spa_media_subtype = 65543;
#[doc = " S/PDIF"]
pub const spa_media_subtype_SPA_MEDIA_SUBTYPE_g723: spa_media_subtype = 65544;
#[doc = " S/PDIF"]
pub const spa_media_subtype_SPA_MEDIA_SUBTYPE_g726: spa_media_subtype = 65545;
#[doc = " S/PDIF"]
pub const spa_media_subtype_SPA_MEDIA_SUBTYPE_g729: spa_media_subtype = 65546;
#[doc = " S/PDIF"]
pub const spa_media_subtype_SPA_MEDIA_SUBTYPE_amr: spa_media_subtype = 65547;
#[doc = " S/PDIF"]
pub const spa_media_subtype_SPA_MEDIA_SUBTYPE_gsm: spa_media_subtype = 65548;
#[doc = " S/PDIF"]
pub const spa_media_subtype_SPA_MEDIA_SUBTYPE_alac: spa_media_subtype = 65549;
#[doc = " since 0.3.65"]
pub const spa_media_subtype_SPA_MEDIA_SUBTYPE_flac: spa_media_subtype = 65550;
#[doc = " since 0.3.65"]
pub const spa_media_subtype_SPA_MEDIA_SUBTYPE_ape: spa_media_subtype = 65551;
#[doc = " since 0.3.65"]
pub const spa_media_subtype_SPA_MEDIA_SUBTYPE_opus: spa_media_subtype = 65552;
#[doc = " since 0.3.68"]
pub const spa_media_subtype_SPA_MEDIA_SUBTYPE_START_Video: spa_media_subtype = 131072;
#[doc = " since 0.3.68"]
pub const spa_media_subtype_SPA_MEDIA_SUBTYPE_h264: spa_media_subtype = 131073;
#[doc = " since 0.3.68"]
pub const spa_media_subtype_SPA_MEDIA_SUBTYPE_mjpg: spa_media_subtype = 131074;
#[doc = " since 0.3.68"]
pub const spa_media_subtype_SPA_MEDIA_SUBTYPE_dv: spa_media_subtype = 131075;
#[doc = " since 0.3.68"]
pub const spa_media_subtype_SPA_MEDIA_SUBTYPE_mpegts: spa_media_subtype = 131076;
#[doc = " since 0.3.68"]
pub const spa_media_subtype_SPA_MEDIA_SUBTYPE_h263: spa_media_subtype = 131077;
#[doc = " since 0.3.68"]
pub const spa_media_subtype_SPA_MEDIA_SUBTYPE_mpeg1: spa_media_subtype = 131078;
#[doc = " since 0.3.68"]
pub const spa_media_subtype_SPA_MEDIA_SUBTYPE_mpeg2: spa_media_subtype = 131079;
#[doc = " since 0.3.68"]
pub const spa_media_subtype_SPA_MEDIA_SUBTYPE_mpeg4: spa_media_subtype = 131080;
#[doc = " since 0.3.68"]
pub const spa_media_subtype_SPA_MEDIA_SUBTYPE_xvid: spa_media_subtype = 131081;
#[doc = " since 0.3.68"]
pub const spa_media_subtype_SPA_MEDIA_SUBTYPE_vc1: spa_media_subtype = 131082;
#[doc = " since 0.3.68"]
pub const spa_media_subtype_SPA_MEDIA_SUBTYPE_vp8: spa_media_subtype = 131083;
#[doc = " since 0.3.68"]
pub const spa_media_subtype_SPA_MEDIA_SUBTYPE_vp9: spa_media_subtype = 131084;
#[doc = " since 0.3.68"]
pub const spa_media_subtype_SPA_MEDIA_SUBTYPE_bayer: spa_media_subtype = 131085;
#[doc = " since 0.3.68"]
pub const spa_media_subtype_SPA_MEDIA_SUBTYPE_START_Image: spa_media_subtype = 196608;
#[doc = " since 0.3.68"]
pub const spa_media_subtype_SPA_MEDIA_SUBTYPE_jpeg: spa_media_subtype = 196609;
#[doc = " since 0.3.68"]
pub const spa_media_subtype_SPA_MEDIA_SUBTYPE_START_Binary: spa_media_subtype = 262144;
#[doc = " since 0.3.68"]
pub const spa_media_subtype_SPA_MEDIA_SUBTYPE_START_Stream: spa_media_subtype = 327680;
#[doc = " since 0.3.68"]
pub const spa_media_subtype_SPA_MEDIA_SUBTYPE_midi: spa_media_subtype = 327681;
#[doc = " since 0.3.68"]
pub const spa_media_subtype_SPA_MEDIA_SUBTYPE_START_Application: spa_media_subtype = 393216;
#[doc = "< control stream, data contains\n  spa_pod_sequence with control info."]
pub const spa_media_subtype_SPA_MEDIA_SUBTYPE_control: spa_media_subtype = 393217;
#[doc = " media subtype for SPA_TYPE_OBJECT_Format"]
pub type spa_media_subtype = ::std::os::raw::c_uint;
pub const spa_format_SPA_FORMAT_START: spa_format = 0;
#[doc = "< media type (Id enum spa_media_type)"]
pub const spa_format_SPA_FORMAT_mediaType: spa_format = 1;
#[doc = "< media subtype (Id enum spa_media_subtype)"]
pub const spa_format_SPA_FORMAT_mediaSubtype: spa_format = 2;
pub const spa_format_SPA_FORMAT_START_Audio: spa_format = 65536;
#[doc = "< audio format, (Id enum spa_audio_format)"]
pub const spa_format_SPA_FORMAT_AUDIO_format: spa_format = 65537;
#[doc = "< optional flags (Int)"]
pub const spa_format_SPA_FORMAT_AUDIO_flags: spa_format = 65538;
#[doc = "< sample rate (Int)"]
pub const spa_format_SPA_FORMAT_AUDIO_rate: spa_format = 65539;
#[doc = "< number of audio channels (Int)"]
pub const spa_format_SPA_FORMAT_AUDIO_channels: spa_format = 65540;
#[doc = "< channel positions (Id enum spa_audio_position)"]
pub const spa_format_SPA_FORMAT_AUDIO_position: spa_format = 65541;
#[doc = "< codec used (IEC958) (Id enum spa_audio_iec958_codec)"]
pub const spa_format_SPA_FORMAT_AUDIO_iec958Codec: spa_format = 65542;
#[doc = "< bit order (Id enum spa_param_bitorder)"]
pub const spa_format_SPA_FORMAT_AUDIO_bitorder: spa_format = 65543;
#[doc = "< Interleave bytes (Int)"]
pub const spa_format_SPA_FORMAT_AUDIO_interleave: spa_format = 65544;
#[doc = "< bit rate (Int)"]
pub const spa_format_SPA_FORMAT_AUDIO_bitrate: spa_format = 65545;
#[doc = "< audio data block alignment (Int)"]
pub const spa_format_SPA_FORMAT_AUDIO_blockAlign: spa_format = 65546;
#[doc = "< AAC stream format, (Id enum spa_audio_aac_stream_format)"]
pub const spa_format_SPA_FORMAT_AUDIO_AAC_streamFormat: spa_format = 65547;
#[doc = "< WMA profile (Id enum spa_audio_wma_profile)"]
pub const spa_format_SPA_FORMAT_AUDIO_WMA_profile: spa_format = 65548;
#[doc = "< AMR band mode (Id enum spa_audio_amr_band_mode)"]
pub const spa_format_SPA_FORMAT_AUDIO_AMR_bandMode: spa_format = 65549;
pub const spa_format_SPA_FORMAT_START_Video: spa_format = 131072;
#[doc = "< video format (Id enum spa_video_format)"]
pub const spa_format_SPA_FORMAT_VIDEO_format: spa_format = 131073;
#[doc = "< format modifier (Long)\n use only with DMA-BUF and omit for other buffer types"]
pub const spa_format_SPA_FORMAT_VIDEO_modifier: spa_format = 131074;
#[doc = "< size (Rectangle)"]
pub const spa_format_SPA_FORMAT_VIDEO_size: spa_format = 131075;
#[doc = "< frame rate (Fraction)"]
pub const spa_format_SPA_FORMAT_VIDEO_framerate: spa_format = 131076;
#[doc = "< maximum frame rate (Fraction)"]
pub const spa_format_SPA_FORMAT_VIDEO_maxFramerate: spa_format = 131077;
#[doc = "< number of views (Int)"]
pub const spa_format_SPA_FORMAT_VIDEO_views: spa_format = 131078;
#[doc = "< (Id enum spa_video_interlace_mode)"]
pub const spa_format_SPA_FORMAT_VIDEO_interlaceMode: spa_format = 131079;
#[doc = "< (Rectangle)"]
pub const spa_format_SPA_FORMAT_VIDEO_pixelAspectRatio: spa_format = 131080;
#[doc = "< (Id enum spa_video_multiview_mode)"]
pub const spa_format_SPA_FORMAT_VIDEO_multiviewMode: spa_format = 131081;
#[doc = "< (Id enum spa_video_multiview_flags)"]
pub const spa_format_SPA_FORMAT_VIDEO_multiviewFlags: spa_format = 131082;
#[doc = "< /Id enum spa_video_chroma_site)"]
pub const spa_format_SPA_FORMAT_VIDEO_chromaSite: spa_format = 131083;
#[doc = "< /Id enum spa_video_color_range)"]
pub const spa_format_SPA_FORMAT_VIDEO_colorRange: spa_format = 131084;
#[doc = "< /Id enum spa_video_color_matrix)"]
pub const spa_format_SPA_FORMAT_VIDEO_colorMatrix: spa_format = 131085;
#[doc = "< /Id enum spa_video_transfer_function)"]
pub const spa_format_SPA_FORMAT_VIDEO_transferFunction: spa_format = 131086;
#[doc = "< /Id enum spa_video_color_primaries)"]
pub const spa_format_SPA_FORMAT_VIDEO_colorPrimaries: spa_format = 131087;
#[doc = "< (Int)"]
pub const spa_format_SPA_FORMAT_VIDEO_profile: spa_format = 131088;
#[doc = "< (Int)"]
pub const spa_format_SPA_FORMAT_VIDEO_level: spa_format = 131089;
#[doc = "< (Id enum spa_h264_stream_format)"]
pub const spa_format_SPA_FORMAT_VIDEO_H264_streamFormat: spa_format = 131090;
#[doc = "< (Id enum spa_h264_alignment)"]
pub const spa_format_SPA_FORMAT_VIDEO_H264_alignment: spa_format = 131091;
pub const spa_format_SPA_FORMAT_START_Image: spa_format = 196608;
pub const spa_format_SPA_FORMAT_START_Binary: spa_format = 262144;
pub const spa_format_SPA_FORMAT_START_Stream: spa_format = 327680;
pub const spa_format_SPA_FORMAT_START_Application: spa_format = 393216;
#[doc = "< possible control types (flags choice Int,\n  mask of enum spa_control_type)"]
pub const spa_format_SPA_FORMAT_CONTROL_types: spa_format = 393217;
#[doc = " properties for audio SPA_TYPE_OBJECT_Format"]
pub type spa_format = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub static spa_type_param: [spa_type_info; 19usize];
}
pub const spa_audio_format_SPA_AUDIO_FORMAT_UNKNOWN: spa_audio_format = 0;
pub const spa_audio_format_SPA_AUDIO_FORMAT_ENCODED: spa_audio_format = 1;
pub const spa_audio_format_SPA_AUDIO_FORMAT_START_Interleaved: spa_audio_format = 256;
pub const spa_audio_format_SPA_AUDIO_FORMAT_S8: spa_audio_format = 257;
pub const spa_audio_format_SPA_AUDIO_FORMAT_U8: spa_audio_format = 258;
pub const spa_audio_format_SPA_AUDIO_FORMAT_S16_LE: spa_audio_format = 259;
pub const spa_audio_format_SPA_AUDIO_FORMAT_S16_BE: spa_audio_format = 260;
pub const spa_audio_format_SPA_AUDIO_FORMAT_U16_LE: spa_audio_format = 261;
pub const spa_audio_format_SPA_AUDIO_FORMAT_U16_BE: spa_audio_format = 262;
pub const spa_audio_format_SPA_AUDIO_FORMAT_S24_32_LE: spa_audio_format = 263;
pub const spa_audio_format_SPA_AUDIO_FORMAT_S24_32_BE: spa_audio_format = 264;
pub const spa_audio_format_SPA_AUDIO_FORMAT_U24_32_LE: spa_audio_format = 265;
pub const spa_audio_format_SPA_AUDIO_FORMAT_U24_32_BE: spa_audio_format = 266;
pub const spa_audio_format_SPA_AUDIO_FORMAT_S32_LE: spa_audio_format = 267;
pub const spa_audio_format_SPA_AUDIO_FORMAT_S32_BE: spa_audio_format = 268;
pub const spa_audio_format_SPA_AUDIO_FORMAT_U32_LE: spa_audio_format = 269;
pub const spa_audio_format_SPA_AUDIO_FORMAT_U32_BE: spa_audio_format = 270;
pub const spa_audio_format_SPA_AUDIO_FORMAT_S24_LE: spa_audio_format = 271;
pub const spa_audio_format_SPA_AUDIO_FORMAT_S24_BE: spa_audio_format = 272;
pub const spa_audio_format_SPA_AUDIO_FORMAT_U24_LE: spa_audio_format = 273;
pub const spa_audio_format_SPA_AUDIO_FORMAT_U24_BE: spa_audio_format = 274;
pub const spa_audio_format_SPA_AUDIO_FORMAT_S20_LE: spa_audio_format = 275;
pub const spa_audio_format_SPA_AUDIO_FORMAT_S20_BE: spa_audio_format = 276;
pub const spa_audio_format_SPA_AUDIO_FORMAT_U20_LE: spa_audio_format = 277;
pub const spa_audio_format_SPA_AUDIO_FORMAT_U20_BE: spa_audio_format = 278;
pub const spa_audio_format_SPA_AUDIO_FORMAT_S18_LE: spa_audio_format = 279;
pub const spa_audio_format_SPA_AUDIO_FORMAT_S18_BE: spa_audio_format = 280;
pub const spa_audio_format_SPA_AUDIO_FORMAT_U18_LE: spa_audio_format = 281;
pub const spa_audio_format_SPA_AUDIO_FORMAT_U18_BE: spa_audio_format = 282;
pub const spa_audio_format_SPA_AUDIO_FORMAT_F32_LE: spa_audio_format = 283;
pub const spa_audio_format_SPA_AUDIO_FORMAT_F32_BE: spa_audio_format = 284;
pub const spa_audio_format_SPA_AUDIO_FORMAT_F64_LE: spa_audio_format = 285;
pub const spa_audio_format_SPA_AUDIO_FORMAT_F64_BE: spa_audio_format = 286;
pub const spa_audio_format_SPA_AUDIO_FORMAT_ULAW: spa_audio_format = 287;
pub const spa_audio_format_SPA_AUDIO_FORMAT_ALAW: spa_audio_format = 288;
pub const spa_audio_format_SPA_AUDIO_FORMAT_START_Planar: spa_audio_format = 512;
pub const spa_audio_format_SPA_AUDIO_FORMAT_U8P: spa_audio_format = 513;
pub const spa_audio_format_SPA_AUDIO_FORMAT_S16P: spa_audio_format = 514;
pub const spa_audio_format_SPA_AUDIO_FORMAT_S24_32P: spa_audio_format = 515;
pub const spa_audio_format_SPA_AUDIO_FORMAT_S32P: spa_audio_format = 516;
pub const spa_audio_format_SPA_AUDIO_FORMAT_S24P: spa_audio_format = 517;
pub const spa_audio_format_SPA_AUDIO_FORMAT_F32P: spa_audio_format = 518;
pub const spa_audio_format_SPA_AUDIO_FORMAT_F64P: spa_audio_format = 519;
pub const spa_audio_format_SPA_AUDIO_FORMAT_S8P: spa_audio_format = 520;
pub const spa_audio_format_SPA_AUDIO_FORMAT_START_Other: spa_audio_format = 1024;
pub const spa_audio_format_SPA_AUDIO_FORMAT_DSP_S32: spa_audio_format = 515;
pub const spa_audio_format_SPA_AUDIO_FORMAT_DSP_F32: spa_audio_format = 518;
pub const spa_audio_format_SPA_AUDIO_FORMAT_DSP_F64: spa_audio_format = 519;
pub const spa_audio_format_SPA_AUDIO_FORMAT_S16: spa_audio_format = 259;
pub const spa_audio_format_SPA_AUDIO_FORMAT_U16: spa_audio_format = 261;
pub const spa_audio_format_SPA_AUDIO_FORMAT_S24_32: spa_audio_format = 263;
pub const spa_audio_format_SPA_AUDIO_FORMAT_U24_32: spa_audio_format = 265;
pub const spa_audio_format_SPA_AUDIO_FORMAT_S32: spa_audio_format = 267;
pub const spa_audio_format_SPA_AUDIO_FORMAT_U32: spa_audio_format = 269;
pub const spa_audio_format_SPA_AUDIO_FORMAT_S24: spa_audio_format = 271;
pub const spa_audio_format_SPA_AUDIO_FORMAT_U24: spa_audio_format = 273;
pub const spa_audio_format_SPA_AUDIO_FORMAT_S20: spa_audio_format = 275;
pub const spa_audio_format_SPA_AUDIO_FORMAT_U20: spa_audio_format = 277;
pub const spa_audio_format_SPA_AUDIO_FORMAT_S18: spa_audio_format = 279;
pub const spa_audio_format_SPA_AUDIO_FORMAT_U18: spa_audio_format = 281;
pub const spa_audio_format_SPA_AUDIO_FORMAT_F32: spa_audio_format = 283;
pub const spa_audio_format_SPA_AUDIO_FORMAT_F64: spa_audio_format = 285;
pub const spa_audio_format_SPA_AUDIO_FORMAT_S16_OE: spa_audio_format = 260;
pub const spa_audio_format_SPA_AUDIO_FORMAT_U16_OE: spa_audio_format = 262;
pub const spa_audio_format_SPA_AUDIO_FORMAT_S24_32_OE: spa_audio_format = 264;
pub const spa_audio_format_SPA_AUDIO_FORMAT_U24_32_OE: spa_audio_format = 266;
pub const spa_audio_format_SPA_AUDIO_FORMAT_S32_OE: spa_audio_format = 268;
pub const spa_audio_format_SPA_AUDIO_FORMAT_U32_OE: spa_audio_format = 270;
pub const spa_audio_format_SPA_AUDIO_FORMAT_S24_OE: spa_audio_format = 272;
pub const spa_audio_format_SPA_AUDIO_FORMAT_U24_OE: spa_audio_format = 274;
pub const spa_audio_format_SPA_AUDIO_FORMAT_S20_OE: spa_audio_format = 276;
pub const spa_audio_format_SPA_AUDIO_FORMAT_U20_OE: spa_audio_format = 278;
pub const spa_audio_format_SPA_AUDIO_FORMAT_S18_OE: spa_audio_format = 280;
pub const spa_audio_format_SPA_AUDIO_FORMAT_U18_OE: spa_audio_format = 282;
pub const spa_audio_format_SPA_AUDIO_FORMAT_F32_OE: spa_audio_format = 284;
pub const spa_audio_format_SPA_AUDIO_FORMAT_F64_OE: spa_audio_format = 286;
pub type spa_audio_format = ::std::os::raw::c_uint;
#[doc = "< unspecified"]
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_UNKNOWN: spa_audio_channel = 0;
#[doc = "< N/A, silent"]
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_NA: spa_audio_channel = 1;
#[doc = "< mono stream"]
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_MONO: spa_audio_channel = 2;
#[doc = "< front left"]
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_FL: spa_audio_channel = 3;
#[doc = "< front right"]
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_FR: spa_audio_channel = 4;
#[doc = "< front center"]
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_FC: spa_audio_channel = 5;
#[doc = "< LFE"]
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_LFE: spa_audio_channel = 6;
#[doc = "< side left"]
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_SL: spa_audio_channel = 7;
#[doc = "< side right"]
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_SR: spa_audio_channel = 8;
#[doc = "< front left center"]
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_FLC: spa_audio_channel = 9;
#[doc = "< front right center"]
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_FRC: spa_audio_channel = 10;
#[doc = "< rear center"]
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_RC: spa_audio_channel = 11;
#[doc = "< rear left"]
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_RL: spa_audio_channel = 12;
#[doc = "< rear right"]
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_RR: spa_audio_channel = 13;
#[doc = "< top center"]
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_TC: spa_audio_channel = 14;
#[doc = "< top front left"]
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_TFL: spa_audio_channel = 15;
#[doc = "< top front center"]
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_TFC: spa_audio_channel = 16;
#[doc = "< top front right"]
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_TFR: spa_audio_channel = 17;
#[doc = "< top rear left"]
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_TRL: spa_audio_channel = 18;
#[doc = "< top rear center"]
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_TRC: spa_audio_channel = 19;
#[doc = "< top rear right"]
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_TRR: spa_audio_channel = 20;
#[doc = "< rear left center"]
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_RLC: spa_audio_channel = 21;
#[doc = "< rear right center"]
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_RRC: spa_audio_channel = 22;
#[doc = "< front left wide"]
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_FLW: spa_audio_channel = 23;
#[doc = "< front right wide"]
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_FRW: spa_audio_channel = 24;
#[doc = "< LFE 2"]
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_LFE2: spa_audio_channel = 25;
#[doc = "< front left high"]
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_FLH: spa_audio_channel = 26;
#[doc = "< front center high"]
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_FCH: spa_audio_channel = 27;
#[doc = "< front right high"]
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_FRH: spa_audio_channel = 28;
#[doc = "< top front left center"]
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_TFLC: spa_audio_channel = 29;
#[doc = "< top front right center"]
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_TFRC: spa_audio_channel = 30;
#[doc = "< top side left"]
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_TSL: spa_audio_channel = 31;
#[doc = "< top side right"]
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_TSR: spa_audio_channel = 32;
#[doc = "< left LFE"]
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_LLFE: spa_audio_channel = 33;
#[doc = "< right LFE"]
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_RLFE: spa_audio_channel = 34;
#[doc = "< bottom center"]
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_BC: spa_audio_channel = 35;
#[doc = "< bottom left center"]
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_BLC: spa_audio_channel = 36;
#[doc = "< bottom right center"]
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_BRC: spa_audio_channel = 37;
#[doc = "< aux channels"]
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_START_Aux: spa_audio_channel = 4096;
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_AUX0: spa_audio_channel = 4096;
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_AUX1: spa_audio_channel = 4097;
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_AUX2: spa_audio_channel = 4098;
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_AUX3: spa_audio_channel = 4099;
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_AUX4: spa_audio_channel = 4100;
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_AUX5: spa_audio_channel = 4101;
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_AUX6: spa_audio_channel = 4102;
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_AUX7: spa_audio_channel = 4103;
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_AUX8: spa_audio_channel = 4104;
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_AUX9: spa_audio_channel = 4105;
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_AUX10: spa_audio_channel = 4106;
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_AUX11: spa_audio_channel = 4107;
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_AUX12: spa_audio_channel = 4108;
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_AUX13: spa_audio_channel = 4109;
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_AUX14: spa_audio_channel = 4110;
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_AUX15: spa_audio_channel = 4111;
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_AUX16: spa_audio_channel = 4112;
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_AUX17: spa_audio_channel = 4113;
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_AUX18: spa_audio_channel = 4114;
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_AUX19: spa_audio_channel = 4115;
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_AUX20: spa_audio_channel = 4116;
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_AUX21: spa_audio_channel = 4117;
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_AUX22: spa_audio_channel = 4118;
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_AUX23: spa_audio_channel = 4119;
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_AUX24: spa_audio_channel = 4120;
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_AUX25: spa_audio_channel = 4121;
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_AUX26: spa_audio_channel = 4122;
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_AUX27: spa_audio_channel = 4123;
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_AUX28: spa_audio_channel = 4124;
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_AUX29: spa_audio_channel = 4125;
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_AUX30: spa_audio_channel = 4126;
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_AUX31: spa_audio_channel = 4127;
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_AUX32: spa_audio_channel = 4128;
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_AUX33: spa_audio_channel = 4129;
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_AUX34: spa_audio_channel = 4130;
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_AUX35: spa_audio_channel = 4131;
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_AUX36: spa_audio_channel = 4132;
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_AUX37: spa_audio_channel = 4133;
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_AUX38: spa_audio_channel = 4134;
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_AUX39: spa_audio_channel = 4135;
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_AUX40: spa_audio_channel = 4136;
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_AUX41: spa_audio_channel = 4137;
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_AUX42: spa_audio_channel = 4138;
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_AUX43: spa_audio_channel = 4139;
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_AUX44: spa_audio_channel = 4140;
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_AUX45: spa_audio_channel = 4141;
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_AUX46: spa_audio_channel = 4142;
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_AUX47: spa_audio_channel = 4143;
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_AUX48: spa_audio_channel = 4144;
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_AUX49: spa_audio_channel = 4145;
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_AUX50: spa_audio_channel = 4146;
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_AUX51: spa_audio_channel = 4147;
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_AUX52: spa_audio_channel = 4148;
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_AUX53: spa_audio_channel = 4149;
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_AUX54: spa_audio_channel = 4150;
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_AUX55: spa_audio_channel = 4151;
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_AUX56: spa_audio_channel = 4152;
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_AUX57: spa_audio_channel = 4153;
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_AUX58: spa_audio_channel = 4154;
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_AUX59: spa_audio_channel = 4155;
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_AUX60: spa_audio_channel = 4156;
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_AUX61: spa_audio_channel = 4157;
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_AUX62: spa_audio_channel = 4158;
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_AUX63: spa_audio_channel = 4159;
#[doc = "< aux channels"]
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_LAST_Aux: spa_audio_channel = 8191;
pub const spa_audio_channel_SPA_AUDIO_CHANNEL_START_Custom: spa_audio_channel = 65536;
pub type spa_audio_channel = ::std::os::raw::c_uint;
pub const spa_audio_volume_ramp_scale_SPA_AUDIO_VOLUME_RAMP_INVALID: spa_audio_volume_ramp_scale =
    0;
pub const spa_audio_volume_ramp_scale_SPA_AUDIO_VOLUME_RAMP_LINEAR: spa_audio_volume_ramp_scale = 1;
pub const spa_audio_volume_ramp_scale_SPA_AUDIO_VOLUME_RAMP_CUBIC: spa_audio_volume_ramp_scale = 2;
pub type spa_audio_volume_ramp_scale = ::std::os::raw::c_uint;
#[doc = " Audio information description"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_audio_info_raw {
    pub format: spa_audio_format,
    pub flags: u32,
    pub rate: u32,
    pub channels: u32,
    pub position: [u32; 64usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_audio_info_raw"][::std::mem::size_of::<spa_audio_info_raw>() - 272usize];
    ["Alignment of spa_audio_info_raw"][::std::mem::align_of::<spa_audio_info_raw>() - 4usize];
    ["Offset of field: spa_audio_info_raw::format"]
        [::std::mem::offset_of!(spa_audio_info_raw, format) - 0usize];
    ["Offset of field: spa_audio_info_raw::flags"]
        [::std::mem::offset_of!(spa_audio_info_raw, flags) - 4usize];
    ["Offset of field: spa_audio_info_raw::rate"]
        [::std::mem::offset_of!(spa_audio_info_raw, rate) - 8usize];
    ["Offset of field: spa_audio_info_raw::channels"]
        [::std::mem::offset_of!(spa_audio_info_raw, channels) - 12usize];
    ["Offset of field: spa_audio_info_raw::position"]
        [::std::mem::offset_of!(spa_audio_info_raw, position) - 16usize];
};
unsafe extern "C" {
    pub static spa_type_audio_format: [spa_type_info; 71usize];
}
unsafe extern "C" {
    pub static spa_type_audio_flags: [spa_type_info; 3usize];
}
unsafe extern "C" {
    pub static spa_type_audio_channel: [spa_type_info; 103usize];
}
pub const spa_audio_iec958_codec_SPA_AUDIO_IEC958_CODEC_UNKNOWN: spa_audio_iec958_codec = 0;
pub const spa_audio_iec958_codec_SPA_AUDIO_IEC958_CODEC_PCM: spa_audio_iec958_codec = 1;
pub const spa_audio_iec958_codec_SPA_AUDIO_IEC958_CODEC_DTS: spa_audio_iec958_codec = 2;
pub const spa_audio_iec958_codec_SPA_AUDIO_IEC958_CODEC_AC3: spa_audio_iec958_codec = 3;
#[doc = "< MPEG-1 or MPEG-2 (Part 3, not AAC)"]
pub const spa_audio_iec958_codec_SPA_AUDIO_IEC958_CODEC_MPEG: spa_audio_iec958_codec = 4;
#[doc = "< MPEG-2 AAC"]
pub const spa_audio_iec958_codec_SPA_AUDIO_IEC958_CODEC_MPEG2_AAC: spa_audio_iec958_codec = 5;
pub const spa_audio_iec958_codec_SPA_AUDIO_IEC958_CODEC_EAC3: spa_audio_iec958_codec = 6;
#[doc = "< Dolby TrueHD"]
pub const spa_audio_iec958_codec_SPA_AUDIO_IEC958_CODEC_TRUEHD: spa_audio_iec958_codec = 7;
#[doc = "< DTS-HD Master Audio"]
pub const spa_audio_iec958_codec_SPA_AUDIO_IEC958_CODEC_DTSHD: spa_audio_iec958_codec = 8;
#[doc = " \\addtogroup spa_param\n \\{"]
pub type spa_audio_iec958_codec = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_audio_info_iec958 {
    pub codec: spa_audio_iec958_codec,
    pub flags: u32,
    pub rate: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_audio_info_iec958"][::std::mem::size_of::<spa_audio_info_iec958>() - 12usize];
    ["Alignment of spa_audio_info_iec958"]
        [::std::mem::align_of::<spa_audio_info_iec958>() - 4usize];
    ["Offset of field: spa_audio_info_iec958::codec"]
        [::std::mem::offset_of!(spa_audio_info_iec958, codec) - 0usize];
    ["Offset of field: spa_audio_info_iec958::flags"]
        [::std::mem::offset_of!(spa_audio_info_iec958, flags) - 4usize];
    ["Offset of field: spa_audio_info_iec958::rate"]
        [::std::mem::offset_of!(spa_audio_info_iec958, rate) - 8usize];
};
unsafe extern "C" {
    pub static spa_type_audio_iec958_codec: [spa_type_info; 10usize];
}
pub const spa_audio_mp3_channel_mode_SPA_AUDIO_MP3_CHANNEL_MODE_UNKNOWN:
    spa_audio_mp3_channel_mode = 0;
pub const spa_audio_mp3_channel_mode_SPA_AUDIO_MP3_CHANNEL_MODE_MONO: spa_audio_mp3_channel_mode =
    1;
pub const spa_audio_mp3_channel_mode_SPA_AUDIO_MP3_CHANNEL_MODE_STEREO: spa_audio_mp3_channel_mode =
    2;
pub const spa_audio_mp3_channel_mode_SPA_AUDIO_MP3_CHANNEL_MODE_JOINTSTEREO:
    spa_audio_mp3_channel_mode = 3;
pub const spa_audio_mp3_channel_mode_SPA_AUDIO_MP3_CHANNEL_MODE_DUAL: spa_audio_mp3_channel_mode =
    4;
#[doc = " \\addtogroup spa_param\n \\{"]
pub type spa_audio_mp3_channel_mode = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_audio_info_mp3 {
    pub rate: u32,
    pub channels: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_audio_info_mp3"][::std::mem::size_of::<spa_audio_info_mp3>() - 8usize];
    ["Alignment of spa_audio_info_mp3"][::std::mem::align_of::<spa_audio_info_mp3>() - 4usize];
    ["Offset of field: spa_audio_info_mp3::rate"]
        [::std::mem::offset_of!(spa_audio_info_mp3, rate) - 0usize];
    ["Offset of field: spa_audio_info_mp3::channels"]
        [::std::mem::offset_of!(spa_audio_info_mp3, channels) - 4usize];
};
unsafe extern "C" {
    pub static spa_type_audio_mp3_channel_mode: [spa_type_info; 6usize];
}
pub const spa_audio_aac_stream_format_SPA_AUDIO_AAC_STREAM_FORMAT_UNKNOWN:
    spa_audio_aac_stream_format = 0;
pub const spa_audio_aac_stream_format_SPA_AUDIO_AAC_STREAM_FORMAT_RAW: spa_audio_aac_stream_format =
    1;
pub const spa_audio_aac_stream_format_SPA_AUDIO_AAC_STREAM_FORMAT_MP2ADTS:
    spa_audio_aac_stream_format = 2;
pub const spa_audio_aac_stream_format_SPA_AUDIO_AAC_STREAM_FORMAT_MP4ADTS:
    spa_audio_aac_stream_format = 3;
pub const spa_audio_aac_stream_format_SPA_AUDIO_AAC_STREAM_FORMAT_MP4LOAS:
    spa_audio_aac_stream_format = 4;
pub const spa_audio_aac_stream_format_SPA_AUDIO_AAC_STREAM_FORMAT_MP4LATM:
    spa_audio_aac_stream_format = 5;
pub const spa_audio_aac_stream_format_SPA_AUDIO_AAC_STREAM_FORMAT_ADIF:
    spa_audio_aac_stream_format = 6;
pub const spa_audio_aac_stream_format_SPA_AUDIO_AAC_STREAM_FORMAT_MP4FF:
    spa_audio_aac_stream_format = 7;
pub const spa_audio_aac_stream_format_SPA_AUDIO_AAC_STREAM_FORMAT_CUSTOM:
    spa_audio_aac_stream_format = 65536;
#[doc = " \\addtogroup spa_param\n \\{"]
pub type spa_audio_aac_stream_format = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_audio_info_aac {
    pub rate: u32,
    pub channels: u32,
    pub bitrate: u32,
    pub stream_format: spa_audio_aac_stream_format,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_audio_info_aac"][::std::mem::size_of::<spa_audio_info_aac>() - 16usize];
    ["Alignment of spa_audio_info_aac"][::std::mem::align_of::<spa_audio_info_aac>() - 4usize];
    ["Offset of field: spa_audio_info_aac::rate"]
        [::std::mem::offset_of!(spa_audio_info_aac, rate) - 0usize];
    ["Offset of field: spa_audio_info_aac::channels"]
        [::std::mem::offset_of!(spa_audio_info_aac, channels) - 4usize];
    ["Offset of field: spa_audio_info_aac::bitrate"]
        [::std::mem::offset_of!(spa_audio_info_aac, bitrate) - 8usize];
    ["Offset of field: spa_audio_info_aac::stream_format"]
        [::std::mem::offset_of!(spa_audio_info_aac, stream_format) - 12usize];
};
unsafe extern "C" {
    pub static spa_type_audio_aac_stream_format: [spa_type_info; 9usize];
}
pub const spa_audio_wma_profile_SPA_AUDIO_WMA_PROFILE_UNKNOWN: spa_audio_wma_profile = 0;
pub const spa_audio_wma_profile_SPA_AUDIO_WMA_PROFILE_WMA7: spa_audio_wma_profile = 1;
pub const spa_audio_wma_profile_SPA_AUDIO_WMA_PROFILE_WMA8: spa_audio_wma_profile = 2;
pub const spa_audio_wma_profile_SPA_AUDIO_WMA_PROFILE_WMA9: spa_audio_wma_profile = 3;
pub const spa_audio_wma_profile_SPA_AUDIO_WMA_PROFILE_WMA10: spa_audio_wma_profile = 4;
pub const spa_audio_wma_profile_SPA_AUDIO_WMA_PROFILE_WMA9_PRO: spa_audio_wma_profile = 5;
pub const spa_audio_wma_profile_SPA_AUDIO_WMA_PROFILE_WMA9_LOSSLESS: spa_audio_wma_profile = 6;
pub const spa_audio_wma_profile_SPA_AUDIO_WMA_PROFILE_WMA10_LOSSLESS: spa_audio_wma_profile = 7;
pub const spa_audio_wma_profile_SPA_AUDIO_WMA_PROFILE_CUSTOM: spa_audio_wma_profile = 65536;
#[doc = " \\addtogroup spa_param\n \\{"]
pub type spa_audio_wma_profile = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_audio_info_wma {
    pub rate: u32,
    pub channels: u32,
    pub bitrate: u32,
    pub block_align: u32,
    pub profile: spa_audio_wma_profile,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_audio_info_wma"][::std::mem::size_of::<spa_audio_info_wma>() - 20usize];
    ["Alignment of spa_audio_info_wma"][::std::mem::align_of::<spa_audio_info_wma>() - 4usize];
    ["Offset of field: spa_audio_info_wma::rate"]
        [::std::mem::offset_of!(spa_audio_info_wma, rate) - 0usize];
    ["Offset of field: spa_audio_info_wma::channels"]
        [::std::mem::offset_of!(spa_audio_info_wma, channels) - 4usize];
    ["Offset of field: spa_audio_info_wma::bitrate"]
        [::std::mem::offset_of!(spa_audio_info_wma, bitrate) - 8usize];
    ["Offset of field: spa_audio_info_wma::block_align"]
        [::std::mem::offset_of!(spa_audio_info_wma, block_align) - 12usize];
    ["Offset of field: spa_audio_info_wma::profile"]
        [::std::mem::offset_of!(spa_audio_info_wma, profile) - 16usize];
};
unsafe extern "C" {
    pub static spa_type_audio_wma_profile: [spa_type_info; 9usize];
}
pub const spa_audio_amr_band_mode_SPA_AUDIO_AMR_BAND_MODE_UNKNOWN: spa_audio_amr_band_mode = 0;
pub const spa_audio_amr_band_mode_SPA_AUDIO_AMR_BAND_MODE_NB: spa_audio_amr_band_mode = 1;
pub const spa_audio_amr_band_mode_SPA_AUDIO_AMR_BAND_MODE_WB: spa_audio_amr_band_mode = 2;
#[doc = " \\addtogroup spa_param\n \\{"]
pub type spa_audio_amr_band_mode = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_audio_info_amr {
    pub rate: u32,
    pub channels: u32,
    pub band_mode: spa_audio_amr_band_mode,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_audio_info_amr"][::std::mem::size_of::<spa_audio_info_amr>() - 12usize];
    ["Alignment of spa_audio_info_amr"][::std::mem::align_of::<spa_audio_info_amr>() - 4usize];
    ["Offset of field: spa_audio_info_amr::rate"]
        [::std::mem::offset_of!(spa_audio_info_amr, rate) - 0usize];
    ["Offset of field: spa_audio_info_amr::channels"]
        [::std::mem::offset_of!(spa_audio_info_amr, channels) - 4usize];
    ["Offset of field: spa_audio_info_amr::band_mode"]
        [::std::mem::offset_of!(spa_audio_info_amr, band_mode) - 8usize];
};
unsafe extern "C" {
    pub static spa_type_audio_amr_band_mode: [spa_type_info; 4usize];
}
unsafe extern "C" {
    pub static spa_type_prop_float_array: [spa_type_info; 2usize];
}
unsafe extern "C" {
    pub static spa_type_prop_int_array: [spa_type_info; 2usize];
}
unsafe extern "C" {
    pub static spa_type_prop_channel_map: [spa_type_info; 2usize];
}
unsafe extern "C" {
    pub static spa_type_prop_iec958_codec: [spa_type_info; 2usize];
}
unsafe extern "C" {
    pub static spa_type_param_bitorder: [spa_type_info; 4usize];
}
unsafe extern "C" {
    pub static spa_type_param_availability: [spa_type_info; 4usize];
}
unsafe extern "C" {
    pub static spa_type_param_meta: [spa_type_info; 4usize];
}
unsafe extern "C" {
    pub static spa_type_param_io: [spa_type_info; 4usize];
}
unsafe extern "C" {
    pub static spa_type_param_buffers: [spa_type_info; 9usize];
}
pub const spa_bluetooth_audio_codec_SPA_BLUETOOTH_AUDIO_CODEC_START: spa_bluetooth_audio_codec = 0;
pub const spa_bluetooth_audio_codec_SPA_BLUETOOTH_AUDIO_CODEC_SBC: spa_bluetooth_audio_codec = 1;
pub const spa_bluetooth_audio_codec_SPA_BLUETOOTH_AUDIO_CODEC_SBC_XQ: spa_bluetooth_audio_codec = 2;
pub const spa_bluetooth_audio_codec_SPA_BLUETOOTH_AUDIO_CODEC_MPEG: spa_bluetooth_audio_codec = 3;
pub const spa_bluetooth_audio_codec_SPA_BLUETOOTH_AUDIO_CODEC_AAC: spa_bluetooth_audio_codec = 4;
pub const spa_bluetooth_audio_codec_SPA_BLUETOOTH_AUDIO_CODEC_AAC_ELD: spa_bluetooth_audio_codec =
    5;
pub const spa_bluetooth_audio_codec_SPA_BLUETOOTH_AUDIO_CODEC_APTX: spa_bluetooth_audio_codec = 6;
pub const spa_bluetooth_audio_codec_SPA_BLUETOOTH_AUDIO_CODEC_APTX_HD: spa_bluetooth_audio_codec =
    7;
pub const spa_bluetooth_audio_codec_SPA_BLUETOOTH_AUDIO_CODEC_LDAC: spa_bluetooth_audio_codec = 8;
pub const spa_bluetooth_audio_codec_SPA_BLUETOOTH_AUDIO_CODEC_APTX_LL: spa_bluetooth_audio_codec =
    9;
pub const spa_bluetooth_audio_codec_SPA_BLUETOOTH_AUDIO_CODEC_APTX_LL_DUPLEX:
    spa_bluetooth_audio_codec = 10;
pub const spa_bluetooth_audio_codec_SPA_BLUETOOTH_AUDIO_CODEC_FASTSTREAM:
    spa_bluetooth_audio_codec = 11;
pub const spa_bluetooth_audio_codec_SPA_BLUETOOTH_AUDIO_CODEC_FASTSTREAM_DUPLEX:
    spa_bluetooth_audio_codec = 12;
pub const spa_bluetooth_audio_codec_SPA_BLUETOOTH_AUDIO_CODEC_LC3PLUS_HR:
    spa_bluetooth_audio_codec = 13;
pub const spa_bluetooth_audio_codec_SPA_BLUETOOTH_AUDIO_CODEC_OPUS_05: spa_bluetooth_audio_codec =
    14;
pub const spa_bluetooth_audio_codec_SPA_BLUETOOTH_AUDIO_CODEC_OPUS_05_51:
    spa_bluetooth_audio_codec = 15;
pub const spa_bluetooth_audio_codec_SPA_BLUETOOTH_AUDIO_CODEC_OPUS_05_71:
    spa_bluetooth_audio_codec = 16;
pub const spa_bluetooth_audio_codec_SPA_BLUETOOTH_AUDIO_CODEC_OPUS_05_DUPLEX:
    spa_bluetooth_audio_codec = 17;
pub const spa_bluetooth_audio_codec_SPA_BLUETOOTH_AUDIO_CODEC_OPUS_05_PRO:
    spa_bluetooth_audio_codec = 18;
pub const spa_bluetooth_audio_codec_SPA_BLUETOOTH_AUDIO_CODEC_OPUS_G: spa_bluetooth_audio_codec =
    19;
pub const spa_bluetooth_audio_codec_SPA_BLUETOOTH_AUDIO_CODEC_CVSD: spa_bluetooth_audio_codec = 256;
pub const spa_bluetooth_audio_codec_SPA_BLUETOOTH_AUDIO_CODEC_MSBC: spa_bluetooth_audio_codec = 257;
pub const spa_bluetooth_audio_codec_SPA_BLUETOOTH_AUDIO_CODEC_LC3_SWB: spa_bluetooth_audio_codec =
    258;
pub const spa_bluetooth_audio_codec_SPA_BLUETOOTH_AUDIO_CODEC_LC3: spa_bluetooth_audio_codec = 512;
pub const spa_bluetooth_audio_codec_SPA_BLUETOOTH_AUDIO_CODEC_G722: spa_bluetooth_audio_codec = 768;
#[doc = " \\addtogroup spa_param\n \\{"]
pub type spa_bluetooth_audio_codec = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub static spa_type_bluetooth_audio_codec: [spa_type_info; 25usize];
}
unsafe extern "C" {
    pub static spa_type_props: [spa_type_info; 49usize];
}
unsafe extern "C" {
    pub static spa_type_prop_info: [spa_type_info; 9usize];
}
#[doc = "< unknown cositing"]
pub const spa_video_chroma_site_SPA_VIDEO_CHROMA_SITE_UNKNOWN: spa_video_chroma_site = 0;
#[doc = "< no cositing"]
pub const spa_video_chroma_site_SPA_VIDEO_CHROMA_SITE_NONE: spa_video_chroma_site = 1;
#[doc = "< chroma is horizontally cosited"]
pub const spa_video_chroma_site_SPA_VIDEO_CHROMA_SITE_H_COSITED: spa_video_chroma_site = 2;
#[doc = "< chroma is vertically cosited"]
pub const spa_video_chroma_site_SPA_VIDEO_CHROMA_SITE_V_COSITED: spa_video_chroma_site = 4;
#[doc = "< chroma samples are sited on alternate lines"]
pub const spa_video_chroma_site_SPA_VIDEO_CHROMA_SITE_ALT_LINE: spa_video_chroma_site = 8;
#[doc = " chroma samples cosited with luma samples"]
pub const spa_video_chroma_site_SPA_VIDEO_CHROMA_SITE_COSITED: spa_video_chroma_site = 6;
#[doc = " jpeg style cositing, also for mpeg1 and mjpeg"]
pub const spa_video_chroma_site_SPA_VIDEO_CHROMA_SITE_JPEG: spa_video_chroma_site = 1;
#[doc = " mpeg2 style cositing"]
pub const spa_video_chroma_site_SPA_VIDEO_CHROMA_SITE_MPEG2: spa_video_chroma_site = 2;
pub const spa_video_chroma_site_SPA_VIDEO_CHROMA_SITE_DV: spa_video_chroma_site = 14;
#[doc = " Various Chroma settings."]
pub type spa_video_chroma_site = ::std::os::raw::c_uint;
#[doc = "< unknown range"]
pub const spa_video_color_range_SPA_VIDEO_COLOR_RANGE_UNKNOWN: spa_video_color_range = 0;
#[doc = "< [0..255] for 8 bit components"]
pub const spa_video_color_range_SPA_VIDEO_COLOR_RANGE_0_255: spa_video_color_range = 1;
#[doc = "< [16..235] for 8 bit components. Chroma has\n[16..240] range."]
pub const spa_video_color_range_SPA_VIDEO_COLOR_RANGE_16_235: spa_video_color_range = 2;
#[doc = " Possible color range values. These constants are defined for 8 bit color\n values and can be scaled for other bit depths."]
pub type spa_video_color_range = ::std::os::raw::c_uint;
#[doc = "< unknown matrix"]
pub const spa_video_color_matrix_SPA_VIDEO_COLOR_MATRIX_UNKNOWN: spa_video_color_matrix = 0;
#[doc = "< identity matrix"]
pub const spa_video_color_matrix_SPA_VIDEO_COLOR_MATRIX_RGB: spa_video_color_matrix = 1;
#[doc = "< FCC color matrix"]
pub const spa_video_color_matrix_SPA_VIDEO_COLOR_MATRIX_FCC: spa_video_color_matrix = 2;
#[doc = "< ITU BT.709 color matrix"]
pub const spa_video_color_matrix_SPA_VIDEO_COLOR_MATRIX_BT709: spa_video_color_matrix = 3;
#[doc = "< ITU BT.601 color matrix"]
pub const spa_video_color_matrix_SPA_VIDEO_COLOR_MATRIX_BT601: spa_video_color_matrix = 4;
#[doc = "< SMTPE  240M color matrix"]
pub const spa_video_color_matrix_SPA_VIDEO_COLOR_MATRIX_SMPTE240M: spa_video_color_matrix = 5;
#[doc = "<  ITU-R BT.2020 color matrix. since 1.6."]
pub const spa_video_color_matrix_SPA_VIDEO_COLOR_MATRIX_BT2020: spa_video_color_matrix = 6;
#[doc = " The color matrix is used to convert between Y'PbPr and\n non-linear RGB (R'G'B')"]
pub type spa_video_color_matrix = ::std::os::raw::c_uint;
#[doc = "< unknown transfer function"]
pub const spa_video_transfer_function_SPA_VIDEO_TRANSFER_UNKNOWN: spa_video_transfer_function = 0;
#[doc = "< linear RGB, gamma 1.0 curve"]
pub const spa_video_transfer_function_SPA_VIDEO_TRANSFER_GAMMA10: spa_video_transfer_function = 1;
#[doc = "< Gamma 1.8 curve"]
pub const spa_video_transfer_function_SPA_VIDEO_TRANSFER_GAMMA18: spa_video_transfer_function = 2;
#[doc = "< Gamma 2.0 curve"]
pub const spa_video_transfer_function_SPA_VIDEO_TRANSFER_GAMMA20: spa_video_transfer_function = 3;
#[doc = "< Gamma 2.2 curve"]
pub const spa_video_transfer_function_SPA_VIDEO_TRANSFER_GAMMA22: spa_video_transfer_function = 4;
#[doc = "< Gamma 2.2 curve with a linear segment in the lower range"]
pub const spa_video_transfer_function_SPA_VIDEO_TRANSFER_BT709: spa_video_transfer_function = 5;
#[doc = "< Gamma 2.2 curve with a linear segment in the lower range"]
pub const spa_video_transfer_function_SPA_VIDEO_TRANSFER_SMPTE240M: spa_video_transfer_function = 6;
#[doc = "< Gamma 2.4 curve with a linear segment in the lower range"]
pub const spa_video_transfer_function_SPA_VIDEO_TRANSFER_SRGB: spa_video_transfer_function = 7;
#[doc = "< Gamma 2.8 curve"]
pub const spa_video_transfer_function_SPA_VIDEO_TRANSFER_GAMMA28: spa_video_transfer_function = 8;
#[doc = "< Logarithmic transfer characteristic 100:1 range"]
pub const spa_video_transfer_function_SPA_VIDEO_TRANSFER_LOG100: spa_video_transfer_function = 9;
#[doc = "< Logarithmic transfer characteristic 316.22777:1 range"]
pub const spa_video_transfer_function_SPA_VIDEO_TRANSFER_LOG316: spa_video_transfer_function = 10;
#[doc = "< Gamma 2.2 curve with a linear segment in the lower\n   range. Used for BT.2020 with 12 bits per\n   component. \\since 1.6."]
pub const spa_video_transfer_function_SPA_VIDEO_TRANSFER_BT2020_12: spa_video_transfer_function =
    11;
#[doc = "< Gamma 2.19921875. \\since 1.8"]
pub const spa_video_transfer_function_SPA_VIDEO_TRANSFER_ADOBERGB: spa_video_transfer_function = 12;
#[doc = " The video transfer function defines the formula for converting between\n non-linear RGB (R'G'B') and linear RGB"]
pub type spa_video_transfer_function = ::std::os::raw::c_uint;
#[doc = "< unknown color primaries"]
pub const spa_video_color_primaries_SPA_VIDEO_COLOR_PRIMARIES_UNKNOWN: spa_video_color_primaries =
    0;
#[doc = "< BT709 primaries"]
pub const spa_video_color_primaries_SPA_VIDEO_COLOR_PRIMARIES_BT709: spa_video_color_primaries = 1;
#[doc = "< BT470M primaries"]
pub const spa_video_color_primaries_SPA_VIDEO_COLOR_PRIMARIES_BT470M: spa_video_color_primaries = 2;
#[doc = "< BT470BG primaries"]
pub const spa_video_color_primaries_SPA_VIDEO_COLOR_PRIMARIES_BT470BG: spa_video_color_primaries =
    3;
#[doc = "< SMPTE170M primaries"]
pub const spa_video_color_primaries_SPA_VIDEO_COLOR_PRIMARIES_SMPTE170M: spa_video_color_primaries =
    4;
#[doc = "< SMPTE240M primaries"]
pub const spa_video_color_primaries_SPA_VIDEO_COLOR_PRIMARIES_SMPTE240M: spa_video_color_primaries =
    5;
#[doc = "< Generic film"]
pub const spa_video_color_primaries_SPA_VIDEO_COLOR_PRIMARIES_FILM: spa_video_color_primaries = 6;
#[doc = "< BT2020 primaries. \\since 1.6."]
pub const spa_video_color_primaries_SPA_VIDEO_COLOR_PRIMARIES_BT2020: spa_video_color_primaries = 7;
#[doc = "< Adobe RGB primaries. \\since 1.8"]
pub const spa_video_color_primaries_SPA_VIDEO_COLOR_PRIMARIES_ADOBERGB: spa_video_color_primaries =
    8;
#[doc = " The color primaries define the how to transform linear RGB values to and from\n the CIE XYZ colorspace."]
pub type spa_video_color_primaries = ::std::os::raw::c_uint;
#[doc = " spa_video_colorimetry:\n\n Structure describing the color info."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_video_colorimetry {
    #[doc = "< The color range. This is the valid range for the\n    samples. It is used to convert the samples to Y'PbPr\n    values."]
    pub range: spa_video_color_range,
    #[doc = "< the color matrix. Used to convert between Y'PbPr and\n    non-linear RGB (R'G'B')"]
    pub matrix: spa_video_color_matrix,
    #[doc = "< The transfer function. Used to convert between\n   R'G'B' and RGB"]
    pub transfer: spa_video_transfer_function,
    #[doc = "< Color primaries. Used to convert between R'G'B'\n   and CIE XYZ"]
    pub primaries: spa_video_color_primaries,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_video_colorimetry"][::std::mem::size_of::<spa_video_colorimetry>() - 16usize];
    ["Alignment of spa_video_colorimetry"]
        [::std::mem::align_of::<spa_video_colorimetry>() - 4usize];
    ["Offset of field: spa_video_colorimetry::range"]
        [::std::mem::offset_of!(spa_video_colorimetry, range) - 0usize];
    ["Offset of field: spa_video_colorimetry::matrix"]
        [::std::mem::offset_of!(spa_video_colorimetry, matrix) - 4usize];
    ["Offset of field: spa_video_colorimetry::transfer"]
        [::std::mem::offset_of!(spa_video_colorimetry, transfer) - 8usize];
    ["Offset of field: spa_video_colorimetry::primaries"]
        [::std::mem::offset_of!(spa_video_colorimetry, primaries) - 12usize];
};
#[doc = " A special value indicating no multiview information. Used in spa_video_info and other\n places to indicate that no specific multiview handling has been requested or provided.\n This value is never carried on caps."]
pub const spa_video_multiview_mode_SPA_VIDEO_MULTIVIEW_MODE_NONE: spa_video_multiview_mode = -1;
#[doc = "< All frames are monoscopic"]
pub const spa_video_multiview_mode_SPA_VIDEO_MULTIVIEW_MODE_MONO: spa_video_multiview_mode = 0;
#[doc = "< All frames represent a left-eye view"]
pub const spa_video_multiview_mode_SPA_VIDEO_MULTIVIEW_MODE_LEFT: spa_video_multiview_mode = 1;
#[doc = "< All frames represent a right-eye view"]
pub const spa_video_multiview_mode_SPA_VIDEO_MULTIVIEW_MODE_RIGHT: spa_video_multiview_mode = 2;
#[doc = "< Left and right eye views are provided\n   in the left and right half of the frame\n   respectively."]
pub const spa_video_multiview_mode_SPA_VIDEO_MULTIVIEW_MODE_SIDE_BY_SIDE: spa_video_multiview_mode =
    3;
#[doc = "< Left and right eye views are provided\n   in the left and right half of the\n   frame, but have been sampled using\n   quincunx method, with half-pixel offset\n   between the 2 views."]
pub const spa_video_multiview_mode_SPA_VIDEO_MULTIVIEW_MODE_SIDE_BY_SIDE_QUINCUNX:
    spa_video_multiview_mode = 4;
#[doc = "< Alternating vertical columns of pixels\n   represent the left and right eye view\n   respectively."]
pub const spa_video_multiview_mode_SPA_VIDEO_MULTIVIEW_MODE_COLUMN_INTERLEAVED:
    spa_video_multiview_mode = 5;
#[doc = "< Alternating horizontal rows of pixels\n   represent the left and right eye view\n   respectively."]
pub const spa_video_multiview_mode_SPA_VIDEO_MULTIVIEW_MODE_ROW_INTERLEAVED:
    spa_video_multiview_mode = 6;
#[doc = "< The top half of the frame contains the\n   left eye, and the bottom half the right\n   eye."]
pub const spa_video_multiview_mode_SPA_VIDEO_MULTIVIEW_MODE_TOP_BOTTOM: spa_video_multiview_mode =
    7;
#[doc = "< Pixels are arranged with alternating\n   pixels representing left and right eye\n   views in a checkerboard fashion."]
pub const spa_video_multiview_mode_SPA_VIDEO_MULTIVIEW_MODE_CHECKERBOARD: spa_video_multiview_mode =
    8;
#[doc = "< Left and right eye views are provided\n   in separate frames alternately."]
pub const spa_video_multiview_mode_SPA_VIDEO_MULTIVIEW_MODE_FRAME_BY_FRAME:
    spa_video_multiview_mode = 32;
#[doc = "< Multipleindependent views are\n   provided in separate frames in\n   sequence. This method only applies to\n   raw video buffers at the moment.\n   Specific view identification is via\n   metadata on raw video buffers."]
pub const spa_video_multiview_mode_SPA_VIDEO_MULTIVIEW_MODE_MULTIVIEW_FRAME_BY_FRAME:
    spa_video_multiview_mode = 33;
#[doc = "< Multiple views are provided as separate\n   \\ref spa_data framebuffers attached\n   to each \\ref spa_buffer, described\n   by the metadata"]
pub const spa_video_multiview_mode_SPA_VIDEO_MULTIVIEW_MODE_SEPARATED: spa_video_multiview_mode =
    34;
#[doc = " All possible stereoscopic 3D and multiview representations.\n In conjunction with \\ref spa_video_multiview_flags, describes how\n multiview content is being transported in the stream."]
pub type spa_video_multiview_mode = ::std::os::raw::c_int;
#[doc = "< No flags"]
pub const spa_video_multiview_flags_SPA_VIDEO_MULTIVIEW_FLAGS_NONE: spa_video_multiview_flags = 0;
#[doc = "< For stereo streams, the normal arrangement\n   of left and right views is reversed"]
pub const spa_video_multiview_flags_SPA_VIDEO_MULTIVIEW_FLAGS_RIGHT_VIEW_FIRST:
    spa_video_multiview_flags = 1;
#[doc = "< The left view is vertically mirrored"]
pub const spa_video_multiview_flags_SPA_VIDEO_MULTIVIEW_FLAGS_LEFT_FLIPPED:
    spa_video_multiview_flags = 2;
#[doc = "< The left view is horizontally mirrored"]
pub const spa_video_multiview_flags_SPA_VIDEO_MULTIVIEW_FLAGS_LEFT_FLOPPED:
    spa_video_multiview_flags = 4;
#[doc = "< The right view is vertically mirrored"]
pub const spa_video_multiview_flags_SPA_VIDEO_MULTIVIEW_FLAGS_RIGHT_FLIPPED:
    spa_video_multiview_flags = 8;
#[doc = "< The right view is horizontally mirrored"]
pub const spa_video_multiview_flags_SPA_VIDEO_MULTIVIEW_FLAGS_RIGHT_FLOPPED:
    spa_video_multiview_flags = 16;
#[doc = "< For frame-packed multiview\n   modes, indicates that the individual\n   views have been encoded with half the true\n   width or height and should be scaled back\n   up for display. This flag is used for\n   overriding input layout interpretation\n   by adjusting pixel-aspect-ratio.\n   For side-by-side, column interleaved or\n   checkerboard packings, the\n   pixel width will be doubled.\n   For row interleaved and\n   top-bottom encodings, pixel height will\n   be doubled"]
pub const spa_video_multiview_flags_SPA_VIDEO_MULTIVIEW_FLAGS_HALF_ASPECT:
    spa_video_multiview_flags = 16384;
#[doc = "< The video stream contains both\n   mono and multiview portions,\n   signalled on each buffer by the\n   absence or presence of a buffer flag."]
pub const spa_video_multiview_flags_SPA_VIDEO_MULTIVIEW_FLAGS_MIXED_MONO:
    spa_video_multiview_flags = 32768;
#[doc = " spa_video_multiview_flags are used to indicate extra properties of a\n stereo/multiview stream beyond the frame layout and buffer mapping\n that is conveyed in the \\ref spa_video_multiview_mode."]
pub type spa_video_multiview_flags = ::std::os::raw::c_uint;
pub const spa_video_format_SPA_VIDEO_FORMAT_UNKNOWN: spa_video_format = 0;
pub const spa_video_format_SPA_VIDEO_FORMAT_ENCODED: spa_video_format = 1;
pub const spa_video_format_SPA_VIDEO_FORMAT_I420: spa_video_format = 2;
pub const spa_video_format_SPA_VIDEO_FORMAT_YV12: spa_video_format = 3;
pub const spa_video_format_SPA_VIDEO_FORMAT_YUY2: spa_video_format = 4;
pub const spa_video_format_SPA_VIDEO_FORMAT_UYVY: spa_video_format = 5;
pub const spa_video_format_SPA_VIDEO_FORMAT_AYUV: spa_video_format = 6;
pub const spa_video_format_SPA_VIDEO_FORMAT_RGBx: spa_video_format = 7;
pub const spa_video_format_SPA_VIDEO_FORMAT_BGRx: spa_video_format = 8;
pub const spa_video_format_SPA_VIDEO_FORMAT_xRGB: spa_video_format = 9;
pub const spa_video_format_SPA_VIDEO_FORMAT_xBGR: spa_video_format = 10;
pub const spa_video_format_SPA_VIDEO_FORMAT_RGBA: spa_video_format = 11;
pub const spa_video_format_SPA_VIDEO_FORMAT_BGRA: spa_video_format = 12;
pub const spa_video_format_SPA_VIDEO_FORMAT_ARGB: spa_video_format = 13;
pub const spa_video_format_SPA_VIDEO_FORMAT_ABGR: spa_video_format = 14;
pub const spa_video_format_SPA_VIDEO_FORMAT_RGB: spa_video_format = 15;
pub const spa_video_format_SPA_VIDEO_FORMAT_BGR: spa_video_format = 16;
pub const spa_video_format_SPA_VIDEO_FORMAT_Y41B: spa_video_format = 17;
pub const spa_video_format_SPA_VIDEO_FORMAT_Y42B: spa_video_format = 18;
pub const spa_video_format_SPA_VIDEO_FORMAT_YVYU: spa_video_format = 19;
pub const spa_video_format_SPA_VIDEO_FORMAT_Y444: spa_video_format = 20;
pub const spa_video_format_SPA_VIDEO_FORMAT_v210: spa_video_format = 21;
pub const spa_video_format_SPA_VIDEO_FORMAT_v216: spa_video_format = 22;
pub const spa_video_format_SPA_VIDEO_FORMAT_NV12: spa_video_format = 23;
pub const spa_video_format_SPA_VIDEO_FORMAT_NV21: spa_video_format = 24;
pub const spa_video_format_SPA_VIDEO_FORMAT_GRAY8: spa_video_format = 25;
pub const spa_video_format_SPA_VIDEO_FORMAT_GRAY16_BE: spa_video_format = 26;
pub const spa_video_format_SPA_VIDEO_FORMAT_GRAY16_LE: spa_video_format = 27;
pub const spa_video_format_SPA_VIDEO_FORMAT_v308: spa_video_format = 28;
pub const spa_video_format_SPA_VIDEO_FORMAT_RGB16: spa_video_format = 29;
pub const spa_video_format_SPA_VIDEO_FORMAT_BGR16: spa_video_format = 30;
pub const spa_video_format_SPA_VIDEO_FORMAT_RGB15: spa_video_format = 31;
pub const spa_video_format_SPA_VIDEO_FORMAT_BGR15: spa_video_format = 32;
pub const spa_video_format_SPA_VIDEO_FORMAT_UYVP: spa_video_format = 33;
pub const spa_video_format_SPA_VIDEO_FORMAT_A420: spa_video_format = 34;
pub const spa_video_format_SPA_VIDEO_FORMAT_RGB8P: spa_video_format = 35;
pub const spa_video_format_SPA_VIDEO_FORMAT_YUV9: spa_video_format = 36;
pub const spa_video_format_SPA_VIDEO_FORMAT_YVU9: spa_video_format = 37;
pub const spa_video_format_SPA_VIDEO_FORMAT_IYU1: spa_video_format = 38;
pub const spa_video_format_SPA_VIDEO_FORMAT_ARGB64: spa_video_format = 39;
pub const spa_video_format_SPA_VIDEO_FORMAT_AYUV64: spa_video_format = 40;
pub const spa_video_format_SPA_VIDEO_FORMAT_r210: spa_video_format = 41;
pub const spa_video_format_SPA_VIDEO_FORMAT_I420_10BE: spa_video_format = 42;
pub const spa_video_format_SPA_VIDEO_FORMAT_I420_10LE: spa_video_format = 43;
pub const spa_video_format_SPA_VIDEO_FORMAT_I422_10BE: spa_video_format = 44;
pub const spa_video_format_SPA_VIDEO_FORMAT_I422_10LE: spa_video_format = 45;
pub const spa_video_format_SPA_VIDEO_FORMAT_Y444_10BE: spa_video_format = 46;
pub const spa_video_format_SPA_VIDEO_FORMAT_Y444_10LE: spa_video_format = 47;
pub const spa_video_format_SPA_VIDEO_FORMAT_GBR: spa_video_format = 48;
pub const spa_video_format_SPA_VIDEO_FORMAT_GBR_10BE: spa_video_format = 49;
pub const spa_video_format_SPA_VIDEO_FORMAT_GBR_10LE: spa_video_format = 50;
pub const spa_video_format_SPA_VIDEO_FORMAT_NV16: spa_video_format = 51;
pub const spa_video_format_SPA_VIDEO_FORMAT_NV24: spa_video_format = 52;
pub const spa_video_format_SPA_VIDEO_FORMAT_NV12_64Z32: spa_video_format = 53;
pub const spa_video_format_SPA_VIDEO_FORMAT_A420_10BE: spa_video_format = 54;
pub const spa_video_format_SPA_VIDEO_FORMAT_A420_10LE: spa_video_format = 55;
pub const spa_video_format_SPA_VIDEO_FORMAT_A422_10BE: spa_video_format = 56;
pub const spa_video_format_SPA_VIDEO_FORMAT_A422_10LE: spa_video_format = 57;
pub const spa_video_format_SPA_VIDEO_FORMAT_A444_10BE: spa_video_format = 58;
pub const spa_video_format_SPA_VIDEO_FORMAT_A444_10LE: spa_video_format = 59;
pub const spa_video_format_SPA_VIDEO_FORMAT_NV61: spa_video_format = 60;
pub const spa_video_format_SPA_VIDEO_FORMAT_P010_10BE: spa_video_format = 61;
pub const spa_video_format_SPA_VIDEO_FORMAT_P010_10LE: spa_video_format = 62;
pub const spa_video_format_SPA_VIDEO_FORMAT_IYU2: spa_video_format = 63;
pub const spa_video_format_SPA_VIDEO_FORMAT_VYUY: spa_video_format = 64;
pub const spa_video_format_SPA_VIDEO_FORMAT_GBRA: spa_video_format = 65;
pub const spa_video_format_SPA_VIDEO_FORMAT_GBRA_10BE: spa_video_format = 66;
pub const spa_video_format_SPA_VIDEO_FORMAT_GBRA_10LE: spa_video_format = 67;
pub const spa_video_format_SPA_VIDEO_FORMAT_GBR_12BE: spa_video_format = 68;
pub const spa_video_format_SPA_VIDEO_FORMAT_GBR_12LE: spa_video_format = 69;
pub const spa_video_format_SPA_VIDEO_FORMAT_GBRA_12BE: spa_video_format = 70;
pub const spa_video_format_SPA_VIDEO_FORMAT_GBRA_12LE: spa_video_format = 71;
pub const spa_video_format_SPA_VIDEO_FORMAT_I420_12BE: spa_video_format = 72;
pub const spa_video_format_SPA_VIDEO_FORMAT_I420_12LE: spa_video_format = 73;
pub const spa_video_format_SPA_VIDEO_FORMAT_I422_12BE: spa_video_format = 74;
pub const spa_video_format_SPA_VIDEO_FORMAT_I422_12LE: spa_video_format = 75;
pub const spa_video_format_SPA_VIDEO_FORMAT_Y444_12BE: spa_video_format = 76;
pub const spa_video_format_SPA_VIDEO_FORMAT_Y444_12LE: spa_video_format = 77;
pub const spa_video_format_SPA_VIDEO_FORMAT_RGBA_F16: spa_video_format = 78;
pub const spa_video_format_SPA_VIDEO_FORMAT_RGBA_F32: spa_video_format = 79;
#[doc = "< 32-bit x:R:G:B 2:10:10:10 little endian"]
pub const spa_video_format_SPA_VIDEO_FORMAT_xRGB_210LE: spa_video_format = 80;
#[doc = "< 32-bit x:B:G:R 2:10:10:10 little endian"]
pub const spa_video_format_SPA_VIDEO_FORMAT_xBGR_210LE: spa_video_format = 81;
#[doc = "< 32-bit R:G:B:x 10:10:10:2 little endian"]
pub const spa_video_format_SPA_VIDEO_FORMAT_RGBx_102LE: spa_video_format = 82;
#[doc = "< 32-bit B:G:R:x 10:10:10:2 little endian"]
pub const spa_video_format_SPA_VIDEO_FORMAT_BGRx_102LE: spa_video_format = 83;
#[doc = "< 32-bit A:R:G:B 2:10:10:10 little endian"]
pub const spa_video_format_SPA_VIDEO_FORMAT_ARGB_210LE: spa_video_format = 84;
#[doc = "< 32-bit A:B:G:R 2:10:10:10 little endian"]
pub const spa_video_format_SPA_VIDEO_FORMAT_ABGR_210LE: spa_video_format = 85;
#[doc = "< 32-bit R:G:B:A 10:10:10:2 little endian"]
pub const spa_video_format_SPA_VIDEO_FORMAT_RGBA_102LE: spa_video_format = 86;
#[doc = "< 32-bit B:G:R:A 10:10:10:2 little endian"]
pub const spa_video_format_SPA_VIDEO_FORMAT_BGRA_102LE: spa_video_format = 87;
pub const spa_video_format_SPA_VIDEO_FORMAT_DSP_F32: spa_video_format = 79;
#[doc = " Video formats\n\n The components are in general described in big-endian order. There are some\n exceptions (e.g. RGB15 and RGB16) which use the host endianness.\n\n Most of the formats are identical to their GStreamer equivalent. See the\n GStreamer video formats documentation for more details:\n\n https://gstreamer.freedesktop.org/documentation/additional/design/mediatype-video-raw.html#formats"]
pub type spa_video_format = ::std::os::raw::c_uint;
#[doc = "< no flags"]
pub const spa_video_flags_SPA_VIDEO_FLAG_NONE: spa_video_flags = 0;
#[doc = "< a variable fps is selected, fps_n and fps_d\n   denote the maximum fps of the video"]
pub const spa_video_flags_SPA_VIDEO_FLAG_VARIABLE_FPS: spa_video_flags = 1;
#[doc = "< Each color has been scaled by the alpha value."]
pub const spa_video_flags_SPA_VIDEO_FLAG_PREMULTIPLIED_ALPHA: spa_video_flags = 2;
#[doc = "< use the format modifier"]
pub const spa_video_flags_SPA_VIDEO_FLAG_MODIFIER: spa_video_flags = 4;
#[doc = "< format modifier was not fixated yet"]
pub const spa_video_flags_SPA_VIDEO_FLAG_MODIFIER_FIXATION_REQUIRED: spa_video_flags = 8;
#[doc = " Extra video flags"]
pub type spa_video_flags = ::std::os::raw::c_uint;
#[doc = "< all frames are progressive"]
pub const spa_video_interlace_mode_SPA_VIDEO_INTERLACE_MODE_PROGRESSIVE: spa_video_interlace_mode =
    0;
#[doc = "< 2 fields are interleaved in one video frame.\n Extra buffer flags describe the field order."]
pub const spa_video_interlace_mode_SPA_VIDEO_INTERLACE_MODE_INTERLEAVED: spa_video_interlace_mode =
    1;
#[doc = "< frames contains both interlaced and progressive\n   video, the buffer flags describe the frame and\n   fields."]
pub const spa_video_interlace_mode_SPA_VIDEO_INTERLACE_MODE_MIXED: spa_video_interlace_mode = 2;
#[doc = "< 2 fields are stored in one buffer, use the\n   frame ID to get access to the required\n   field. For multiview (the 'views'\n   property > 1) the fields of view N can\n   be found at frame ID (N * 2) and (N *\n   2) + 1. Each field has only half the\n   amount of lines as noted in the height\n   property. This mode requires multiple\n   spa_data to describe the fields."]
pub const spa_video_interlace_mode_SPA_VIDEO_INTERLACE_MODE_FIELDS: spa_video_interlace_mode = 3;
#[doc = " The possible values of the #spa_video_interlace_mode describing the interlace\n mode of the stream."]
pub type spa_video_interlace_mode = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_video_info_raw {
    #[doc = "< the format"]
    pub format: spa_video_format,
    #[doc = "< extra video flags"]
    pub flags: u32,
    #[doc = "< format modifier\n only used with DMA-BUF"]
    pub modifier: u64,
    #[doc = "< the frame size of the video"]
    pub size: spa_rectangle,
    #[doc = "< the framerate of the video, 0/1 means variable rate"]
    pub framerate: spa_fraction,
    #[doc = "< the maximum framerate of the video. This is only valid when\n\\ref framerate is 0/1"]
    pub max_framerate: spa_fraction,
    #[doc = "< the number of views in this video"]
    pub views: u32,
    #[doc = "< the interlace mode"]
    pub interlace_mode: spa_video_interlace_mode,
    #[doc = "< the pixel aspect ratio"]
    pub pixel_aspect_ratio: spa_fraction,
    #[doc = "< multiview mode"]
    pub multiview_mode: spa_video_multiview_mode,
    #[doc = "< multiview flags"]
    pub multiview_flags: spa_video_multiview_flags,
    #[doc = "< the chroma siting"]
    pub chroma_site: spa_video_chroma_site,
    #[doc = "< the color range. This is the valid range for the samples.\n   It is used to convert the samples to Y'PbPr values."]
    pub color_range: spa_video_color_range,
    #[doc = "< the color matrix. Used to convert between Y'PbPr and\n   non-linear RGB (R'G'B')"]
    pub color_matrix: spa_video_color_matrix,
    #[doc = "< the transfer function. used to convert between R'G'B' and RGB"]
    pub transfer_function: spa_video_transfer_function,
    #[doc = "< color primaries. used to convert between R'G'B' and CIE XYZ"]
    pub color_primaries: spa_video_color_primaries,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_video_info_raw"][::std::mem::size_of::<spa_video_info_raw>() - 88usize];
    ["Alignment of spa_video_info_raw"][::std::mem::align_of::<spa_video_info_raw>() - 8usize];
    ["Offset of field: spa_video_info_raw::format"]
        [::std::mem::offset_of!(spa_video_info_raw, format) - 0usize];
    ["Offset of field: spa_video_info_raw::flags"]
        [::std::mem::offset_of!(spa_video_info_raw, flags) - 4usize];
    ["Offset of field: spa_video_info_raw::modifier"]
        [::std::mem::offset_of!(spa_video_info_raw, modifier) - 8usize];
    ["Offset of field: spa_video_info_raw::size"]
        [::std::mem::offset_of!(spa_video_info_raw, size) - 16usize];
    ["Offset of field: spa_video_info_raw::framerate"]
        [::std::mem::offset_of!(spa_video_info_raw, framerate) - 24usize];
    ["Offset of field: spa_video_info_raw::max_framerate"]
        [::std::mem::offset_of!(spa_video_info_raw, max_framerate) - 32usize];
    ["Offset of field: spa_video_info_raw::views"]
        [::std::mem::offset_of!(spa_video_info_raw, views) - 40usize];
    ["Offset of field: spa_video_info_raw::interlace_mode"]
        [::std::mem::offset_of!(spa_video_info_raw, interlace_mode) - 44usize];
    ["Offset of field: spa_video_info_raw::pixel_aspect_ratio"]
        [::std::mem::offset_of!(spa_video_info_raw, pixel_aspect_ratio) - 48usize];
    ["Offset of field: spa_video_info_raw::multiview_mode"]
        [::std::mem::offset_of!(spa_video_info_raw, multiview_mode) - 56usize];
    ["Offset of field: spa_video_info_raw::multiview_flags"]
        [::std::mem::offset_of!(spa_video_info_raw, multiview_flags) - 60usize];
    ["Offset of field: spa_video_info_raw::chroma_site"]
        [::std::mem::offset_of!(spa_video_info_raw, chroma_site) - 64usize];
    ["Offset of field: spa_video_info_raw::color_range"]
        [::std::mem::offset_of!(spa_video_info_raw, color_range) - 68usize];
    ["Offset of field: spa_video_info_raw::color_matrix"]
        [::std::mem::offset_of!(spa_video_info_raw, color_matrix) - 72usize];
    ["Offset of field: spa_video_info_raw::transfer_function"]
        [::std::mem::offset_of!(spa_video_info_raw, transfer_function) - 76usize];
    ["Offset of field: spa_video_info_raw::color_primaries"]
        [::std::mem::offset_of!(spa_video_info_raw, color_primaries) - 80usize];
};
unsafe extern "C" {
    pub static spa_type_video_format: [spa_type_info; 89usize];
}
unsafe extern "C" {
    pub static spa_type_video_flags: [spa_type_info; 5usize];
}
unsafe extern "C" {
    pub static spa_type_video_interlace_mode: [spa_type_info; 5usize];
}
unsafe extern "C" {
    pub static spa_type_media_type: [spa_type_info; 8usize];
}
unsafe extern "C" {
    pub static spa_type_media_subtype: [spa_type_info; 38usize];
}
unsafe extern "C" {
    pub static spa_type_format: [spa_type_info; 37usize];
}
pub const spa_param_latency_SPA_PARAM_LATENCY_START: spa_param_latency = 0;
#[doc = "< direction, input/output (Id enum spa_direction)"]
pub const spa_param_latency_SPA_PARAM_LATENCY_direction: spa_param_latency = 1;
#[doc = "< min latency relative to quantum (Float)"]
pub const spa_param_latency_SPA_PARAM_LATENCY_minQuantum: spa_param_latency = 2;
#[doc = "< max latency relative to quantum (Float)"]
pub const spa_param_latency_SPA_PARAM_LATENCY_maxQuantum: spa_param_latency = 3;
#[doc = "< min latency (Int) relative to graph rate"]
pub const spa_param_latency_SPA_PARAM_LATENCY_minRate: spa_param_latency = 4;
#[doc = "< max latency (Int) relative to graph rate"]
pub const spa_param_latency_SPA_PARAM_LATENCY_maxRate: spa_param_latency = 5;
#[doc = "< min latency (Long) in nanoseconds"]
pub const spa_param_latency_SPA_PARAM_LATENCY_minNs: spa_param_latency = 6;
#[doc = "< max latency (Long) in nanoseconds"]
pub const spa_param_latency_SPA_PARAM_LATENCY_maxNs: spa_param_latency = 7;
#[doc = " Properties for SPA_TYPE_OBJECT_ParamLatency\n\n The latency indicates:\n\n - for playback: time delay between start of a graph cycle, and the rendering of\n   the first sample of that cycle in audio output.\n\n - for capture: time delay between start of a graph cycle, and the first sample\n   of that cycle having occurred in audio input.\n\n For physical output/input, the latency is intended to correspond to the\n rendering/capture of physical audio, including hardware internal rendering delay.\n\n The latency values are adjusted by \\ref SPA_PROP_latencyOffsetNsec or\n SPA_PARAM_ProcessLatency, if present. (e.g. for ALSA this is used to adjust for\n the internal hardware latency)."]
pub type spa_param_latency = ::std::os::raw::c_uint;
#[doc = " helper structure for managing latency objects"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_latency_info {
    pub direction: spa_direction,
    pub min_quantum: f32,
    pub max_quantum: f32,
    pub min_rate: i32,
    pub max_rate: i32,
    pub min_ns: i64,
    pub max_ns: i64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_latency_info"][::std::mem::size_of::<spa_latency_info>() - 40usize];
    ["Alignment of spa_latency_info"][::std::mem::align_of::<spa_latency_info>() - 8usize];
    ["Offset of field: spa_latency_info::direction"]
        [::std::mem::offset_of!(spa_latency_info, direction) - 0usize];
    ["Offset of field: spa_latency_info::min_quantum"]
        [::std::mem::offset_of!(spa_latency_info, min_quantum) - 4usize];
    ["Offset of field: spa_latency_info::max_quantum"]
        [::std::mem::offset_of!(spa_latency_info, max_quantum) - 8usize];
    ["Offset of field: spa_latency_info::min_rate"]
        [::std::mem::offset_of!(spa_latency_info, min_rate) - 12usize];
    ["Offset of field: spa_latency_info::max_rate"]
        [::std::mem::offset_of!(spa_latency_info, max_rate) - 16usize];
    ["Offset of field: spa_latency_info::min_ns"]
        [::std::mem::offset_of!(spa_latency_info, min_ns) - 24usize];
    ["Offset of field: spa_latency_info::max_ns"]
        [::std::mem::offset_of!(spa_latency_info, max_ns) - 32usize];
};
pub const spa_param_process_latency_SPA_PARAM_PROCESS_LATENCY_START: spa_param_process_latency = 0;
#[doc = "< latency relative to quantum (Float)"]
pub const spa_param_process_latency_SPA_PARAM_PROCESS_LATENCY_quantum: spa_param_process_latency =
    1;
#[doc = "< latency (Int) relative to graph rate"]
pub const spa_param_process_latency_SPA_PARAM_PROCESS_LATENCY_rate: spa_param_process_latency = 2;
#[doc = "< latency (Long) in nanoseconds"]
pub const spa_param_process_latency_SPA_PARAM_PROCESS_LATENCY_ns: spa_param_process_latency = 3;
#[doc = " Properties for SPA_TYPE_OBJECT_ParamProcessLatency\n\n The processing latency indicates logical time delay between a sample in an input port,\n and a corresponding sample in an output port, relative to the graph time."]
pub type spa_param_process_latency = ::std::os::raw::c_uint;
#[doc = " Helper structure for managing process latency objects"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_process_latency_info {
    pub quantum: f32,
    pub rate: i32,
    pub ns: i64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_process_latency_info"]
        [::std::mem::size_of::<spa_process_latency_info>() - 16usize];
    ["Alignment of spa_process_latency_info"]
        [::std::mem::align_of::<spa_process_latency_info>() - 8usize];
    ["Offset of field: spa_process_latency_info::quantum"]
        [::std::mem::offset_of!(spa_process_latency_info, quantum) - 0usize];
    ["Offset of field: spa_process_latency_info::rate"]
        [::std::mem::offset_of!(spa_process_latency_info, rate) - 4usize];
    ["Offset of field: spa_process_latency_info::ns"]
        [::std::mem::offset_of!(spa_process_latency_info, ns) - 8usize];
};
unsafe extern "C" {
    pub static spa_type_param_latency: [spa_type_info; 9usize];
}
unsafe extern "C" {
    pub static spa_type_param_process_latency: [spa_type_info; 5usize];
}
unsafe extern "C" {
    pub static spa_type_param_port_config_mode: [spa_type_info; 5usize];
}
unsafe extern "C" {
    pub static spa_type_param_port_config: [spa_type_info; 7usize];
}
pub const spa_profiler_SPA_PROFILER_START: spa_profiler = 0;
#[doc = "< driver related profiler properties"]
pub const spa_profiler_SPA_PROFILER_START_Driver: spa_profiler = 65536;
#[doc = "< Generic info, counter and CPU load,\n (Struct(\n      Long : counter,\n      Float : cpu_load fast,\n      Float : cpu_load medium,\n      Float : cpu_load slow),\n      Int : xrun-count))"]
pub const spa_profiler_SPA_PROFILER_info: spa_profiler = 65537;
#[doc = "< clock information\n  (Struct(\n      Int : clock flags,\n      Int : clock id,\n      String: clock name,\n      Long : clock nsec,\n      Fraction : clock rate,\n      Long : clock position,\n      Long : clock duration,\n      Long : clock delay,\n      Double : clock rate_diff,\n      Long : clock next_nsec,\n      Int : transport_state,\n      Int : clock cycle,\n      Long : xrun duration))"]
pub const spa_profiler_SPA_PROFILER_clock: spa_profiler = 65538;
#[doc = "< generic driver info block\n  (Struct(\n      Int : driver_id,\n      String : name,\n      Long : driver prev_signal,\n      Long : driver signal,\n      Long : driver awake,\n      Long : driver finish,\n      Int : driver status,\n      Fraction : latency,\n      Int : xrun_count))"]
pub const spa_profiler_SPA_PROFILER_driverBlock: spa_profiler = 65539;
#[doc = "< follower related profiler properties"]
pub const spa_profiler_SPA_PROFILER_START_Follower: spa_profiler = 131072;
#[doc = "< generic follower info block\n  (Struct(\n      Int : id,\n      String : name,\n      Long : prev_signal,\n      Long : signal,\n      Long : awake,\n      Long : finish,\n      Int : status,\n      Fraction : latency,\n      Int : xrun_count))"]
pub const spa_profiler_SPA_PROFILER_followerBlock: spa_profiler = 131073;
#[doc = "< follower clock information\n  (Struct(\n      Int : clock id,\n      String: clock name,\n      Long : clock nsec,\n      Fraction : clock rate,\n      Long : clock position,\n      Long : clock duration,\n      Long : clock delay,\n      Double : clock rate_diff,\n      Long : clock next_nsec,\n      Long : xrun duration))"]
pub const spa_profiler_SPA_PROFILER_followerClock: spa_profiler = 131074;
pub const spa_profiler_SPA_PROFILER_START_CUSTOM: spa_profiler = 16777216;
#[doc = " properties for SPA_TYPE_OBJECT_Profiler"]
pub type spa_profiler = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub static spa_type_profiler: [spa_type_info; 7usize];
}
unsafe extern "C" {
    pub static spa_type_param_profile: [spa_type_info; 10usize];
}
unsafe extern "C" {
    pub static spa_type_param_route: [spa_type_info; 15usize];
}
pub const spa_param_tag_SPA_PARAM_TAG_START: spa_param_tag = 0;
#[doc = "< direction, input/output (Id enum spa_direction)"]
pub const spa_param_tag_SPA_PARAM_TAG_direction: spa_param_tag = 1;
#[doc = "< Struct(\n      Int: n_items\n      (String: key\n       String: value)*\n  )"]
pub const spa_param_tag_SPA_PARAM_TAG_info: spa_param_tag = 2;
#[doc = " properties for SPA_TYPE_OBJECT_ParamTag"]
pub type spa_param_tag = ::std::os::raw::c_uint;
#[doc = " helper structure for managing tag objects"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_tag_info {
    pub direction: spa_direction,
    pub info: *const spa_pod,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_tag_info"][::std::mem::size_of::<spa_tag_info>() - 16usize];
    ["Alignment of spa_tag_info"][::std::mem::align_of::<spa_tag_info>() - 8usize];
    ["Offset of field: spa_tag_info::direction"]
        [::std::mem::offset_of!(spa_tag_info, direction) - 0usize];
    ["Offset of field: spa_tag_info::info"][::std::mem::offset_of!(spa_tag_info, info) - 8usize];
};
unsafe extern "C" {
    pub static spa_type_param_tag: [spa_type_info; 4usize];
}
unsafe extern "C" {
    pub static spa_types: [spa_type_info; 46usize];
}
#[doc = " \\addtogroup spa_dict\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_dict_item {
    pub key: *const ::std::os::raw::c_char,
    pub value: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_dict_item"][::std::mem::size_of::<spa_dict_item>() - 16usize];
    ["Alignment of spa_dict_item"][::std::mem::align_of::<spa_dict_item>() - 8usize];
    ["Offset of field: spa_dict_item::key"][::std::mem::offset_of!(spa_dict_item, key) - 0usize];
    ["Offset of field: spa_dict_item::value"]
        [::std::mem::offset_of!(spa_dict_item, value) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_dict {
    pub flags: u32,
    pub n_items: u32,
    pub items: *const spa_dict_item,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_dict"][::std::mem::size_of::<spa_dict>() - 16usize];
    ["Alignment of spa_dict"][::std::mem::align_of::<spa_dict>() - 8usize];
    ["Offset of field: spa_dict::flags"][::std::mem::offset_of!(spa_dict, flags) - 0usize];
    ["Offset of field: spa_dict::n_items"][::std::mem::offset_of!(spa_dict, n_items) - 4usize];
    ["Offset of field: spa_dict::items"][::std::mem::offset_of!(spa_dict, items) - 8usize];
};
#[doc = " \\addtogroup spa_list List\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_list {
    pub next: *mut spa_list,
    pub prev: *mut spa_list,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_list"][::std::mem::size_of::<spa_list>() - 16usize];
    ["Alignment of spa_list"][::std::mem::align_of::<spa_list>() - 8usize];
    ["Offset of field: spa_list::next"][::std::mem::offset_of!(spa_list, next) - 0usize];
    ["Offset of field: spa_list::prev"][::std::mem::offset_of!(spa_list, prev) - 8usize];
};
#[doc = " \\struct spa_callbacks\n Callbacks, contains the structure with functions and the data passed\n to the functions.  The structure should also contain a version field that\n is checked."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_callbacks {
    pub funcs: *const ::std::os::raw::c_void,
    pub data: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_callbacks"][::std::mem::size_of::<spa_callbacks>() - 16usize];
    ["Alignment of spa_callbacks"][::std::mem::align_of::<spa_callbacks>() - 8usize];
    ["Offset of field: spa_callbacks::funcs"]
        [::std::mem::offset_of!(spa_callbacks, funcs) - 0usize];
    ["Offset of field: spa_callbacks::data"][::std::mem::offset_of!(spa_callbacks, data) - 8usize];
};
#[doc = " \\struct spa_interface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_interface {
    pub type_: *const ::std::os::raw::c_char,
    pub version: u32,
    pub cb: spa_callbacks,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_interface"][::std::mem::size_of::<spa_interface>() - 32usize];
    ["Alignment of spa_interface"][::std::mem::align_of::<spa_interface>() - 8usize];
    ["Offset of field: spa_interface::type_"]
        [::std::mem::offset_of!(spa_interface, type_) - 0usize];
    ["Offset of field: spa_interface::version"]
        [::std::mem::offset_of!(spa_interface, version) - 8usize];
    ["Offset of field: spa_interface::cb"][::std::mem::offset_of!(spa_interface, cb) - 16usize];
};
#[doc = " \\struct spa_hook_list\n A list of hooks. This struct is primarily used by\n implementation that use multiple caller-provided \\ref spa_hook."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_hook_list {
    pub list: spa_list,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_hook_list"][::std::mem::size_of::<spa_hook_list>() - 16usize];
    ["Alignment of spa_hook_list"][::std::mem::align_of::<spa_hook_list>() - 8usize];
    ["Offset of field: spa_hook_list::list"][::std::mem::offset_of!(spa_hook_list, list) - 0usize];
};
#[doc = " \\struct spa_hook\n A hook, contains the structure with functions and the data passed\n to the functions.\n\n A hook should be treated as opaque by the caller."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_hook {
    pub link: spa_list,
    pub cb: spa_callbacks,
    #[doc = " callback and data for the hook list, private to the\n hook_list implementor"]
    pub removed: ::std::option::Option<unsafe extern "C" fn(hook: *mut spa_hook)>,
    pub priv_: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_hook"][::std::mem::size_of::<spa_hook>() - 48usize];
    ["Alignment of spa_hook"][::std::mem::align_of::<spa_hook>() - 8usize];
    ["Offset of field: spa_hook::link"][::std::mem::offset_of!(spa_hook, link) - 0usize];
    ["Offset of field: spa_hook::cb"][::std::mem::offset_of!(spa_hook, cb) - 16usize];
    ["Offset of field: spa_hook::removed"][::std::mem::offset_of!(spa_hook, removed) - 32usize];
    ["Offset of field: spa_hook::priv_"][::std::mem::offset_of!(spa_hook, priv_) - 40usize];
};
pub const spa_log_level_SPA_LOG_LEVEL_NONE: spa_log_level = 0;
pub const spa_log_level_SPA_LOG_LEVEL_ERROR: spa_log_level = 1;
pub const spa_log_level_SPA_LOG_LEVEL_WARN: spa_log_level = 2;
pub const spa_log_level_SPA_LOG_LEVEL_INFO: spa_log_level = 3;
pub const spa_log_level_SPA_LOG_LEVEL_DEBUG: spa_log_level = 4;
pub const spa_log_level_SPA_LOG_LEVEL_TRACE: spa_log_level = 5;
pub type spa_log_level = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_log {
    pub iface: spa_interface,
    #[doc = " Logging level, everything above this level is not logged"]
    pub level: spa_log_level,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_log"][::std::mem::size_of::<spa_log>() - 40usize];
    ["Alignment of spa_log"][::std::mem::align_of::<spa_log>() - 8usize];
    ["Offset of field: spa_log::iface"][::std::mem::offset_of!(spa_log, iface) - 0usize];
    ["Offset of field: spa_log::level"][::std::mem::offset_of!(spa_log, level) - 32usize];
};
#[doc = " \\struct spa_log_topic\n\n Identifier for a topic. Topics are string-based filters that logically\n group messages together. An implementation may decide to filter different\n topics on different levels, for example the \"protocol\" topic may require\n debug level TRACE while the \"core\" topic defaults to debug level INFO.\n\n spa_log_topics require a spa_log_methods version of 1 or higher."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_log_topic {
    #[doc = " the version of this topic. This can be used to expand this\n structure in the future"]
    pub version: u32,
    #[doc = " The string identifier for the topic"]
    pub topic: *const ::std::os::raw::c_char,
    #[doc = " Logging level set for this topic"]
    pub level: spa_log_level,
    #[doc = " False if this topic follows the \\ref spa_log level"]
    pub has_custom_level: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_log_topic"][::std::mem::size_of::<spa_log_topic>() - 24usize];
    ["Alignment of spa_log_topic"][::std::mem::align_of::<spa_log_topic>() - 8usize];
    ["Offset of field: spa_log_topic::version"]
        [::std::mem::offset_of!(spa_log_topic, version) - 0usize];
    ["Offset of field: spa_log_topic::topic"]
        [::std::mem::offset_of!(spa_log_topic, topic) - 8usize];
    ["Offset of field: spa_log_topic::level"]
        [::std::mem::offset_of!(spa_log_topic, level) - 16usize];
    ["Offset of field: spa_log_topic::has_custom_level"]
        [::std::mem::offset_of!(spa_log_topic, has_custom_level) - 20usize];
};
#[doc = " Enumeration of log topics in a plugin\n\n \\since 1.1.0"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_log_topic_enum {
    pub version: u32,
    #[doc = " Array of pointers to log topics"]
    pub topics: *const *mut spa_log_topic,
    #[doc = " End of topics array"]
    pub topics_end: *const *mut spa_log_topic,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_log_topic_enum"][::std::mem::size_of::<spa_log_topic_enum>() - 24usize];
    ["Alignment of spa_log_topic_enum"][::std::mem::align_of::<spa_log_topic_enum>() - 8usize];
    ["Offset of field: spa_log_topic_enum::version"]
        [::std::mem::offset_of!(spa_log_topic_enum, version) - 0usize];
    ["Offset of field: spa_log_topic_enum::topics"]
        [::std::mem::offset_of!(spa_log_topic_enum, topics) - 8usize];
    ["Offset of field: spa_log_topic_enum::topics_end"]
        [::std::mem::offset_of!(spa_log_topic_enum, topics_end) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_log_methods {
    pub version: u32,
    #[doc = " Log a message with the given log level.\n\n \\note If compiled with this header, this function is only called\n for implementations of version 0. For versions 1 and above, see\n logt() instead.\n\n \\param log a spa_log\n \\param level a spa_log_level\n \\param file the file name\n \\param line the line number\n \\param func the function name\n \\param fmt printf style format\n \\param ... format arguments"]
    pub log: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            level: spa_log_level,
            file: *const ::std::os::raw::c_char,
            line: ::std::os::raw::c_int,
            func: *const ::std::os::raw::c_char,
            fmt: *const ::std::os::raw::c_char,
            ...
        ),
    >,
    #[doc = " Log a message with the given log level.\n\n \\note If compiled with this header, this function is only called\n for implementations of version 0. For versions 1 and above, see\n logtv() instead.\n\n \\param log a spa_log\n \\param level a spa_log_level\n \\param file the file name\n \\param line the line number\n \\param func the function name\n \\param fmt printf style format\n \\param args format arguments"]
    pub logv: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            level: spa_log_level,
            file: *const ::std::os::raw::c_char,
            line: ::std::os::raw::c_int,
            func: *const ::std::os::raw::c_char,
            fmt: *const ::std::os::raw::c_char,
            args: *mut __va_list_tag,
        ),
    >,
    #[doc = " Log a message with the given log level for the given topic.\n\n \\note Callers that do not use topic-based logging (version 0), the \\a\n topic is NULL\n\n \\param log a spa_log\n \\param level a spa_log_level\n \\param topic the topic for this message, may be NULL\n \\param file the file name\n \\param line the line number\n \\param func the function name\n \\param fmt printf style format\n \\param ... format arguments\n\n \\since 1"]
    pub logt: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            level: spa_log_level,
            topic: *const spa_log_topic,
            file: *const ::std::os::raw::c_char,
            line: ::std::os::raw::c_int,
            func: *const ::std::os::raw::c_char,
            fmt: *const ::std::os::raw::c_char,
            ...
        ),
    >,
    #[doc = " Log a message with the given log level for the given topic.\n\n \\note For callers that do not use topic-based logging (version 0),\n the \\a topic is NULL\n\n \\param log a spa_log\n \\param level a spa_log_level\n \\param topic the topic for this message, may be NULL\n \\param file the file name\n \\param line the line number\n \\param func the function name\n \\param fmt printf style format\n \\param args format arguments\n\n \\since 1"]
    pub logtv: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            level: spa_log_level,
            topic: *const spa_log_topic,
            file: *const ::std::os::raw::c_char,
            line: ::std::os::raw::c_int,
            func: *const ::std::os::raw::c_char,
            fmt: *const ::std::os::raw::c_char,
            args: *mut __va_list_tag,
        ),
    >,
    #[doc = " Initializes a \\ref spa_log_topic to the correct logging level.\n\n \\deprecated\n Plugin host should obtain log topics from \\ref SPA_LOG_TOPIC_ENUM_NAME\n and update them itself.\n\n \\since 1"]
    pub topic_init: ::std::option::Option<
        unsafe extern "C" fn(object: *mut ::std::os::raw::c_void, topic: *mut spa_log_topic),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_log_methods"][::std::mem::size_of::<spa_log_methods>() - 48usize];
    ["Alignment of spa_log_methods"][::std::mem::align_of::<spa_log_methods>() - 8usize];
    ["Offset of field: spa_log_methods::version"]
        [::std::mem::offset_of!(spa_log_methods, version) - 0usize];
    ["Offset of field: spa_log_methods::log"]
        [::std::mem::offset_of!(spa_log_methods, log) - 8usize];
    ["Offset of field: spa_log_methods::logv"]
        [::std::mem::offset_of!(spa_log_methods, logv) - 16usize];
    ["Offset of field: spa_log_methods::logt"]
        [::std::mem::offset_of!(spa_log_methods, logt) - 24usize];
    ["Offset of field: spa_log_methods::logtv"]
        [::std::mem::offset_of!(spa_log_methods, logtv) - 32usize];
    ["Offset of field: spa_log_methods::topic_init"]
        [::std::mem::offset_of!(spa_log_methods, topic_init) - 40usize];
};
#[doc = " \\addtogroup spa_pod\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_pod_frame {
    pub pod: spa_pod,
    pub parent: *mut spa_pod_frame,
    pub offset: u32,
    pub flags: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_frame"][::std::mem::size_of::<spa_pod_frame>() - 24usize];
    ["Alignment of spa_pod_frame"][::std::mem::align_of::<spa_pod_frame>() - 8usize];
    ["Offset of field: spa_pod_frame::pod"][::std::mem::offset_of!(spa_pod_frame, pod) - 0usize];
    ["Offset of field: spa_pod_frame::parent"]
        [::std::mem::offset_of!(spa_pod_frame, parent) - 8usize];
    ["Offset of field: spa_pod_frame::offset"]
        [::std::mem::offset_of!(spa_pod_frame, offset) - 16usize];
    ["Offset of field: spa_pod_frame::flags"]
        [::std::mem::offset_of!(spa_pod_frame, flags) - 20usize];
};
#[doc = " \\addtogroup spa_pod\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_pod_parser_state {
    pub offset: u32,
    pub flags: u32,
    pub frame: *mut spa_pod_frame,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_parser_state"][::std::mem::size_of::<spa_pod_parser_state>() - 16usize];
    ["Alignment of spa_pod_parser_state"][::std::mem::align_of::<spa_pod_parser_state>() - 8usize];
    ["Offset of field: spa_pod_parser_state::offset"]
        [::std::mem::offset_of!(spa_pod_parser_state, offset) - 0usize];
    ["Offset of field: spa_pod_parser_state::flags"]
        [::std::mem::offset_of!(spa_pod_parser_state, flags) - 4usize];
    ["Offset of field: spa_pod_parser_state::frame"]
        [::std::mem::offset_of!(spa_pod_parser_state, frame) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_pod_parser {
    pub data: *const ::std::os::raw::c_void,
    pub size: u32,
    pub _padding: u32,
    pub state: spa_pod_parser_state,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_parser"][::std::mem::size_of::<spa_pod_parser>() - 32usize];
    ["Alignment of spa_pod_parser"][::std::mem::align_of::<spa_pod_parser>() - 8usize];
    ["Offset of field: spa_pod_parser::data"]
        [::std::mem::offset_of!(spa_pod_parser, data) - 0usize];
    ["Offset of field: spa_pod_parser::size"]
        [::std::mem::offset_of!(spa_pod_parser, size) - 8usize];
    ["Offset of field: spa_pod_parser::_padding"]
        [::std::mem::offset_of!(spa_pod_parser, _padding) - 12usize];
    ["Offset of field: spa_pod_parser::state"]
        [::std::mem::offset_of!(spa_pod_parser, state) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_debug_file_ctx {
    pub ctx: spa_debug_context,
    pub f: *mut FILE,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_debug_file_ctx"][::std::mem::size_of::<spa_debug_file_ctx>() - 16usize];
    ["Alignment of spa_debug_file_ctx"][::std::mem::align_of::<spa_debug_file_ctx>() - 8usize];
    ["Offset of field: spa_debug_file_ctx::ctx"]
        [::std::mem::offset_of!(spa_debug_file_ctx, ctx) - 0usize];
    ["Offset of field: spa_debug_file_ctx::f"]
        [::std::mem::offset_of!(spa_debug_file_ctx, f) - 8usize];
};
#[doc = " \\addtogroup spa_debug\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_debug_log_ctx {
    pub ctx: spa_debug_context,
    pub log: *mut spa_log,
    pub level: spa_log_level,
    pub topic: *const spa_log_topic,
    pub file: *const ::std::os::raw::c_char,
    pub line: ::std::os::raw::c_int,
    pub func: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_debug_log_ctx"][::std::mem::size_of::<spa_debug_log_ctx>() - 56usize];
    ["Alignment of spa_debug_log_ctx"][::std::mem::align_of::<spa_debug_log_ctx>() - 8usize];
    ["Offset of field: spa_debug_log_ctx::ctx"]
        [::std::mem::offset_of!(spa_debug_log_ctx, ctx) - 0usize];
    ["Offset of field: spa_debug_log_ctx::log"]
        [::std::mem::offset_of!(spa_debug_log_ctx, log) - 8usize];
    ["Offset of field: spa_debug_log_ctx::level"]
        [::std::mem::offset_of!(spa_debug_log_ctx, level) - 16usize];
    ["Offset of field: spa_debug_log_ctx::topic"]
        [::std::mem::offset_of!(spa_debug_log_ctx, topic) - 24usize];
    ["Offset of field: spa_debug_log_ctx::file"]
        [::std::mem::offset_of!(spa_debug_log_ctx, file) - 32usize];
    ["Offset of field: spa_debug_log_ctx::line"]
        [::std::mem::offset_of!(spa_debug_log_ctx, line) - 40usize];
    ["Offset of field: spa_debug_log_ctx::func"]
        [::std::mem::offset_of!(spa_debug_log_ctx, func) - 48usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_node {
    pub iface: spa_interface,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_node"][::std::mem::size_of::<spa_node>() - 32usize];
    ["Alignment of spa_node"][::std::mem::align_of::<spa_node>() - 8usize];
    ["Offset of field: spa_node::iface"][::std::mem::offset_of!(spa_node, iface) - 0usize];
};
#[doc = " Node information structure\n\n Contains the basic node information."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_node_info {
    pub max_input_ports: u32,
    pub max_output_ports: u32,
    pub change_mask: u64,
    pub flags: u64,
    #[doc = "< extra node properties"]
    pub props: *mut spa_dict,
    #[doc = "< parameter information"]
    pub params: *mut spa_param_info,
    #[doc = "< number of items in \\a params"]
    pub n_params: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_node_info"][::std::mem::size_of::<spa_node_info>() - 48usize];
    ["Alignment of spa_node_info"][::std::mem::align_of::<spa_node_info>() - 8usize];
    ["Offset of field: spa_node_info::max_input_ports"]
        [::std::mem::offset_of!(spa_node_info, max_input_ports) - 0usize];
    ["Offset of field: spa_node_info::max_output_ports"]
        [::std::mem::offset_of!(spa_node_info, max_output_ports) - 4usize];
    ["Offset of field: spa_node_info::change_mask"]
        [::std::mem::offset_of!(spa_node_info, change_mask) - 8usize];
    ["Offset of field: spa_node_info::flags"]
        [::std::mem::offset_of!(spa_node_info, flags) - 16usize];
    ["Offset of field: spa_node_info::props"]
        [::std::mem::offset_of!(spa_node_info, props) - 24usize];
    ["Offset of field: spa_node_info::params"]
        [::std::mem::offset_of!(spa_node_info, params) - 32usize];
    ["Offset of field: spa_node_info::n_params"]
        [::std::mem::offset_of!(spa_node_info, n_params) - 40usize];
};
#[doc = " Port information structure\n\n Contains the basic port information."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_port_info {
    pub change_mask: u64,
    #[doc = "< port flags"]
    pub flags: u64,
    #[doc = "< rate of sequence numbers on port"]
    pub rate: spa_fraction,
    #[doc = "< extra port properties"]
    pub props: *const spa_dict,
    #[doc = "< parameter information"]
    pub params: *mut spa_param_info,
    #[doc = "< number of items in \\a params"]
    pub n_params: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_port_info"][::std::mem::size_of::<spa_port_info>() - 48usize];
    ["Alignment of spa_port_info"][::std::mem::align_of::<spa_port_info>() - 8usize];
    ["Offset of field: spa_port_info::change_mask"]
        [::std::mem::offset_of!(spa_port_info, change_mask) - 0usize];
    ["Offset of field: spa_port_info::flags"]
        [::std::mem::offset_of!(spa_port_info, flags) - 8usize];
    ["Offset of field: spa_port_info::rate"][::std::mem::offset_of!(spa_port_info, rate) - 16usize];
    ["Offset of field: spa_port_info::props"]
        [::std::mem::offset_of!(spa_port_info, props) - 24usize];
    ["Offset of field: spa_port_info::params"]
        [::std::mem::offset_of!(spa_port_info, params) - 32usize];
    ["Offset of field: spa_port_info::n_params"]
        [::std::mem::offset_of!(spa_port_info, n_params) - 40usize];
};
#[doc = " an error result"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_result_node_error {
    pub message: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_result_node_error"][::std::mem::size_of::<spa_result_node_error>() - 8usize];
    ["Alignment of spa_result_node_error"]
        [::std::mem::align_of::<spa_result_node_error>() - 8usize];
    ["Offset of field: spa_result_node_error::message"]
        [::std::mem::offset_of!(spa_result_node_error, message) - 0usize];
};
#[doc = " the result of enum_params or port_enum_params."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_result_node_params {
    #[doc = "< id of parameter"]
    pub id: u32,
    #[doc = "< index of parameter"]
    pub index: u32,
    #[doc = "< next index of iteration"]
    pub next: u32,
    #[doc = "< the result param"]
    pub param: *mut spa_pod,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_result_node_params"][::std::mem::size_of::<spa_result_node_params>() - 24usize];
    ["Alignment of spa_result_node_params"]
        [::std::mem::align_of::<spa_result_node_params>() - 8usize];
    ["Offset of field: spa_result_node_params::id"]
        [::std::mem::offset_of!(spa_result_node_params, id) - 0usize];
    ["Offset of field: spa_result_node_params::index"]
        [::std::mem::offset_of!(spa_result_node_params, index) - 4usize];
    ["Offset of field: spa_result_node_params::next"]
        [::std::mem::offset_of!(spa_result_node_params, next) - 8usize];
    ["Offset of field: spa_result_node_params::param"]
        [::std::mem::offset_of!(spa_result_node_params, param) - 16usize];
};
#[doc = " events from the spa_node.\n\n All event are called from the main thread and multiple\n listeners can be registered for the events with\n spa_node_add_listener()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_node_events {
    #[doc = "< version of this structure"]
    pub version: u32,
    #[doc = " Emitted when info changes"]
    pub info: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, info: *const spa_node_info),
    >,
    #[doc = " Emitted when port info changes, NULL when port is removed"]
    pub port_info: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            direction: spa_direction,
            port: u32,
            info: *const spa_port_info,
        ),
    >,
    #[doc = " notify a result.\n\n Some methods will trigger a result event with an optional\n result of the given type. Look at the documentation of the\n method to know when to expect a result event.\n\n The result event can be called synchronously, as an event\n called from inside the method itself, in which case the seq\n number passed to the method will be passed unchanged.\n\n The result event will be called asynchronously when the\n method returned an async return value. In this case, the seq\n number in the result will match the async return value of\n the method call. Users should match the seq number from\n request to the reply."]
    pub result: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            seq: ::std::os::raw::c_int,
            res: ::std::os::raw::c_int,
            type_: u32,
            result: *const ::std::os::raw::c_void,
        ),
    >,
    #[doc = " \\param node a spa_node\n \\param event the event that was emitted\n\n This will be called when an out-of-bound event is notified\n on \\a node."]
    pub event: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, event: *const spa_event),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_node_events"][::std::mem::size_of::<spa_node_events>() - 40usize];
    ["Alignment of spa_node_events"][::std::mem::align_of::<spa_node_events>() - 8usize];
    ["Offset of field: spa_node_events::version"]
        [::std::mem::offset_of!(spa_node_events, version) - 0usize];
    ["Offset of field: spa_node_events::info"]
        [::std::mem::offset_of!(spa_node_events, info) - 8usize];
    ["Offset of field: spa_node_events::port_info"]
        [::std::mem::offset_of!(spa_node_events, port_info) - 16usize];
    ["Offset of field: spa_node_events::result"]
        [::std::mem::offset_of!(spa_node_events, result) - 24usize];
    ["Offset of field: spa_node_events::event"]
        [::std::mem::offset_of!(spa_node_events, event) - 32usize];
};
#[doc = " Node callbacks\n\n Callbacks are called from the real-time data thread. Only\n one callback structure can be set on an spa_node."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_node_callbacks {
    pub version: u32,
    #[doc = " \\param node a spa_node\n\n The node is ready for processing.\n\n When this function is NULL, synchronous operation is requested\n on the ports."]
    pub ready: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            state: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " \\param node a spa_node\n \\param port_id an input port_id\n \\param buffer_id the buffer id to be reused\n\n The node has a buffer that can be reused.\n\n When this function is NULL, the buffers to reuse will be set in\n the io area of the input ports."]
    pub reuse_buffer: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            port_id: u32,
            buffer_id: u32,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " \\param data user data\n \\param trigger the timestamp in microseconds when the xrun happened\n \\param delay the amount of microseconds of xrun.\n \\param info an object with extra info (NULL for now)\n\n The node has encountered an over or underrun\n\n The info contains an object with more information"]
    pub xrun: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            trigger: u64,
            delay: u64,
            info: *mut spa_pod,
        ) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_node_callbacks"][::std::mem::size_of::<spa_node_callbacks>() - 32usize];
    ["Alignment of spa_node_callbacks"][::std::mem::align_of::<spa_node_callbacks>() - 8usize];
    ["Offset of field: spa_node_callbacks::version"]
        [::std::mem::offset_of!(spa_node_callbacks, version) - 0usize];
    ["Offset of field: spa_node_callbacks::ready"]
        [::std::mem::offset_of!(spa_node_callbacks, ready) - 8usize];
    ["Offset of field: spa_node_callbacks::reuse_buffer"]
        [::std::mem::offset_of!(spa_node_callbacks, reuse_buffer) - 16usize];
    ["Offset of field: spa_node_callbacks::xrun"]
        [::std::mem::offset_of!(spa_node_callbacks, xrun) - 24usize];
};
#[doc = " Node methods"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_node_methods {
    pub version: u32,
    #[doc = " Adds an event listener on \\a node.\n\n Setting the events will trigger the info event and a\n port_info event for each managed port on the new\n listener.\n\n \\param node a #spa_node\n \\param listener a listener\n \\param events a struct \\ref spa_node_events\n \\param data data passed as first argument in functions of \\a events\n \\return 0 on success\n\t   < 0 errno on error"]
    pub add_listener: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            listener: *mut spa_hook,
            events: *const spa_node_events,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Set callbacks to on \\a node.\n if \\a callbacks is NULL, the current callbacks are removed.\n\n This function must be called from the main thread.\n\n All callbacks are called from the data thread.\n\n \\param node a spa_node\n \\param callbacks callbacks to set\n \\return 0 on success\n         -EINVAL when node is NULL"]
    pub set_callbacks: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            callbacks: *const spa_node_callbacks,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Perform a sync operation.\n\n This method will emit the result event with the given sequence\n number synchronously or with the returned async return value\n asynchronously.\n\n Because all methods are serialized in the node, this can be used\n to wait for completion of all previous method calls.\n\n \\param seq a sequence number\n \\return 0 on success\n         -EINVAL when node is NULL\n         an async result"]
    pub sync: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            seq: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Enumerate the parameters of a node.\n\n Parameters are identified with an \\a id. Some parameters can have\n multiple values, see the documentation of the parameter id.\n\n Parameters can be filtered by passing a non-NULL \\a filter.\n\n The function will emit the result event up to \\a max times with\n the result value. The seq in the result will either be the \\a seq\n number when executed synchronously or the async return value of\n this function when executed asynchronously.\n\n This function must be called from the main thread.\n\n \\param node a \\ref spa_node\n \\param seq a sequence number to pass to the result event when\n\tthis method is executed synchronously.\n \\param id the param id to enumerate\n \\param start the index of enumeration, pass 0 for the first item\n \\param max the maximum number of parameters to enumerate\n \\param filter and optional filter to use\n\n \\return 0 when no more items can be iterated.\n         -EINVAL when invalid arguments are given\n         -ENOENT the parameter \\a id is unknown\n         -ENOTSUP when there are no parameters\n                 implemented on \\a node\n         an async return value when the result event will be\n             emitted later."]
    pub enum_params: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            seq: ::std::os::raw::c_int,
            id: u32,
            start: u32,
            max: u32,
            filter: *const spa_pod,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Set the configurable parameter in \\a node.\n\n Usually, \\a param will be obtained from enum_params and then\n modified but it is also possible to set another spa_pod\n as long as its keys and types match a supported object.\n\n Objects with property keys that are not known are ignored.\n\n This function must be called from the main thread.\n\n \\param node a \\ref spa_node\n \\param id the parameter id to configure\n \\param flags additional flags\n \\param param the parameter to configure\n\n \\return 0 on success\n         -EINVAL when node is NULL\n         -ENOTSUP when there are no parameters implemented on \\a node\n         -ENOENT the parameter is unknown"]
    pub set_param: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            id: u32,
            flags: u32,
            param: *const spa_pod,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Configure the given memory area with \\a id on \\a node. This\n structure is allocated by the host and is used to exchange\n data and parameters with the node.\n\n Setting an \\a io of NULL will disable the node io.\n\n This function must be called from the main thread.\n\n \\param id the id of the io area, the available ids can be\n        enumerated with the node parameters.\n \\param data a io area memory\n \\param size the size of \\a data\n \\return 0 on success\n         -EINVAL when invalid input is given\n         -ENOENT when \\a id is unknown\n         -ENOSPC when \\a size is too small"]
    pub set_io: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            id: u32,
            data: *mut ::std::os::raw::c_void,
            size: usize,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Send a command to a node.\n\n Upon completion, a command might change the state of a node.\n\n This function must be called from the main thread.\n\n \\param node a  spa_node\n \\param command a spa_command\n \\return 0 on success\n         -EINVAL when node or command is NULL\n         -ENOTSUP when this node can't process commands\n         -EINVAL \\a command is an invalid command"]
    pub send_command: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            command: *const spa_command,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Make a new port with \\a port_id. The caller should use the lowest unused\n port id for the given \\a direction.\n\n Port ids should be between 0 and max_ports as obtained from the info\n event.\n\n This function must be called from the main thread.\n\n \\param node a  spa_node\n \\param direction a enum \\ref spa_direction\n \\param port_id an unused port id\n \\param props extra properties\n \\return 0 on success\n         -EINVAL when node is NULL"]
    pub add_port: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            direction: spa_direction,
            port_id: u32,
            props: *const spa_dict,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Remove a port with \\a port_id.\n\n \\param node a  spa_node\n \\param direction a enum \\ref spa_direction\n \\param port_id a port id\n \\return 0 on success\n         -EINVAL when node is NULL or when port_id is unknown or\n\t\twhen the port can't be removed."]
    pub remove_port: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            direction: spa_direction,
            port_id: u32,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Enumerate all possible parameters of \\a id on \\a port_id of \\a node\n that are compatible with \\a filter.\n\n When SPA_ID_INVALID is given as the port_id, the node will reply with\n the params that would be returned for a new port in the given direction.\n\n The result parameters can be queried and modified and ultimately be used\n to call port_set_param.\n\n The function will emit the result event up to \\a max times with\n the result value. The seq in the result event will either be the\n \\a seq number when executed synchronously or the async return\n value of this function when executed asynchronously.\n\n This function must be called from the main thread.\n\n \\param node a spa_node\n \\param seq a sequence number to pass to the result event when\n\tthis method is executed synchronously.\n \\param direction an spa_direction\n \\param port_id the port to query or SPA_ID_INVALID\n \\param id the parameter id to query\n \\param start the first index to query, 0 to get the first item\n \\param max the maximum number of params to query\n \\param filter a parameter filter or NULL for no filter\n\n \\return 0 when no more items can be iterated.\n         -EINVAL when invalid parameters are given\n         -ENOENT when \\a id is unknown\n         an async return value when the result event will be\n             emitted later."]
    pub port_enum_params: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            seq: ::std::os::raw::c_int,
            direction: spa_direction,
            port_id: u32,
            id: u32,
            start: u32,
            max: u32,
            filter: *const spa_pod,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Set a parameter on \\a port_id of \\a node.\n\n When \\a param is NULL, the parameter will be unset.\n\n This function must be called from the main thread. The node muse be paused\n or the port SPA_IO_Buffers area is NULL when this function is called with\n a param that changes the processing state (like a format change).\n\n \\param node a struct \\ref spa_node\n \\param direction a enum \\ref spa_direction\n \\param port_id the port to configure\n \\param id the parameter id to set\n \\param flags optional flags\n \\param param a struct \\ref spa_pod with the parameter to set\n \\return 0 on success\n         1 on success, the value of \\a param might have been\n                changed depending on \\a flags and the final value can be found by\n                doing port_enum_params.\n         -EINVAL when node is NULL or invalid arguments are given\n         -ESRCH when one of the mandatory param\n                 properties is not specified and SPA_NODE_PARAM_FLAG_FIXATE was\n                 not set in \\a flags.\n         -ESRCH when the type or size of a property is not correct.\n         -ENOENT when the param id is not found"]
    pub port_set_param: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            direction: spa_direction,
            port_id: u32,
            id: u32,
            flags: u32,
            param: *const spa_pod,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Tell the port to use the given buffers\n\n When \\a flags contains SPA_NODE_BUFFERS_FLAG_ALLOC, the data\n in the buffers should point to an array of at least 1 data entry\n with the desired supported type that will be filled by this function.\n\n The port should also have a spa_io_buffers io area configured to exchange\n the buffers with the port.\n\n For an input port, all the buffers will remain dequeued.\n Once a buffer has been queued on a port in the spa_io_buffers,\n it should not be reused until the reuse_buffer callback is notified\n or when the buffer has been returned in the spa_io_buffers of\n the port.\n\n For output ports, all buffers will be queued in the port. When process\n returns SPA_STATUS_HAVE_DATA, buffers are available in one or more\n of the spa_io_buffers areas.\n\n When a buffer can be reused, port_reuse_buffer() should be called or the\n buffer_id should be placed in the spa_io_buffers area before calling\n process.\n\n Passing NULL as \\a buffers will remove the reference that the port has\n on the buffers.\n\n When this function returns async, use the spa_node_sync operation to\n wait for completion.\n\n This function must be called from the main thread. The node muse be paused\n or the port SPA_IO_Buffers area is NULL when this function is called.\n\n \\param object an object implementing the interface\n \\param direction a port direction\n \\param port_id a port id\n \\param flags extra flags\n \\param buffers an array of buffer pointers\n \\param n_buffers number of elements in \\a buffers\n \\return 0 on success"]
    pub port_use_buffers: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            direction: spa_direction,
            port_id: u32,
            flags: u32,
            buffers: *mut *mut spa_buffer,
            n_buffers: u32,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Configure the given memory area with \\a id on \\a port_id. This\n structure is allocated by the host and is used to exchange\n data and parameters with the port.\n\n Setting an \\a io of NULL will disable the port io.\n\n This function must be called from the main thread.\n\n This function can be called when the node is running and the node\n must be prepared to handle changes in io areas while running. This\n is normally done by synchronizing the port io updates with the\n data processing loop.\n\n \\param direction a spa_direction\n \\param port_id a port id\n \\param id the id of the io area, the available ids can be\n        enumerated with the port parameters.\n \\param data a io area memory\n \\param size the size of \\a data\n \\return 0 on success\n         -EINVAL when invalid input is given\n         -ENOENT when \\a id is unknown\n         -ENOSPC when \\a size is too small"]
    pub port_set_io: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            direction: spa_direction,
            port_id: u32,
            id: u32,
            data: *mut ::std::os::raw::c_void,
            size: usize,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Tell an output port to reuse a buffer.\n\n This function must be called from the data thread.\n\n \\param node a spa_node\n \\param port_id a port id\n \\param buffer_id a buffer id to reuse\n \\return 0 on success\n         -EINVAL when node is NULL"]
    pub port_reuse_buffer: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            port_id: u32,
            buffer_id: u32,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Process the node\n\n This function must be called from the data thread.\n\n Output io areas with SPA_STATUS_NEED_DATA will recycle the\n buffers if any.\n\n Input areas with SPA_STATUS_HAVE_DATA are consumed if possible\n and the status is set to SPA_STATUS_NEED_DATA or SPA_STATUS_OK.\n\n When the node has new output buffers, the SPA_STATUS_HAVE_DATA\n bit will be set.\n\n When the node can accept new input in the next cycle, the\n SPA_STATUS_NEED_DATA bit will be set.\n\n Note that the node might return SPA_STATUS_NEED_DATA even when\n no input ports have this status. This means that the amount of\n data still available on the input ports is likely not going to\n be enough for the next cycle and the host might need to prefetch\n data for the next cycle."]
    pub process: ::std::option::Option<
        unsafe extern "C" fn(object: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_node_methods"][::std::mem::size_of::<spa_node_methods>() - 128usize];
    ["Alignment of spa_node_methods"][::std::mem::align_of::<spa_node_methods>() - 8usize];
    ["Offset of field: spa_node_methods::version"]
        [::std::mem::offset_of!(spa_node_methods, version) - 0usize];
    ["Offset of field: spa_node_methods::add_listener"]
        [::std::mem::offset_of!(spa_node_methods, add_listener) - 8usize];
    ["Offset of field: spa_node_methods::set_callbacks"]
        [::std::mem::offset_of!(spa_node_methods, set_callbacks) - 16usize];
    ["Offset of field: spa_node_methods::sync"]
        [::std::mem::offset_of!(spa_node_methods, sync) - 24usize];
    ["Offset of field: spa_node_methods::enum_params"]
        [::std::mem::offset_of!(spa_node_methods, enum_params) - 32usize];
    ["Offset of field: spa_node_methods::set_param"]
        [::std::mem::offset_of!(spa_node_methods, set_param) - 40usize];
    ["Offset of field: spa_node_methods::set_io"]
        [::std::mem::offset_of!(spa_node_methods, set_io) - 48usize];
    ["Offset of field: spa_node_methods::send_command"]
        [::std::mem::offset_of!(spa_node_methods, send_command) - 56usize];
    ["Offset of field: spa_node_methods::add_port"]
        [::std::mem::offset_of!(spa_node_methods, add_port) - 64usize];
    ["Offset of field: spa_node_methods::remove_port"]
        [::std::mem::offset_of!(spa_node_methods, remove_port) - 72usize];
    ["Offset of field: spa_node_methods::port_enum_params"]
        [::std::mem::offset_of!(spa_node_methods, port_enum_params) - 80usize];
    ["Offset of field: spa_node_methods::port_set_param"]
        [::std::mem::offset_of!(spa_node_methods, port_set_param) - 88usize];
    ["Offset of field: spa_node_methods::port_use_buffers"]
        [::std::mem::offset_of!(spa_node_methods, port_use_buffers) - 96usize];
    ["Offset of field: spa_node_methods::port_set_io"]
        [::std::mem::offset_of!(spa_node_methods, port_set_io) - 104usize];
    ["Offset of field: spa_node_methods::port_reuse_buffer"]
        [::std::mem::offset_of!(spa_node_methods, port_reuse_buffer) - 112usize];
    ["Offset of field: spa_node_methods::process"]
        [::std::mem::offset_of!(spa_node_methods, process) - 120usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_graph_state {
    #[doc = "< current status"]
    pub status: ::std::os::raw::c_int,
    #[doc = "< required number of signals"]
    pub required: i32,
    #[doc = "< number of pending signals"]
    pub pending: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_graph_state"][::std::mem::size_of::<spa_graph_state>() - 12usize];
    ["Alignment of spa_graph_state"][::std::mem::align_of::<spa_graph_state>() - 4usize];
    ["Offset of field: spa_graph_state::status"]
        [::std::mem::offset_of!(spa_graph_state, status) - 0usize];
    ["Offset of field: spa_graph_state::required"]
        [::std::mem::offset_of!(spa_graph_state, required) - 4usize];
    ["Offset of field: spa_graph_state::pending"]
        [::std::mem::offset_of!(spa_graph_state, pending) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_graph_link {
    pub link: spa_list,
    pub state: *mut spa_graph_state,
    pub signal: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    pub signal_data: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_graph_link"][::std::mem::size_of::<spa_graph_link>() - 40usize];
    ["Alignment of spa_graph_link"][::std::mem::align_of::<spa_graph_link>() - 8usize];
    ["Offset of field: spa_graph_link::link"]
        [::std::mem::offset_of!(spa_graph_link, link) - 0usize];
    ["Offset of field: spa_graph_link::state"]
        [::std::mem::offset_of!(spa_graph_link, state) - 16usize];
    ["Offset of field: spa_graph_link::signal"]
        [::std::mem::offset_of!(spa_graph_link, signal) - 24usize];
    ["Offset of field: spa_graph_link::signal_data"]
        [::std::mem::offset_of!(spa_graph_link, signal_data) - 32usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_graph {
    pub flags: u32,
    pub parent: *mut spa_graph_node,
    pub state: *mut spa_graph_state,
    pub nodes: spa_list,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_graph"][::std::mem::size_of::<spa_graph>() - 40usize];
    ["Alignment of spa_graph"][::std::mem::align_of::<spa_graph>() - 8usize];
    ["Offset of field: spa_graph::flags"][::std::mem::offset_of!(spa_graph, flags) - 0usize];
    ["Offset of field: spa_graph::parent"][::std::mem::offset_of!(spa_graph, parent) - 8usize];
    ["Offset of field: spa_graph::state"][::std::mem::offset_of!(spa_graph, state) - 16usize];
    ["Offset of field: spa_graph::nodes"][::std::mem::offset_of!(spa_graph, nodes) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_graph_node_callbacks {
    pub version: u32,
    pub process: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            node: *mut spa_graph_node,
        ) -> ::std::os::raw::c_int,
    >,
    pub reuse_buffer: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            node: *mut spa_graph_node,
            port_id: u32,
            buffer_id: u32,
        ) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_graph_node_callbacks"]
        [::std::mem::size_of::<spa_graph_node_callbacks>() - 24usize];
    ["Alignment of spa_graph_node_callbacks"]
        [::std::mem::align_of::<spa_graph_node_callbacks>() - 8usize];
    ["Offset of field: spa_graph_node_callbacks::version"]
        [::std::mem::offset_of!(spa_graph_node_callbacks, version) - 0usize];
    ["Offset of field: spa_graph_node_callbacks::process"]
        [::std::mem::offset_of!(spa_graph_node_callbacks, process) - 8usize];
    ["Offset of field: spa_graph_node_callbacks::reuse_buffer"]
        [::std::mem::offset_of!(spa_graph_node_callbacks, reuse_buffer) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_graph_node {
    #[doc = "< link in graph nodes list"]
    pub link: spa_list,
    #[doc = "< owner graph"]
    pub graph: *mut spa_graph,
    #[doc = "< list of input and output ports"]
    pub ports: [spa_list; 2usize],
    #[doc = "< list of links to next nodes"]
    pub links: spa_list,
    #[doc = "< node flags"]
    pub flags: u32,
    #[doc = "< state of the node"]
    pub state: *mut spa_graph_state,
    #[doc = "< link in graph"]
    pub graph_link: spa_graph_link,
    #[doc = "< subgraph or NULL"]
    pub subgraph: *mut spa_graph,
    pub callbacks: spa_callbacks,
    #[doc = "< link for scheduler"]
    pub sched_link: spa_list,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_graph_node"][::std::mem::size_of::<spa_graph_node>() - 168usize];
    ["Alignment of spa_graph_node"][::std::mem::align_of::<spa_graph_node>() - 8usize];
    ["Offset of field: spa_graph_node::link"]
        [::std::mem::offset_of!(spa_graph_node, link) - 0usize];
    ["Offset of field: spa_graph_node::graph"]
        [::std::mem::offset_of!(spa_graph_node, graph) - 16usize];
    ["Offset of field: spa_graph_node::ports"]
        [::std::mem::offset_of!(spa_graph_node, ports) - 24usize];
    ["Offset of field: spa_graph_node::links"]
        [::std::mem::offset_of!(spa_graph_node, links) - 56usize];
    ["Offset of field: spa_graph_node::flags"]
        [::std::mem::offset_of!(spa_graph_node, flags) - 72usize];
    ["Offset of field: spa_graph_node::state"]
        [::std::mem::offset_of!(spa_graph_node, state) - 80usize];
    ["Offset of field: spa_graph_node::graph_link"]
        [::std::mem::offset_of!(spa_graph_node, graph_link) - 88usize];
    ["Offset of field: spa_graph_node::subgraph"]
        [::std::mem::offset_of!(spa_graph_node, subgraph) - 128usize];
    ["Offset of field: spa_graph_node::callbacks"]
        [::std::mem::offset_of!(spa_graph_node, callbacks) - 136usize];
    ["Offset of field: spa_graph_node::sched_link"]
        [::std::mem::offset_of!(spa_graph_node, sched_link) - 152usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_graph_port {
    #[doc = "< link in node port list"]
    pub link: spa_list,
    #[doc = "< owner node"]
    pub node: *mut spa_graph_node,
    #[doc = "< port direction"]
    pub direction: spa_direction,
    #[doc = "< port id"]
    pub port_id: u32,
    #[doc = "< port flags"]
    pub flags: u32,
    #[doc = "< peer"]
    pub peer: *mut spa_graph_port,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_graph_port"][::std::mem::size_of::<spa_graph_port>() - 48usize];
    ["Alignment of spa_graph_port"][::std::mem::align_of::<spa_graph_port>() - 8usize];
    ["Offset of field: spa_graph_port::link"]
        [::std::mem::offset_of!(spa_graph_port, link) - 0usize];
    ["Offset of field: spa_graph_port::node"]
        [::std::mem::offset_of!(spa_graph_port, node) - 16usize];
    ["Offset of field: spa_graph_port::direction"]
        [::std::mem::offset_of!(spa_graph_port, direction) - 24usize];
    ["Offset of field: spa_graph_port::port_id"]
        [::std::mem::offset_of!(spa_graph_port, port_id) - 28usize];
    ["Offset of field: spa_graph_port::flags"]
        [::std::mem::offset_of!(spa_graph_port, flags) - 32usize];
    ["Offset of field: spa_graph_port::peer"]
        [::std::mem::offset_of!(spa_graph_port, peer) - 40usize];
};
unsafe extern "C" {
    pub static spa_graph_node_sub_impl_default: spa_graph_node_callbacks;
}
unsafe extern "C" {
    pub static spa_graph_node_impl_default: spa_graph_node_callbacks;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_pod_builder_state {
    pub offset: u32,
    pub flags: u32,
    pub frame: *mut spa_pod_frame,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_builder_state"][::std::mem::size_of::<spa_pod_builder_state>() - 16usize];
    ["Alignment of spa_pod_builder_state"]
        [::std::mem::align_of::<spa_pod_builder_state>() - 8usize];
    ["Offset of field: spa_pod_builder_state::offset"]
        [::std::mem::offset_of!(spa_pod_builder_state, offset) - 0usize];
    ["Offset of field: spa_pod_builder_state::flags"]
        [::std::mem::offset_of!(spa_pod_builder_state, flags) - 4usize];
    ["Offset of field: spa_pod_builder_state::frame"]
        [::std::mem::offset_of!(spa_pod_builder_state, frame) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_pod_builder_callbacks {
    pub version: u32,
    pub overflow: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, size: u32) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_builder_callbacks"]
        [::std::mem::size_of::<spa_pod_builder_callbacks>() - 16usize];
    ["Alignment of spa_pod_builder_callbacks"]
        [::std::mem::align_of::<spa_pod_builder_callbacks>() - 8usize];
    ["Offset of field: spa_pod_builder_callbacks::version"]
        [::std::mem::offset_of!(spa_pod_builder_callbacks, version) - 0usize];
    ["Offset of field: spa_pod_builder_callbacks::overflow"]
        [::std::mem::offset_of!(spa_pod_builder_callbacks, overflow) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_pod_builder {
    pub data: *mut ::std::os::raw::c_void,
    pub size: u32,
    pub _padding: u32,
    pub state: spa_pod_builder_state,
    pub callbacks: spa_callbacks,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_builder"][::std::mem::size_of::<spa_pod_builder>() - 48usize];
    ["Alignment of spa_pod_builder"][::std::mem::align_of::<spa_pod_builder>() - 8usize];
    ["Offset of field: spa_pod_builder::data"]
        [::std::mem::offset_of!(spa_pod_builder, data) - 0usize];
    ["Offset of field: spa_pod_builder::size"]
        [::std::mem::offset_of!(spa_pod_builder, size) - 8usize];
    ["Offset of field: spa_pod_builder::_padding"]
        [::std::mem::offset_of!(spa_pod_builder, _padding) - 12usize];
    ["Offset of field: spa_pod_builder::state"]
        [::std::mem::offset_of!(spa_pod_builder, state) - 16usize];
    ["Offset of field: spa_pod_builder::callbacks"]
        [::std::mem::offset_of!(spa_pod_builder, callbacks) - 32usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_audio_aec {
    pub iface: spa_interface,
    pub name: *const ::std::os::raw::c_char,
    pub info: *const spa_dict,
    pub latency: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_audio_aec"][::std::mem::size_of::<spa_audio_aec>() - 56usize];
    ["Alignment of spa_audio_aec"][::std::mem::align_of::<spa_audio_aec>() - 8usize];
    ["Offset of field: spa_audio_aec::iface"]
        [::std::mem::offset_of!(spa_audio_aec, iface) - 0usize];
    ["Offset of field: spa_audio_aec::name"][::std::mem::offset_of!(spa_audio_aec, name) - 32usize];
    ["Offset of field: spa_audio_aec::info"][::std::mem::offset_of!(spa_audio_aec, info) - 40usize];
    ["Offset of field: spa_audio_aec::latency"]
        [::std::mem::offset_of!(spa_audio_aec, latency) - 48usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_audio_aec_info {
    pub change_mask: u64,
    pub props: *const spa_dict,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_audio_aec_info"][::std::mem::size_of::<spa_audio_aec_info>() - 16usize];
    ["Alignment of spa_audio_aec_info"][::std::mem::align_of::<spa_audio_aec_info>() - 8usize];
    ["Offset of field: spa_audio_aec_info::change_mask"]
        [::std::mem::offset_of!(spa_audio_aec_info, change_mask) - 0usize];
    ["Offset of field: spa_audio_aec_info::props"]
        [::std::mem::offset_of!(spa_audio_aec_info, props) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_audio_aec_events {
    #[doc = "< version of this structure"]
    pub version: u32,
    #[doc = " Emitted when info changes"]
    pub info: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, info: *const spa_audio_aec_info),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_audio_aec_events"][::std::mem::size_of::<spa_audio_aec_events>() - 16usize];
    ["Alignment of spa_audio_aec_events"][::std::mem::align_of::<spa_audio_aec_events>() - 8usize];
    ["Offset of field: spa_audio_aec_events::version"]
        [::std::mem::offset_of!(spa_audio_aec_events, version) - 0usize];
    ["Offset of field: spa_audio_aec_events::info"]
        [::std::mem::offset_of!(spa_audio_aec_events, info) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_audio_aec_methods {
    pub version: u32,
    pub add_listener: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            listener: *mut spa_hook,
            events: *const spa_audio_aec_events,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub init: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            args: *const spa_dict,
            info: *const spa_audio_info_raw,
        ) -> ::std::os::raw::c_int,
    >,
    pub run: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            rec: *mut *const f32,
            play: *mut *const f32,
            out: *mut *mut f32,
            n_samples: u32,
        ) -> ::std::os::raw::c_int,
    >,
    pub set_props: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            args: *const spa_dict,
        ) -> ::std::os::raw::c_int,
    >,
    pub activate: ::std::option::Option<
        unsafe extern "C" fn(object: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    pub deactivate: ::std::option::Option<
        unsafe extern "C" fn(object: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    pub enum_props: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            index: ::std::os::raw::c_int,
            builder: *mut spa_pod_builder,
        ) -> ::std::os::raw::c_int,
    >,
    pub get_params: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            builder: *mut spa_pod_builder,
        ) -> ::std::os::raw::c_int,
    >,
    pub set_params: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            args: *const spa_pod,
        ) -> ::std::os::raw::c_int,
    >,
    pub init2: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            args: *const spa_dict,
            play_info: *mut spa_audio_info_raw,
            rec_info: *mut spa_audio_info_raw,
            out_info: *mut spa_audio_info_raw,
        ) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_audio_aec_methods"][::std::mem::size_of::<spa_audio_aec_methods>() - 88usize];
    ["Alignment of spa_audio_aec_methods"]
        [::std::mem::align_of::<spa_audio_aec_methods>() - 8usize];
    ["Offset of field: spa_audio_aec_methods::version"]
        [::std::mem::offset_of!(spa_audio_aec_methods, version) - 0usize];
    ["Offset of field: spa_audio_aec_methods::add_listener"]
        [::std::mem::offset_of!(spa_audio_aec_methods, add_listener) - 8usize];
    ["Offset of field: spa_audio_aec_methods::init"]
        [::std::mem::offset_of!(spa_audio_aec_methods, init) - 16usize];
    ["Offset of field: spa_audio_aec_methods::run"]
        [::std::mem::offset_of!(spa_audio_aec_methods, run) - 24usize];
    ["Offset of field: spa_audio_aec_methods::set_props"]
        [::std::mem::offset_of!(spa_audio_aec_methods, set_props) - 32usize];
    ["Offset of field: spa_audio_aec_methods::activate"]
        [::std::mem::offset_of!(spa_audio_aec_methods, activate) - 40usize];
    ["Offset of field: spa_audio_aec_methods::deactivate"]
        [::std::mem::offset_of!(spa_audio_aec_methods, deactivate) - 48usize];
    ["Offset of field: spa_audio_aec_methods::enum_props"]
        [::std::mem::offset_of!(spa_audio_aec_methods, enum_props) - 56usize];
    ["Offset of field: spa_audio_aec_methods::get_params"]
        [::std::mem::offset_of!(spa_audio_aec_methods, get_params) - 64usize];
    ["Offset of field: spa_audio_aec_methods::set_params"]
        [::std::mem::offset_of!(spa_audio_aec_methods, set_params) - 72usize];
    ["Offset of field: spa_audio_aec_methods::init2"]
        [::std::mem::offset_of!(spa_audio_aec_methods, init2) - 80usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_device {
    pub iface: spa_interface,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_device"][::std::mem::size_of::<spa_device>() - 32usize];
    ["Alignment of spa_device"][::std::mem::align_of::<spa_device>() - 8usize];
    ["Offset of field: spa_device::iface"][::std::mem::offset_of!(spa_device, iface) - 0usize];
};
#[doc = " Information about the device and parameters it supports\n\n This information is part of the info event on a device."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_device_info {
    pub version: u32,
    pub change_mask: u64,
    pub flags: u64,
    #[doc = "< device properties"]
    pub props: *const spa_dict,
    #[doc = "< supported parameters"]
    pub params: *mut spa_param_info,
    #[doc = "< number of elements in params"]
    pub n_params: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_device_info"][::std::mem::size_of::<spa_device_info>() - 48usize];
    ["Alignment of spa_device_info"][::std::mem::align_of::<spa_device_info>() - 8usize];
    ["Offset of field: spa_device_info::version"]
        [::std::mem::offset_of!(spa_device_info, version) - 0usize];
    ["Offset of field: spa_device_info::change_mask"]
        [::std::mem::offset_of!(spa_device_info, change_mask) - 8usize];
    ["Offset of field: spa_device_info::flags"]
        [::std::mem::offset_of!(spa_device_info, flags) - 16usize];
    ["Offset of field: spa_device_info::props"]
        [::std::mem::offset_of!(spa_device_info, props) - 24usize];
    ["Offset of field: spa_device_info::params"]
        [::std::mem::offset_of!(spa_device_info, params) - 32usize];
    ["Offset of field: spa_device_info::n_params"]
        [::std::mem::offset_of!(spa_device_info, n_params) - 40usize];
};
#[doc = " Information about a device object\n\n This information is part of the object_info event on the device."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_device_object_info {
    pub version: u32,
    #[doc = "< the object type managed by this device"]
    pub type_: *const ::std::os::raw::c_char,
    #[doc = "< a factory name that implements the object"]
    pub factory_name: *const ::std::os::raw::c_char,
    pub change_mask: u64,
    pub flags: u64,
    #[doc = "< extra object properties"]
    pub props: *const spa_dict,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_device_object_info"][::std::mem::size_of::<spa_device_object_info>() - 48usize];
    ["Alignment of spa_device_object_info"]
        [::std::mem::align_of::<spa_device_object_info>() - 8usize];
    ["Offset of field: spa_device_object_info::version"]
        [::std::mem::offset_of!(spa_device_object_info, version) - 0usize];
    ["Offset of field: spa_device_object_info::type_"]
        [::std::mem::offset_of!(spa_device_object_info, type_) - 8usize];
    ["Offset of field: spa_device_object_info::factory_name"]
        [::std::mem::offset_of!(spa_device_object_info, factory_name) - 16usize];
    ["Offset of field: spa_device_object_info::change_mask"]
        [::std::mem::offset_of!(spa_device_object_info, change_mask) - 24usize];
    ["Offset of field: spa_device_object_info::flags"]
        [::std::mem::offset_of!(spa_device_object_info, flags) - 32usize];
    ["Offset of field: spa_device_object_info::props"]
        [::std::mem::offset_of!(spa_device_object_info, props) - 40usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_result_device_params {
    pub id: u32,
    pub index: u32,
    pub next: u32,
    pub param: *mut spa_pod,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_result_device_params"]
        [::std::mem::size_of::<spa_result_device_params>() - 24usize];
    ["Alignment of spa_result_device_params"]
        [::std::mem::align_of::<spa_result_device_params>() - 8usize];
    ["Offset of field: spa_result_device_params::id"]
        [::std::mem::offset_of!(spa_result_device_params, id) - 0usize];
    ["Offset of field: spa_result_device_params::index"]
        [::std::mem::offset_of!(spa_result_device_params, index) - 4usize];
    ["Offset of field: spa_result_device_params::next"]
        [::std::mem::offset_of!(spa_result_device_params, next) - 8usize];
    ["Offset of field: spa_result_device_params::param"]
        [::std::mem::offset_of!(spa_result_device_params, param) - 16usize];
};
#[doc = " spa_device_events:\n\n Events are always emitted from the main thread"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_device_events {
    pub version: u32,
    #[doc = " notify extra information about the device"]
    pub info: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, info: *const spa_device_info),
    >,
    #[doc = " notify a result"]
    pub result: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            seq: ::std::os::raw::c_int,
            res: ::std::os::raw::c_int,
            type_: u32,
            result: *const ::std::os::raw::c_void,
        ),
    >,
    #[doc = " a device event"]
    pub event: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, event: *const spa_event),
    >,
    #[doc = " info changed for an object managed by the device, info is NULL when\n the object is removed"]
    pub object_info: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            id: u32,
            info: *const spa_device_object_info,
        ),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_device_events"][::std::mem::size_of::<spa_device_events>() - 40usize];
    ["Alignment of spa_device_events"][::std::mem::align_of::<spa_device_events>() - 8usize];
    ["Offset of field: spa_device_events::version"]
        [::std::mem::offset_of!(spa_device_events, version) - 0usize];
    ["Offset of field: spa_device_events::info"]
        [::std::mem::offset_of!(spa_device_events, info) - 8usize];
    ["Offset of field: spa_device_events::result"]
        [::std::mem::offset_of!(spa_device_events, result) - 16usize];
    ["Offset of field: spa_device_events::event"]
        [::std::mem::offset_of!(spa_device_events, event) - 24usize];
    ["Offset of field: spa_device_events::object_info"]
        [::std::mem::offset_of!(spa_device_events, object_info) - 32usize];
};
#[doc = " spa_device_methods:"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_device_methods {
    pub version: u32,
    #[doc = " Set events to receive asynchronous notifications from\n the device.\n\n Setting the events will trigger the info event and an\n object_info event for each managed object on the new\n listener.\n\n \\param object a \\ref spa_device\n \\param listener a listener\n \\param events a struct \\ref spa_device_events\n \\param data data passed as first argument in functions of \\a events\n \\return 0 on success\n\t   < 0 errno on error"]
    pub add_listener: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            listener: *mut spa_hook,
            events: *const spa_device_events,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Perform a sync operation.\n\n This method will emit the result event with the given sequence\n number synchronously or with the returned async return value\n asynchronously.\n\n Because all methods are serialized in the device, this can be used\n to wait for completion of all previous method calls.\n\n \\param seq a sequence number\n \\return 0 on success\n         -EINVAL when node is NULL\n         an async result"]
    pub sync: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            seq: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Enumerate the parameters of a device.\n\n Parameters are identified with an \\a id. Some parameters can have\n multiple values, see the documentation of the parameter id.\n\n Parameters can be filtered by passing a non-NULL \\a filter.\n\n The result callback will be called at most \\a max times with a\n struct spa_result_device_params as the result.\n\n This function must be called from the main thread.\n\n \\param device a \\ref spa_device\n \\param seq a sequence number to pass to the result function\n \\param id the param id to enumerate\n \\param index the index of enumeration, pass 0 for the first item.\n \\param max the maximum number of items to iterate\n \\param filter and optional filter to use\n \\return 0 when there are no more parameters to enumerate\n         -EINVAL when invalid arguments are given\n         -ENOENT the parameter \\a id is unknown\n         -ENOTSUP when there are no parameters\n                 implemented on \\a device"]
    pub enum_params: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            seq: ::std::os::raw::c_int,
            id: u32,
            index: u32,
            max: u32,
            filter: *const spa_pod,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Set the configurable parameter in \\a device.\n\n Usually, \\a param will be obtained from enum_params and then\n modified but it is also possible to set another spa_pod\n as long as its keys and types match a supported object.\n\n Objects with property keys that are not known are ignored.\n\n This function must be called from the main thread.\n\n \\param object \\ref spa_device\n \\param id the parameter id to configure\n \\param flags additional flags\n \\param param the parameter to configure\n\n \\return 0 on success\n         -EINVAL when invalid arguments are given\n         -ENOTSUP when there are no parameters implemented on \\a device\n         -ENOENT the parameter is unknown"]
    pub set_param: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            id: u32,
            flags: u32,
            param: *const spa_pod,
        ) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_device_methods"][::std::mem::size_of::<spa_device_methods>() - 40usize];
    ["Alignment of spa_device_methods"][::std::mem::align_of::<spa_device_methods>() - 8usize];
    ["Offset of field: spa_device_methods::version"]
        [::std::mem::offset_of!(spa_device_methods, version) - 0usize];
    ["Offset of field: spa_device_methods::add_listener"]
        [::std::mem::offset_of!(spa_device_methods, add_listener) - 8usize];
    ["Offset of field: spa_device_methods::sync"]
        [::std::mem::offset_of!(spa_device_methods, sync) - 16usize];
    ["Offset of field: spa_device_methods::enum_params"]
        [::std::mem::offset_of!(spa_device_methods, enum_params) - 24usize];
    ["Offset of field: spa_device_methods::set_param"]
        [::std::mem::offset_of!(spa_device_methods, set_param) - 32usize];
};
#[doc = " \\addtogroup spa_device\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_result_device_params_data {
    pub builder: *mut spa_pod_builder,
    pub data: spa_result_device_params,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_result_device_params_data"]
        [::std::mem::size_of::<spa_result_device_params_data>() - 32usize];
    ["Alignment of spa_result_device_params_data"]
        [::std::mem::align_of::<spa_result_device_params_data>() - 8usize];
    ["Offset of field: spa_result_device_params_data::builder"]
        [::std::mem::offset_of!(spa_result_device_params_data, builder) - 0usize];
    ["Offset of field: spa_result_device_params_data::data"]
        [::std::mem::offset_of!(spa_result_device_params_data, data) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_result_node_params_data {
    pub builder: *mut spa_pod_builder,
    pub data: spa_result_node_params,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_result_node_params_data"]
        [::std::mem::size_of::<spa_result_node_params_data>() - 32usize];
    ["Alignment of spa_result_node_params_data"]
        [::std::mem::align_of::<spa_result_node_params_data>() - 8usize];
    ["Offset of field: spa_result_node_params_data::builder"]
        [::std::mem::offset_of!(spa_result_node_params_data, builder) - 0usize];
    ["Offset of field: spa_result_node_params_data::data"]
        [::std::mem::offset_of!(spa_result_node_params_data, data) - 8usize];
};
#[doc = " \\addtogroup spa_param\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_audio_info_dsp {
    pub format: spa_audio_format,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_audio_info_dsp"][::std::mem::size_of::<spa_audio_info_dsp>() - 4usize];
    ["Alignment of spa_audio_info_dsp"][::std::mem::align_of::<spa_audio_info_dsp>() - 4usize];
    ["Offset of field: spa_audio_info_dsp::format"]
        [::std::mem::offset_of!(spa_audio_info_dsp, format) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_audio_info_dsd {
    pub bitorder: spa_param_bitorder,
    pub flags: u32,
    pub interleave: i32,
    pub rate: u32,
    pub channels: u32,
    pub position: [u32; 64usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_audio_info_dsd"][::std::mem::size_of::<spa_audio_info_dsd>() - 276usize];
    ["Alignment of spa_audio_info_dsd"][::std::mem::align_of::<spa_audio_info_dsd>() - 4usize];
    ["Offset of field: spa_audio_info_dsd::bitorder"]
        [::std::mem::offset_of!(spa_audio_info_dsd, bitorder) - 0usize];
    ["Offset of field: spa_audio_info_dsd::flags"]
        [::std::mem::offset_of!(spa_audio_info_dsd, flags) - 4usize];
    ["Offset of field: spa_audio_info_dsd::interleave"]
        [::std::mem::offset_of!(spa_audio_info_dsd, interleave) - 8usize];
    ["Offset of field: spa_audio_info_dsd::rate"]
        [::std::mem::offset_of!(spa_audio_info_dsd, rate) - 12usize];
    ["Offset of field: spa_audio_info_dsd::channels"]
        [::std::mem::offset_of!(spa_audio_info_dsd, channels) - 16usize];
    ["Offset of field: spa_audio_info_dsd::position"]
        [::std::mem::offset_of!(spa_audio_info_dsd, position) - 20usize];
};
#[doc = " \\addtogroup spa_param\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_audio_info_vorbis {
    pub rate: u32,
    pub channels: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_audio_info_vorbis"][::std::mem::size_of::<spa_audio_info_vorbis>() - 8usize];
    ["Alignment of spa_audio_info_vorbis"]
        [::std::mem::align_of::<spa_audio_info_vorbis>() - 4usize];
    ["Offset of field: spa_audio_info_vorbis::rate"]
        [::std::mem::offset_of!(spa_audio_info_vorbis, rate) - 0usize];
    ["Offset of field: spa_audio_info_vorbis::channels"]
        [::std::mem::offset_of!(spa_audio_info_vorbis, channels) - 4usize];
};
#[doc = " \\addtogroup spa_param\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_audio_info_ra {
    pub rate: u32,
    pub channels: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_audio_info_ra"][::std::mem::size_of::<spa_audio_info_ra>() - 8usize];
    ["Alignment of spa_audio_info_ra"][::std::mem::align_of::<spa_audio_info_ra>() - 4usize];
    ["Offset of field: spa_audio_info_ra::rate"]
        [::std::mem::offset_of!(spa_audio_info_ra, rate) - 0usize];
    ["Offset of field: spa_audio_info_ra::channels"]
        [::std::mem::offset_of!(spa_audio_info_ra, channels) - 4usize];
};
#[doc = " \\addtogroup spa_param\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_audio_info_alac {
    pub rate: u32,
    pub channels: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_audio_info_alac"][::std::mem::size_of::<spa_audio_info_alac>() - 8usize];
    ["Alignment of spa_audio_info_alac"][::std::mem::align_of::<spa_audio_info_alac>() - 4usize];
    ["Offset of field: spa_audio_info_alac::rate"]
        [::std::mem::offset_of!(spa_audio_info_alac, rate) - 0usize];
    ["Offset of field: spa_audio_info_alac::channels"]
        [::std::mem::offset_of!(spa_audio_info_alac, channels) - 4usize];
};
#[doc = " \\addtogroup spa_param\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_audio_info_flac {
    pub rate: u32,
    pub channels: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_audio_info_flac"][::std::mem::size_of::<spa_audio_info_flac>() - 8usize];
    ["Alignment of spa_audio_info_flac"][::std::mem::align_of::<spa_audio_info_flac>() - 4usize];
    ["Offset of field: spa_audio_info_flac::rate"]
        [::std::mem::offset_of!(spa_audio_info_flac, rate) - 0usize];
    ["Offset of field: spa_audio_info_flac::channels"]
        [::std::mem::offset_of!(spa_audio_info_flac, channels) - 4usize];
};
#[doc = " \\addtogroup spa_param\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_audio_info_ape {
    pub rate: u32,
    pub channels: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_audio_info_ape"][::std::mem::size_of::<spa_audio_info_ape>() - 8usize];
    ["Alignment of spa_audio_info_ape"][::std::mem::align_of::<spa_audio_info_ape>() - 4usize];
    ["Offset of field: spa_audio_info_ape::rate"]
        [::std::mem::offset_of!(spa_audio_info_ape, rate) - 0usize];
    ["Offset of field: spa_audio_info_ape::channels"]
        [::std::mem::offset_of!(spa_audio_info_ape, channels) - 4usize];
};
#[doc = " \\addtogroup spa_param\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_audio_info_opus {
    pub rate: u32,
    pub channels: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_audio_info_opus"][::std::mem::size_of::<spa_audio_info_opus>() - 8usize];
    ["Alignment of spa_audio_info_opus"][::std::mem::align_of::<spa_audio_info_opus>() - 4usize];
    ["Offset of field: spa_audio_info_opus::rate"]
        [::std::mem::offset_of!(spa_audio_info_opus, rate) - 0usize];
    ["Offset of field: spa_audio_info_opus::channels"]
        [::std::mem::offset_of!(spa_audio_info_opus, channels) - 4usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct spa_audio_info {
    pub media_type: u32,
    pub media_subtype: u32,
    pub info: spa_audio_info__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spa_audio_info__bindgen_ty_1 {
    pub raw: spa_audio_info_raw,
    pub dsp: spa_audio_info_dsp,
    pub iec958: spa_audio_info_iec958,
    pub dsd: spa_audio_info_dsd,
    pub mp3: spa_audio_info_mp3,
    pub aac: spa_audio_info_aac,
    pub vorbis: spa_audio_info_vorbis,
    pub wma: spa_audio_info_wma,
    pub ra: spa_audio_info_ra,
    pub amr: spa_audio_info_amr,
    pub alac: spa_audio_info_alac,
    pub flac: spa_audio_info_flac,
    pub ape: spa_audio_info_ape,
    pub opus: spa_audio_info_ape,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_audio_info__bindgen_ty_1"]
        [::std::mem::size_of::<spa_audio_info__bindgen_ty_1>() - 276usize];
    ["Alignment of spa_audio_info__bindgen_ty_1"]
        [::std::mem::align_of::<spa_audio_info__bindgen_ty_1>() - 4usize];
    ["Offset of field: spa_audio_info__bindgen_ty_1::raw"]
        [::std::mem::offset_of!(spa_audio_info__bindgen_ty_1, raw) - 0usize];
    ["Offset of field: spa_audio_info__bindgen_ty_1::dsp"]
        [::std::mem::offset_of!(spa_audio_info__bindgen_ty_1, dsp) - 0usize];
    ["Offset of field: spa_audio_info__bindgen_ty_1::iec958"]
        [::std::mem::offset_of!(spa_audio_info__bindgen_ty_1, iec958) - 0usize];
    ["Offset of field: spa_audio_info__bindgen_ty_1::dsd"]
        [::std::mem::offset_of!(spa_audio_info__bindgen_ty_1, dsd) - 0usize];
    ["Offset of field: spa_audio_info__bindgen_ty_1::mp3"]
        [::std::mem::offset_of!(spa_audio_info__bindgen_ty_1, mp3) - 0usize];
    ["Offset of field: spa_audio_info__bindgen_ty_1::aac"]
        [::std::mem::offset_of!(spa_audio_info__bindgen_ty_1, aac) - 0usize];
    ["Offset of field: spa_audio_info__bindgen_ty_1::vorbis"]
        [::std::mem::offset_of!(spa_audio_info__bindgen_ty_1, vorbis) - 0usize];
    ["Offset of field: spa_audio_info__bindgen_ty_1::wma"]
        [::std::mem::offset_of!(spa_audio_info__bindgen_ty_1, wma) - 0usize];
    ["Offset of field: spa_audio_info__bindgen_ty_1::ra"]
        [::std::mem::offset_of!(spa_audio_info__bindgen_ty_1, ra) - 0usize];
    ["Offset of field: spa_audio_info__bindgen_ty_1::amr"]
        [::std::mem::offset_of!(spa_audio_info__bindgen_ty_1, amr) - 0usize];
    ["Offset of field: spa_audio_info__bindgen_ty_1::alac"]
        [::std::mem::offset_of!(spa_audio_info__bindgen_ty_1, alac) - 0usize];
    ["Offset of field: spa_audio_info__bindgen_ty_1::flac"]
        [::std::mem::offset_of!(spa_audio_info__bindgen_ty_1, flac) - 0usize];
    ["Offset of field: spa_audio_info__bindgen_ty_1::ape"]
        [::std::mem::offset_of!(spa_audio_info__bindgen_ty_1, ape) - 0usize];
    ["Offset of field: spa_audio_info__bindgen_ty_1::opus"]
        [::std::mem::offset_of!(spa_audio_info__bindgen_ty_1, opus) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_audio_info"][::std::mem::size_of::<spa_audio_info>() - 284usize];
    ["Alignment of spa_audio_info"][::std::mem::align_of::<spa_audio_info>() - 4usize];
    ["Offset of field: spa_audio_info::media_type"]
        [::std::mem::offset_of!(spa_audio_info, media_type) - 0usize];
    ["Offset of field: spa_audio_info::media_subtype"]
        [::std::mem::offset_of!(spa_audio_info, media_subtype) - 4usize];
    ["Offset of field: spa_audio_info::info"]
        [::std::mem::offset_of!(spa_audio_info, info) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_audio_layout_info {
    pub n_channels: u32,
    pub position: [u32; 64usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_audio_layout_info"][::std::mem::size_of::<spa_audio_layout_info>() - 260usize];
    ["Alignment of spa_audio_layout_info"]
        [::std::mem::align_of::<spa_audio_layout_info>() - 4usize];
    ["Offset of field: spa_audio_layout_info::n_channels"]
        [::std::mem::offset_of!(spa_audio_layout_info, n_channels) - 0usize];
    ["Offset of field: spa_audio_layout_info::position"]
        [::std::mem::offset_of!(spa_audio_layout_info, position) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_video_info_dsp {
    pub format: spa_video_format,
    pub flags: u32,
    pub modifier: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_video_info_dsp"][::std::mem::size_of::<spa_video_info_dsp>() - 16usize];
    ["Alignment of spa_video_info_dsp"][::std::mem::align_of::<spa_video_info_dsp>() - 8usize];
    ["Offset of field: spa_video_info_dsp::format"]
        [::std::mem::offset_of!(spa_video_info_dsp, format) - 0usize];
    ["Offset of field: spa_video_info_dsp::flags"]
        [::std::mem::offset_of!(spa_video_info_dsp, flags) - 4usize];
    ["Offset of field: spa_video_info_dsp::modifier"]
        [::std::mem::offset_of!(spa_video_info_dsp, modifier) - 8usize];
};
pub const spa_h264_stream_format_SPA_H264_STREAM_FORMAT_UNKNOWN: spa_h264_stream_format = 0;
pub const spa_h264_stream_format_SPA_H264_STREAM_FORMAT_AVC: spa_h264_stream_format = 1;
pub const spa_h264_stream_format_SPA_H264_STREAM_FORMAT_AVC3: spa_h264_stream_format = 2;
pub const spa_h264_stream_format_SPA_H264_STREAM_FORMAT_BYTESTREAM: spa_h264_stream_format = 3;
pub type spa_h264_stream_format = ::std::os::raw::c_uint;
pub const spa_h264_alignment_SPA_H264_ALIGNMENT_UNKNOWN: spa_h264_alignment = 0;
pub const spa_h264_alignment_SPA_H264_ALIGNMENT_AU: spa_h264_alignment = 1;
pub const spa_h264_alignment_SPA_H264_ALIGNMENT_NAL: spa_h264_alignment = 2;
pub type spa_h264_alignment = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_video_info_h264 {
    pub size: spa_rectangle,
    pub framerate: spa_fraction,
    pub max_framerate: spa_fraction,
    pub stream_format: spa_h264_stream_format,
    pub alignment: spa_h264_alignment,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_video_info_h264"][::std::mem::size_of::<spa_video_info_h264>() - 32usize];
    ["Alignment of spa_video_info_h264"][::std::mem::align_of::<spa_video_info_h264>() - 4usize];
    ["Offset of field: spa_video_info_h264::size"]
        [::std::mem::offset_of!(spa_video_info_h264, size) - 0usize];
    ["Offset of field: spa_video_info_h264::framerate"]
        [::std::mem::offset_of!(spa_video_info_h264, framerate) - 8usize];
    ["Offset of field: spa_video_info_h264::max_framerate"]
        [::std::mem::offset_of!(spa_video_info_h264, max_framerate) - 16usize];
    ["Offset of field: spa_video_info_h264::stream_format"]
        [::std::mem::offset_of!(spa_video_info_h264, stream_format) - 24usize];
    ["Offset of field: spa_video_info_h264::alignment"]
        [::std::mem::offset_of!(spa_video_info_h264, alignment) - 28usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_video_info_mjpg {
    pub size: spa_rectangle,
    pub framerate: spa_fraction,
    pub max_framerate: spa_fraction,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_video_info_mjpg"][::std::mem::size_of::<spa_video_info_mjpg>() - 24usize];
    ["Alignment of spa_video_info_mjpg"][::std::mem::align_of::<spa_video_info_mjpg>() - 4usize];
    ["Offset of field: spa_video_info_mjpg::size"]
        [::std::mem::offset_of!(spa_video_info_mjpg, size) - 0usize];
    ["Offset of field: spa_video_info_mjpg::framerate"]
        [::std::mem::offset_of!(spa_video_info_mjpg, framerate) - 8usize];
    ["Offset of field: spa_video_info_mjpg::max_framerate"]
        [::std::mem::offset_of!(spa_video_info_mjpg, max_framerate) - 16usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct spa_video_info {
    pub media_type: u32,
    pub media_subtype: u32,
    pub info: spa_video_info__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spa_video_info__bindgen_ty_1 {
    pub raw: spa_video_info_raw,
    pub dsp: spa_video_info_dsp,
    pub h264: spa_video_info_h264,
    pub mjpg: spa_video_info_mjpg,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_video_info__bindgen_ty_1"]
        [::std::mem::size_of::<spa_video_info__bindgen_ty_1>() - 88usize];
    ["Alignment of spa_video_info__bindgen_ty_1"]
        [::std::mem::align_of::<spa_video_info__bindgen_ty_1>() - 8usize];
    ["Offset of field: spa_video_info__bindgen_ty_1::raw"]
        [::std::mem::offset_of!(spa_video_info__bindgen_ty_1, raw) - 0usize];
    ["Offset of field: spa_video_info__bindgen_ty_1::dsp"]
        [::std::mem::offset_of!(spa_video_info__bindgen_ty_1, dsp) - 0usize];
    ["Offset of field: spa_video_info__bindgen_ty_1::h264"]
        [::std::mem::offset_of!(spa_video_info__bindgen_ty_1, h264) - 0usize];
    ["Offset of field: spa_video_info__bindgen_ty_1::mjpg"]
        [::std::mem::offset_of!(spa_video_info__bindgen_ty_1, mjpg) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_video_info"][::std::mem::size_of::<spa_video_info>() - 96usize];
    ["Alignment of spa_video_info"][::std::mem::align_of::<spa_video_info>() - 8usize];
    ["Offset of field: spa_video_info::media_type"]
        [::std::mem::offset_of!(spa_video_info, media_type) - 0usize];
    ["Offset of field: spa_video_info::media_subtype"]
        [::std::mem::offset_of!(spa_video_info, media_subtype) - 4usize];
    ["Offset of field: spa_video_info::info"]
        [::std::mem::offset_of!(spa_video_info, info) - 8usize];
};
pub type useconds_t = __useconds_t;
pub type socklen_t = __socklen_t;
unsafe extern "C" {
    pub fn access(
        __name: *const ::std::os::raw::c_char,
        __type: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faccessat(
        __fd: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __type: ::std::os::raw::c_int,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn lseek(
        __fd: ::std::os::raw::c_int,
        __offset: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> __off_t;
}
unsafe extern "C" {
    pub fn close(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn closefrom(__lowfd: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn read(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __nbytes: usize,
    ) -> isize;
}
unsafe extern "C" {
    pub fn write(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> isize;
}
unsafe extern "C" {
    pub fn pread(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __nbytes: usize,
        __offset: __off_t,
    ) -> isize;
}
unsafe extern "C" {
    pub fn pwrite(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __n: usize,
        __offset: __off_t,
    ) -> isize;
}
unsafe extern "C" {
    pub fn pipe(__pipedes: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn alarm(__seconds: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub fn sleep(__seconds: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub fn ualarm(__value: __useconds_t, __interval: __useconds_t) -> __useconds_t;
}
unsafe extern "C" {
    pub fn usleep(__useconds: __useconds_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pause() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn chown(
        __file: *const ::std::os::raw::c_char,
        __owner: __uid_t,
        __group: __gid_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fchown(
        __fd: ::std::os::raw::c_int,
        __owner: __uid_t,
        __group: __gid_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn lchown(
        __file: *const ::std::os::raw::c_char,
        __owner: __uid_t,
        __group: __gid_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fchownat(
        __fd: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __owner: __uid_t,
        __group: __gid_t,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn chdir(__path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fchdir(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getcwd(__buf: *mut ::std::os::raw::c_char, __size: usize)
        -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn getwd(__buf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn dup(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn dup2(__fd: ::std::os::raw::c_int, __fd2: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub static mut __environ: *mut *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn execve(
        __path: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
        __envp: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fexecve(
        __fd: ::std::os::raw::c_int,
        __argv: *const *mut ::std::os::raw::c_char,
        __envp: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn execv(
        __path: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn execle(
        __path: *const ::std::os::raw::c_char,
        __arg: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn execl(
        __path: *const ::std::os::raw::c_char,
        __arg: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn execvp(
        __file: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn execlp(
        __file: *const ::std::os::raw::c_char,
        __arg: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn nice(__inc: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _exit(__status: ::std::os::raw::c_int) -> !;
}
pub const _PC_LINK_MAX: _bindgen_ty_12 = 0;
pub const _PC_MAX_CANON: _bindgen_ty_12 = 1;
pub const _PC_MAX_INPUT: _bindgen_ty_12 = 2;
pub const _PC_NAME_MAX: _bindgen_ty_12 = 3;
pub const _PC_PATH_MAX: _bindgen_ty_12 = 4;
pub const _PC_PIPE_BUF: _bindgen_ty_12 = 5;
pub const _PC_CHOWN_RESTRICTED: _bindgen_ty_12 = 6;
pub const _PC_NO_TRUNC: _bindgen_ty_12 = 7;
pub const _PC_VDISABLE: _bindgen_ty_12 = 8;
pub const _PC_SYNC_IO: _bindgen_ty_12 = 9;
pub const _PC_ASYNC_IO: _bindgen_ty_12 = 10;
pub const _PC_PRIO_IO: _bindgen_ty_12 = 11;
pub const _PC_SOCK_MAXBUF: _bindgen_ty_12 = 12;
pub const _PC_FILESIZEBITS: _bindgen_ty_12 = 13;
pub const _PC_REC_INCR_XFER_SIZE: _bindgen_ty_12 = 14;
pub const _PC_REC_MAX_XFER_SIZE: _bindgen_ty_12 = 15;
pub const _PC_REC_MIN_XFER_SIZE: _bindgen_ty_12 = 16;
pub const _PC_REC_XFER_ALIGN: _bindgen_ty_12 = 17;
pub const _PC_ALLOC_SIZE_MIN: _bindgen_ty_12 = 18;
pub const _PC_SYMLINK_MAX: _bindgen_ty_12 = 19;
pub const _PC_2_SYMLINKS: _bindgen_ty_12 = 20;
pub type _bindgen_ty_12 = ::std::os::raw::c_uint;
pub const _SC_ARG_MAX: _bindgen_ty_13 = 0;
pub const _SC_CHILD_MAX: _bindgen_ty_13 = 1;
pub const _SC_CLK_TCK: _bindgen_ty_13 = 2;
pub const _SC_NGROUPS_MAX: _bindgen_ty_13 = 3;
pub const _SC_OPEN_MAX: _bindgen_ty_13 = 4;
pub const _SC_STREAM_MAX: _bindgen_ty_13 = 5;
pub const _SC_TZNAME_MAX: _bindgen_ty_13 = 6;
pub const _SC_JOB_CONTROL: _bindgen_ty_13 = 7;
pub const _SC_SAVED_IDS: _bindgen_ty_13 = 8;
pub const _SC_REALTIME_SIGNALS: _bindgen_ty_13 = 9;
pub const _SC_PRIORITY_SCHEDULING: _bindgen_ty_13 = 10;
pub const _SC_TIMERS: _bindgen_ty_13 = 11;
pub const _SC_ASYNCHRONOUS_IO: _bindgen_ty_13 = 12;
pub const _SC_PRIORITIZED_IO: _bindgen_ty_13 = 13;
pub const _SC_SYNCHRONIZED_IO: _bindgen_ty_13 = 14;
pub const _SC_FSYNC: _bindgen_ty_13 = 15;
pub const _SC_MAPPED_FILES: _bindgen_ty_13 = 16;
pub const _SC_MEMLOCK: _bindgen_ty_13 = 17;
pub const _SC_MEMLOCK_RANGE: _bindgen_ty_13 = 18;
pub const _SC_MEMORY_PROTECTION: _bindgen_ty_13 = 19;
pub const _SC_MESSAGE_PASSING: _bindgen_ty_13 = 20;
pub const _SC_SEMAPHORES: _bindgen_ty_13 = 21;
pub const _SC_SHARED_MEMORY_OBJECTS: _bindgen_ty_13 = 22;
pub const _SC_AIO_LISTIO_MAX: _bindgen_ty_13 = 23;
pub const _SC_AIO_MAX: _bindgen_ty_13 = 24;
pub const _SC_AIO_PRIO_DELTA_MAX: _bindgen_ty_13 = 25;
pub const _SC_DELAYTIMER_MAX: _bindgen_ty_13 = 26;
pub const _SC_MQ_OPEN_MAX: _bindgen_ty_13 = 27;
pub const _SC_MQ_PRIO_MAX: _bindgen_ty_13 = 28;
pub const _SC_VERSION: _bindgen_ty_13 = 29;
pub const _SC_PAGESIZE: _bindgen_ty_13 = 30;
pub const _SC_RTSIG_MAX: _bindgen_ty_13 = 31;
pub const _SC_SEM_NSEMS_MAX: _bindgen_ty_13 = 32;
pub const _SC_SEM_VALUE_MAX: _bindgen_ty_13 = 33;
pub const _SC_SIGQUEUE_MAX: _bindgen_ty_13 = 34;
pub const _SC_TIMER_MAX: _bindgen_ty_13 = 35;
pub const _SC_BC_BASE_MAX: _bindgen_ty_13 = 36;
pub const _SC_BC_DIM_MAX: _bindgen_ty_13 = 37;
pub const _SC_BC_SCALE_MAX: _bindgen_ty_13 = 38;
pub const _SC_BC_STRING_MAX: _bindgen_ty_13 = 39;
pub const _SC_COLL_WEIGHTS_MAX: _bindgen_ty_13 = 40;
pub const _SC_EQUIV_CLASS_MAX: _bindgen_ty_13 = 41;
pub const _SC_EXPR_NEST_MAX: _bindgen_ty_13 = 42;
pub const _SC_LINE_MAX: _bindgen_ty_13 = 43;
pub const _SC_RE_DUP_MAX: _bindgen_ty_13 = 44;
pub const _SC_CHARCLASS_NAME_MAX: _bindgen_ty_13 = 45;
pub const _SC_2_VERSION: _bindgen_ty_13 = 46;
pub const _SC_2_C_BIND: _bindgen_ty_13 = 47;
pub const _SC_2_C_DEV: _bindgen_ty_13 = 48;
pub const _SC_2_FORT_DEV: _bindgen_ty_13 = 49;
pub const _SC_2_FORT_RUN: _bindgen_ty_13 = 50;
pub const _SC_2_SW_DEV: _bindgen_ty_13 = 51;
pub const _SC_2_LOCALEDEF: _bindgen_ty_13 = 52;
pub const _SC_PII: _bindgen_ty_13 = 53;
pub const _SC_PII_XTI: _bindgen_ty_13 = 54;
pub const _SC_PII_SOCKET: _bindgen_ty_13 = 55;
pub const _SC_PII_INTERNET: _bindgen_ty_13 = 56;
pub const _SC_PII_OSI: _bindgen_ty_13 = 57;
pub const _SC_POLL: _bindgen_ty_13 = 58;
pub const _SC_SELECT: _bindgen_ty_13 = 59;
pub const _SC_UIO_MAXIOV: _bindgen_ty_13 = 60;
pub const _SC_IOV_MAX: _bindgen_ty_13 = 60;
pub const _SC_PII_INTERNET_STREAM: _bindgen_ty_13 = 61;
pub const _SC_PII_INTERNET_DGRAM: _bindgen_ty_13 = 62;
pub const _SC_PII_OSI_COTS: _bindgen_ty_13 = 63;
pub const _SC_PII_OSI_CLTS: _bindgen_ty_13 = 64;
pub const _SC_PII_OSI_M: _bindgen_ty_13 = 65;
pub const _SC_T_IOV_MAX: _bindgen_ty_13 = 66;
pub const _SC_THREADS: _bindgen_ty_13 = 67;
pub const _SC_THREAD_SAFE_FUNCTIONS: _bindgen_ty_13 = 68;
pub const _SC_GETGR_R_SIZE_MAX: _bindgen_ty_13 = 69;
pub const _SC_GETPW_R_SIZE_MAX: _bindgen_ty_13 = 70;
pub const _SC_LOGIN_NAME_MAX: _bindgen_ty_13 = 71;
pub const _SC_TTY_NAME_MAX: _bindgen_ty_13 = 72;
pub const _SC_THREAD_DESTRUCTOR_ITERATIONS: _bindgen_ty_13 = 73;
pub const _SC_THREAD_KEYS_MAX: _bindgen_ty_13 = 74;
pub const _SC_THREAD_STACK_MIN: _bindgen_ty_13 = 75;
pub const _SC_THREAD_THREADS_MAX: _bindgen_ty_13 = 76;
pub const _SC_THREAD_ATTR_STACKADDR: _bindgen_ty_13 = 77;
pub const _SC_THREAD_ATTR_STACKSIZE: _bindgen_ty_13 = 78;
pub const _SC_THREAD_PRIORITY_SCHEDULING: _bindgen_ty_13 = 79;
pub const _SC_THREAD_PRIO_INHERIT: _bindgen_ty_13 = 80;
pub const _SC_THREAD_PRIO_PROTECT: _bindgen_ty_13 = 81;
pub const _SC_THREAD_PROCESS_SHARED: _bindgen_ty_13 = 82;
pub const _SC_NPROCESSORS_CONF: _bindgen_ty_13 = 83;
pub const _SC_NPROCESSORS_ONLN: _bindgen_ty_13 = 84;
pub const _SC_PHYS_PAGES: _bindgen_ty_13 = 85;
pub const _SC_AVPHYS_PAGES: _bindgen_ty_13 = 86;
pub const _SC_ATEXIT_MAX: _bindgen_ty_13 = 87;
pub const _SC_PASS_MAX: _bindgen_ty_13 = 88;
pub const _SC_XOPEN_VERSION: _bindgen_ty_13 = 89;
pub const _SC_XOPEN_XCU_VERSION: _bindgen_ty_13 = 90;
pub const _SC_XOPEN_UNIX: _bindgen_ty_13 = 91;
pub const _SC_XOPEN_CRYPT: _bindgen_ty_13 = 92;
pub const _SC_XOPEN_ENH_I18N: _bindgen_ty_13 = 93;
pub const _SC_XOPEN_SHM: _bindgen_ty_13 = 94;
pub const _SC_2_CHAR_TERM: _bindgen_ty_13 = 95;
pub const _SC_2_C_VERSION: _bindgen_ty_13 = 96;
pub const _SC_2_UPE: _bindgen_ty_13 = 97;
pub const _SC_XOPEN_XPG2: _bindgen_ty_13 = 98;
pub const _SC_XOPEN_XPG3: _bindgen_ty_13 = 99;
pub const _SC_XOPEN_XPG4: _bindgen_ty_13 = 100;
pub const _SC_CHAR_BIT: _bindgen_ty_13 = 101;
pub const _SC_CHAR_MAX: _bindgen_ty_13 = 102;
pub const _SC_CHAR_MIN: _bindgen_ty_13 = 103;
pub const _SC_INT_MAX: _bindgen_ty_13 = 104;
pub const _SC_INT_MIN: _bindgen_ty_13 = 105;
pub const _SC_LONG_BIT: _bindgen_ty_13 = 106;
pub const _SC_WORD_BIT: _bindgen_ty_13 = 107;
pub const _SC_MB_LEN_MAX: _bindgen_ty_13 = 108;
pub const _SC_NZERO: _bindgen_ty_13 = 109;
pub const _SC_SSIZE_MAX: _bindgen_ty_13 = 110;
pub const _SC_SCHAR_MAX: _bindgen_ty_13 = 111;
pub const _SC_SCHAR_MIN: _bindgen_ty_13 = 112;
pub const _SC_SHRT_MAX: _bindgen_ty_13 = 113;
pub const _SC_SHRT_MIN: _bindgen_ty_13 = 114;
pub const _SC_UCHAR_MAX: _bindgen_ty_13 = 115;
pub const _SC_UINT_MAX: _bindgen_ty_13 = 116;
pub const _SC_ULONG_MAX: _bindgen_ty_13 = 117;
pub const _SC_USHRT_MAX: _bindgen_ty_13 = 118;
pub const _SC_NL_ARGMAX: _bindgen_ty_13 = 119;
pub const _SC_NL_LANGMAX: _bindgen_ty_13 = 120;
pub const _SC_NL_MSGMAX: _bindgen_ty_13 = 121;
pub const _SC_NL_NMAX: _bindgen_ty_13 = 122;
pub const _SC_NL_SETMAX: _bindgen_ty_13 = 123;
pub const _SC_NL_TEXTMAX: _bindgen_ty_13 = 124;
pub const _SC_XBS5_ILP32_OFF32: _bindgen_ty_13 = 125;
pub const _SC_XBS5_ILP32_OFFBIG: _bindgen_ty_13 = 126;
pub const _SC_XBS5_LP64_OFF64: _bindgen_ty_13 = 127;
pub const _SC_XBS5_LPBIG_OFFBIG: _bindgen_ty_13 = 128;
pub const _SC_XOPEN_LEGACY: _bindgen_ty_13 = 129;
pub const _SC_XOPEN_REALTIME: _bindgen_ty_13 = 130;
pub const _SC_XOPEN_REALTIME_THREADS: _bindgen_ty_13 = 131;
pub const _SC_ADVISORY_INFO: _bindgen_ty_13 = 132;
pub const _SC_BARRIERS: _bindgen_ty_13 = 133;
pub const _SC_BASE: _bindgen_ty_13 = 134;
pub const _SC_C_LANG_SUPPORT: _bindgen_ty_13 = 135;
pub const _SC_C_LANG_SUPPORT_R: _bindgen_ty_13 = 136;
pub const _SC_CLOCK_SELECTION: _bindgen_ty_13 = 137;
pub const _SC_CPUTIME: _bindgen_ty_13 = 138;
pub const _SC_THREAD_CPUTIME: _bindgen_ty_13 = 139;
pub const _SC_DEVICE_IO: _bindgen_ty_13 = 140;
pub const _SC_DEVICE_SPECIFIC: _bindgen_ty_13 = 141;
pub const _SC_DEVICE_SPECIFIC_R: _bindgen_ty_13 = 142;
pub const _SC_FD_MGMT: _bindgen_ty_13 = 143;
pub const _SC_FIFO: _bindgen_ty_13 = 144;
pub const _SC_PIPE: _bindgen_ty_13 = 145;
pub const _SC_FILE_ATTRIBUTES: _bindgen_ty_13 = 146;
pub const _SC_FILE_LOCKING: _bindgen_ty_13 = 147;
pub const _SC_FILE_SYSTEM: _bindgen_ty_13 = 148;
pub const _SC_MONOTONIC_CLOCK: _bindgen_ty_13 = 149;
pub const _SC_MULTI_PROCESS: _bindgen_ty_13 = 150;
pub const _SC_SINGLE_PROCESS: _bindgen_ty_13 = 151;
pub const _SC_NETWORKING: _bindgen_ty_13 = 152;
pub const _SC_READER_WRITER_LOCKS: _bindgen_ty_13 = 153;
pub const _SC_SPIN_LOCKS: _bindgen_ty_13 = 154;
pub const _SC_REGEXP: _bindgen_ty_13 = 155;
pub const _SC_REGEX_VERSION: _bindgen_ty_13 = 156;
pub const _SC_SHELL: _bindgen_ty_13 = 157;
pub const _SC_SIGNALS: _bindgen_ty_13 = 158;
pub const _SC_SPAWN: _bindgen_ty_13 = 159;
pub const _SC_SPORADIC_SERVER: _bindgen_ty_13 = 160;
pub const _SC_THREAD_SPORADIC_SERVER: _bindgen_ty_13 = 161;
pub const _SC_SYSTEM_DATABASE: _bindgen_ty_13 = 162;
pub const _SC_SYSTEM_DATABASE_R: _bindgen_ty_13 = 163;
pub const _SC_TIMEOUTS: _bindgen_ty_13 = 164;
pub const _SC_TYPED_MEMORY_OBJECTS: _bindgen_ty_13 = 165;
pub const _SC_USER_GROUPS: _bindgen_ty_13 = 166;
pub const _SC_USER_GROUPS_R: _bindgen_ty_13 = 167;
pub const _SC_2_PBS: _bindgen_ty_13 = 168;
pub const _SC_2_PBS_ACCOUNTING: _bindgen_ty_13 = 169;
pub const _SC_2_PBS_LOCATE: _bindgen_ty_13 = 170;
pub const _SC_2_PBS_MESSAGE: _bindgen_ty_13 = 171;
pub const _SC_2_PBS_TRACK: _bindgen_ty_13 = 172;
pub const _SC_SYMLOOP_MAX: _bindgen_ty_13 = 173;
pub const _SC_STREAMS: _bindgen_ty_13 = 174;
pub const _SC_2_PBS_CHECKPOINT: _bindgen_ty_13 = 175;
pub const _SC_V6_ILP32_OFF32: _bindgen_ty_13 = 176;
pub const _SC_V6_ILP32_OFFBIG: _bindgen_ty_13 = 177;
pub const _SC_V6_LP64_OFF64: _bindgen_ty_13 = 178;
pub const _SC_V6_LPBIG_OFFBIG: _bindgen_ty_13 = 179;
pub const _SC_HOST_NAME_MAX: _bindgen_ty_13 = 180;
pub const _SC_TRACE: _bindgen_ty_13 = 181;
pub const _SC_TRACE_EVENT_FILTER: _bindgen_ty_13 = 182;
pub const _SC_TRACE_INHERIT: _bindgen_ty_13 = 183;
pub const _SC_TRACE_LOG: _bindgen_ty_13 = 184;
pub const _SC_LEVEL1_ICACHE_SIZE: _bindgen_ty_13 = 185;
pub const _SC_LEVEL1_ICACHE_ASSOC: _bindgen_ty_13 = 186;
pub const _SC_LEVEL1_ICACHE_LINESIZE: _bindgen_ty_13 = 187;
pub const _SC_LEVEL1_DCACHE_SIZE: _bindgen_ty_13 = 188;
pub const _SC_LEVEL1_DCACHE_ASSOC: _bindgen_ty_13 = 189;
pub const _SC_LEVEL1_DCACHE_LINESIZE: _bindgen_ty_13 = 190;
pub const _SC_LEVEL2_CACHE_SIZE: _bindgen_ty_13 = 191;
pub const _SC_LEVEL2_CACHE_ASSOC: _bindgen_ty_13 = 192;
pub const _SC_LEVEL2_CACHE_LINESIZE: _bindgen_ty_13 = 193;
pub const _SC_LEVEL3_CACHE_SIZE: _bindgen_ty_13 = 194;
pub const _SC_LEVEL3_CACHE_ASSOC: _bindgen_ty_13 = 195;
pub const _SC_LEVEL3_CACHE_LINESIZE: _bindgen_ty_13 = 196;
pub const _SC_LEVEL4_CACHE_SIZE: _bindgen_ty_13 = 197;
pub const _SC_LEVEL4_CACHE_ASSOC: _bindgen_ty_13 = 198;
pub const _SC_LEVEL4_CACHE_LINESIZE: _bindgen_ty_13 = 199;
pub const _SC_IPV6: _bindgen_ty_13 = 235;
pub const _SC_RAW_SOCKETS: _bindgen_ty_13 = 236;
pub const _SC_V7_ILP32_OFF32: _bindgen_ty_13 = 237;
pub const _SC_V7_ILP32_OFFBIG: _bindgen_ty_13 = 238;
pub const _SC_V7_LP64_OFF64: _bindgen_ty_13 = 239;
pub const _SC_V7_LPBIG_OFFBIG: _bindgen_ty_13 = 240;
pub const _SC_SS_REPL_MAX: _bindgen_ty_13 = 241;
pub const _SC_TRACE_EVENT_NAME_MAX: _bindgen_ty_13 = 242;
pub const _SC_TRACE_NAME_MAX: _bindgen_ty_13 = 243;
pub const _SC_TRACE_SYS_MAX: _bindgen_ty_13 = 244;
pub const _SC_TRACE_USER_EVENT_MAX: _bindgen_ty_13 = 245;
pub const _SC_XOPEN_STREAMS: _bindgen_ty_13 = 246;
pub const _SC_THREAD_ROBUST_PRIO_INHERIT: _bindgen_ty_13 = 247;
pub const _SC_THREAD_ROBUST_PRIO_PROTECT: _bindgen_ty_13 = 248;
pub const _SC_MINSIGSTKSZ: _bindgen_ty_13 = 249;
pub const _SC_SIGSTKSZ: _bindgen_ty_13 = 250;
pub type _bindgen_ty_13 = ::std::os::raw::c_uint;
pub const _CS_PATH: _bindgen_ty_14 = 0;
pub const _CS_V6_WIDTH_RESTRICTED_ENVS: _bindgen_ty_14 = 1;
pub const _CS_GNU_LIBC_VERSION: _bindgen_ty_14 = 2;
pub const _CS_GNU_LIBPTHREAD_VERSION: _bindgen_ty_14 = 3;
pub const _CS_V5_WIDTH_RESTRICTED_ENVS: _bindgen_ty_14 = 4;
pub const _CS_V7_WIDTH_RESTRICTED_ENVS: _bindgen_ty_14 = 5;
pub const _CS_LFS_CFLAGS: _bindgen_ty_14 = 1000;
pub const _CS_LFS_LDFLAGS: _bindgen_ty_14 = 1001;
pub const _CS_LFS_LIBS: _bindgen_ty_14 = 1002;
pub const _CS_LFS_LINTFLAGS: _bindgen_ty_14 = 1003;
pub const _CS_LFS64_CFLAGS: _bindgen_ty_14 = 1004;
pub const _CS_LFS64_LDFLAGS: _bindgen_ty_14 = 1005;
pub const _CS_LFS64_LIBS: _bindgen_ty_14 = 1006;
pub const _CS_LFS64_LINTFLAGS: _bindgen_ty_14 = 1007;
pub const _CS_XBS5_ILP32_OFF32_CFLAGS: _bindgen_ty_14 = 1100;
pub const _CS_XBS5_ILP32_OFF32_LDFLAGS: _bindgen_ty_14 = 1101;
pub const _CS_XBS5_ILP32_OFF32_LIBS: _bindgen_ty_14 = 1102;
pub const _CS_XBS5_ILP32_OFF32_LINTFLAGS: _bindgen_ty_14 = 1103;
pub const _CS_XBS5_ILP32_OFFBIG_CFLAGS: _bindgen_ty_14 = 1104;
pub const _CS_XBS5_ILP32_OFFBIG_LDFLAGS: _bindgen_ty_14 = 1105;
pub const _CS_XBS5_ILP32_OFFBIG_LIBS: _bindgen_ty_14 = 1106;
pub const _CS_XBS5_ILP32_OFFBIG_LINTFLAGS: _bindgen_ty_14 = 1107;
pub const _CS_XBS5_LP64_OFF64_CFLAGS: _bindgen_ty_14 = 1108;
pub const _CS_XBS5_LP64_OFF64_LDFLAGS: _bindgen_ty_14 = 1109;
pub const _CS_XBS5_LP64_OFF64_LIBS: _bindgen_ty_14 = 1110;
pub const _CS_XBS5_LP64_OFF64_LINTFLAGS: _bindgen_ty_14 = 1111;
pub const _CS_XBS5_LPBIG_OFFBIG_CFLAGS: _bindgen_ty_14 = 1112;
pub const _CS_XBS5_LPBIG_OFFBIG_LDFLAGS: _bindgen_ty_14 = 1113;
pub const _CS_XBS5_LPBIG_OFFBIG_LIBS: _bindgen_ty_14 = 1114;
pub const _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS: _bindgen_ty_14 = 1115;
pub const _CS_POSIX_V6_ILP32_OFF32_CFLAGS: _bindgen_ty_14 = 1116;
pub const _CS_POSIX_V6_ILP32_OFF32_LDFLAGS: _bindgen_ty_14 = 1117;
pub const _CS_POSIX_V6_ILP32_OFF32_LIBS: _bindgen_ty_14 = 1118;
pub const _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS: _bindgen_ty_14 = 1119;
pub const _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS: _bindgen_ty_14 = 1120;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS: _bindgen_ty_14 = 1121;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LIBS: _bindgen_ty_14 = 1122;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS: _bindgen_ty_14 = 1123;
pub const _CS_POSIX_V6_LP64_OFF64_CFLAGS: _bindgen_ty_14 = 1124;
pub const _CS_POSIX_V6_LP64_OFF64_LDFLAGS: _bindgen_ty_14 = 1125;
pub const _CS_POSIX_V6_LP64_OFF64_LIBS: _bindgen_ty_14 = 1126;
pub const _CS_POSIX_V6_LP64_OFF64_LINTFLAGS: _bindgen_ty_14 = 1127;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS: _bindgen_ty_14 = 1128;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS: _bindgen_ty_14 = 1129;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LIBS: _bindgen_ty_14 = 1130;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS: _bindgen_ty_14 = 1131;
pub const _CS_POSIX_V7_ILP32_OFF32_CFLAGS: _bindgen_ty_14 = 1132;
pub const _CS_POSIX_V7_ILP32_OFF32_LDFLAGS: _bindgen_ty_14 = 1133;
pub const _CS_POSIX_V7_ILP32_OFF32_LIBS: _bindgen_ty_14 = 1134;
pub const _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS: _bindgen_ty_14 = 1135;
pub const _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS: _bindgen_ty_14 = 1136;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS: _bindgen_ty_14 = 1137;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LIBS: _bindgen_ty_14 = 1138;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS: _bindgen_ty_14 = 1139;
pub const _CS_POSIX_V7_LP64_OFF64_CFLAGS: _bindgen_ty_14 = 1140;
pub const _CS_POSIX_V7_LP64_OFF64_LDFLAGS: _bindgen_ty_14 = 1141;
pub const _CS_POSIX_V7_LP64_OFF64_LIBS: _bindgen_ty_14 = 1142;
pub const _CS_POSIX_V7_LP64_OFF64_LINTFLAGS: _bindgen_ty_14 = 1143;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS: _bindgen_ty_14 = 1144;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS: _bindgen_ty_14 = 1145;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LIBS: _bindgen_ty_14 = 1146;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS: _bindgen_ty_14 = 1147;
pub const _CS_V6_ENV: _bindgen_ty_14 = 1148;
pub const _CS_V7_ENV: _bindgen_ty_14 = 1149;
pub type _bindgen_ty_14 = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn pathconf(
        __path: *const ::std::os::raw::c_char,
        __name: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn fpathconf(
        __fd: ::std::os::raw::c_int,
        __name: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn sysconf(__name: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn confstr(
        __name: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> usize;
}
unsafe extern "C" {
    pub fn getpid() -> __pid_t;
}
unsafe extern "C" {
    pub fn getppid() -> __pid_t;
}
unsafe extern "C" {
    pub fn getpgrp() -> __pid_t;
}
unsafe extern "C" {
    pub fn __getpgid(__pid: __pid_t) -> __pid_t;
}
unsafe extern "C" {
    pub fn getpgid(__pid: __pid_t) -> __pid_t;
}
unsafe extern "C" {
    pub fn setpgid(__pid: __pid_t, __pgid: __pid_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setpgrp() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setsid() -> __pid_t;
}
unsafe extern "C" {
    pub fn getsid(__pid: __pid_t) -> __pid_t;
}
unsafe extern "C" {
    pub fn getuid() -> __uid_t;
}
unsafe extern "C" {
    pub fn geteuid() -> __uid_t;
}
unsafe extern "C" {
    pub fn getgid() -> __gid_t;
}
unsafe extern "C" {
    pub fn getegid() -> __gid_t;
}
unsafe extern "C" {
    pub fn getgroups(__size: ::std::os::raw::c_int, __list: *mut __gid_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setuid(__uid: __uid_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setreuid(__ruid: __uid_t, __euid: __uid_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn seteuid(__uid: __uid_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setgid(__gid: __gid_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setregid(__rgid: __gid_t, __egid: __gid_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setegid(__gid: __gid_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fork() -> __pid_t;
}
unsafe extern "C" {
    pub fn vfork() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ttyname(__fd: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ttyname_r(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isatty(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ttyslot() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn link(
        __from: *const ::std::os::raw::c_char,
        __to: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn linkat(
        __fromfd: ::std::os::raw::c_int,
        __from: *const ::std::os::raw::c_char,
        __tofd: ::std::os::raw::c_int,
        __to: *const ::std::os::raw::c_char,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn symlink(
        __from: *const ::std::os::raw::c_char,
        __to: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn readlink(
        __path: *const ::std::os::raw::c_char,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> isize;
}
unsafe extern "C" {
    pub fn symlinkat(
        __from: *const ::std::os::raw::c_char,
        __tofd: ::std::os::raw::c_int,
        __to: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn readlinkat(
        __fd: ::std::os::raw::c_int,
        __path: *const ::std::os::raw::c_char,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> isize;
}
unsafe extern "C" {
    pub fn unlink(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn unlinkat(
        __fd: ::std::os::raw::c_int,
        __name: *const ::std::os::raw::c_char,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rmdir(__path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn tcgetpgrp(__fd: ::std::os::raw::c_int) -> __pid_t;
}
unsafe extern "C" {
    pub fn tcsetpgrp(__fd: ::std::os::raw::c_int, __pgrp_id: __pid_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getlogin() -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn getlogin_r(
        __name: *mut ::std::os::raw::c_char,
        __name_len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setlogin(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub static mut optarg: *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub static mut optind: ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub static mut opterr: ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub static mut optopt: ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getopt(
        ___argc: ::std::os::raw::c_int,
        ___argv: *const *mut ::std::os::raw::c_char,
        __shortopts: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn gethostname(__name: *mut ::std::os::raw::c_char, __len: usize) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sethostname(
        __name: *const ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sethostid(__id: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getdomainname(
        __name: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setdomainname(
        __name: *const ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vhangup() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn revoke(__file: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn profil(
        __sample_buffer: *mut ::std::os::raw::c_ushort,
        __size: usize,
        __offset: usize,
        __scale: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn acct(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getusershell() -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn endusershell();
}
unsafe extern "C" {
    pub fn setusershell();
}
unsafe extern "C" {
    pub fn daemon(
        __nochdir: ::std::os::raw::c_int,
        __noclose: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn chroot(__path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getpass(__prompt: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn fsync(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn gethostid() -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn sync();
}
unsafe extern "C" {
    pub fn getpagesize() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getdtablesize() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn truncate(
        __file: *const ::std::os::raw::c_char,
        __length: __off_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ftruncate(__fd: ::std::os::raw::c_int, __length: __off_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn brk(__addr: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sbrk(__delta: isize) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn syscall(__sysno: ::std::os::raw::c_long, ...) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn lockf(
        __fd: ::std::os::raw::c_int,
        __cmd: ::std::os::raw::c_int,
        __len: __off_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fdatasync(__fildes: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn crypt(
        __key: *const ::std::os::raw::c_char,
        __salt: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn getentropy(
        __buffer: *mut ::std::os::raw::c_void,
        __length: usize,
    ) -> ::std::os::raw::c_int;
}
pub type _spa_autoptr_cleanup_type_FILE = *mut _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dirent {
    pub d_ino: __ino_t,
    pub d_off: __off_t,
    pub d_reclen: ::std::os::raw::c_ushort,
    pub d_type: ::std::os::raw::c_uchar,
    pub d_name: [::std::os::raw::c_char; 256usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of dirent"][::std::mem::size_of::<dirent>() - 280usize];
    ["Alignment of dirent"][::std::mem::align_of::<dirent>() - 8usize];
    ["Offset of field: dirent::d_ino"][::std::mem::offset_of!(dirent, d_ino) - 0usize];
    ["Offset of field: dirent::d_off"][::std::mem::offset_of!(dirent, d_off) - 8usize];
    ["Offset of field: dirent::d_reclen"][::std::mem::offset_of!(dirent, d_reclen) - 16usize];
    ["Offset of field: dirent::d_type"][::std::mem::offset_of!(dirent, d_type) - 18usize];
    ["Offset of field: dirent::d_name"][::std::mem::offset_of!(dirent, d_name) - 19usize];
};
pub const DT_UNKNOWN: _bindgen_ty_15 = 0;
pub const DT_FIFO: _bindgen_ty_15 = 1;
pub const DT_CHR: _bindgen_ty_15 = 2;
pub const DT_DIR: _bindgen_ty_15 = 4;
pub const DT_BLK: _bindgen_ty_15 = 6;
pub const DT_REG: _bindgen_ty_15 = 8;
pub const DT_LNK: _bindgen_ty_15 = 10;
pub const DT_SOCK: _bindgen_ty_15 = 12;
pub const DT_WHT: _bindgen_ty_15 = 14;
pub type _bindgen_ty_15 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __dirstream {
    _unused: [u8; 0],
}
pub type DIR = __dirstream;
unsafe extern "C" {
    pub fn closedir(__dirp: *mut DIR) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn opendir(__name: *const ::std::os::raw::c_char) -> *mut DIR;
}
unsafe extern "C" {
    pub fn fdopendir(__fd: ::std::os::raw::c_int) -> *mut DIR;
}
unsafe extern "C" {
    pub fn readdir(__dirp: *mut DIR) -> *mut dirent;
}
unsafe extern "C" {
    pub fn readdir_r(
        __dirp: *mut DIR,
        __entry: *mut dirent,
        __result: *mut *mut dirent,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rewinddir(__dirp: *mut DIR);
}
unsafe extern "C" {
    pub fn seekdir(__dirp: *mut DIR, __pos: ::std::os::raw::c_long);
}
unsafe extern "C" {
    pub fn telldir(__dirp: *mut DIR) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn dirfd(__dirp: *mut DIR) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn scandir(
        __dir: *const ::std::os::raw::c_char,
        __namelist: *mut *mut *mut dirent,
        __selector: ::std::option::Option<
            unsafe extern "C" fn(arg1: *const dirent) -> ::std::os::raw::c_int,
        >,
        __cmp: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut *const dirent,
                arg2: *mut *const dirent,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn alphasort(__e1: *mut *const dirent, __e2: *mut *const dirent) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getdirentries(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __nbytes: usize,
        __basep: *mut __off_t,
    ) -> __ssize_t;
}
pub type _spa_autoptr_cleanup_type_DIR = *mut __dirstream;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_pod_dynamic_builder {
    pub b: spa_pod_builder,
    pub data: *mut ::std::os::raw::c_void,
    pub extend: u32,
    pub _padding: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_dynamic_builder"][::std::mem::size_of::<spa_pod_dynamic_builder>() - 64usize];
    ["Alignment of spa_pod_dynamic_builder"]
        [::std::mem::align_of::<spa_pod_dynamic_builder>() - 8usize];
    ["Offset of field: spa_pod_dynamic_builder::b"]
        [::std::mem::offset_of!(spa_pod_dynamic_builder, b) - 0usize];
    ["Offset of field: spa_pod_dynamic_builder::data"]
        [::std::mem::offset_of!(spa_pod_dynamic_builder, data) - 48usize];
    ["Offset of field: spa_pod_dynamic_builder::extend"]
        [::std::mem::offset_of!(spa_pod_dynamic_builder, extend) - 56usize];
    ["Offset of field: spa_pod_dynamic_builder::_padding"]
        [::std::mem::offset_of!(spa_pod_dynamic_builder, _padding) - 60usize];
};
pub type _spa_auto_cleanup_type_spa_pod_dynamic_builder = spa_pod_dynamic_builder;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_cpu {
    pub iface: spa_interface,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_cpu"][::std::mem::size_of::<spa_cpu>() - 32usize];
    ["Alignment of spa_cpu"][::std::mem::align_of::<spa_cpu>() - 8usize];
    ["Offset of field: spa_cpu::iface"][::std::mem::offset_of!(spa_cpu, iface) - 0usize];
};
#[doc = " methods"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_cpu_methods {
    pub version: u32,
    #[doc = " get CPU flags"]
    pub get_flags:
        ::std::option::Option<unsafe extern "C" fn(object: *mut ::std::os::raw::c_void) -> u32>,
    #[doc = " force CPU flags, use SPA_CPU_FORCE_AUTODETECT to autodetect CPU flags"]
    pub force_flags: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            flags: u32,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " get number of CPU cores"]
    pub get_count:
        ::std::option::Option<unsafe extern "C" fn(object: *mut ::std::os::raw::c_void) -> u32>,
    #[doc = " get maximum required alignment of data"]
    pub get_max_align:
        ::std::option::Option<unsafe extern "C" fn(object: *mut ::std::os::raw::c_void) -> u32>,
    pub get_vm_type:
        ::std::option::Option<unsafe extern "C" fn(object: *mut ::std::os::raw::c_void) -> u32>,
    pub zero_denormals: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            enable: bool,
        ) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_cpu_methods"][::std::mem::size_of::<spa_cpu_methods>() - 56usize];
    ["Alignment of spa_cpu_methods"][::std::mem::align_of::<spa_cpu_methods>() - 8usize];
    ["Offset of field: spa_cpu_methods::version"]
        [::std::mem::offset_of!(spa_cpu_methods, version) - 0usize];
    ["Offset of field: spa_cpu_methods::get_flags"]
        [::std::mem::offset_of!(spa_cpu_methods, get_flags) - 8usize];
    ["Offset of field: spa_cpu_methods::force_flags"]
        [::std::mem::offset_of!(spa_cpu_methods, force_flags) - 16usize];
    ["Offset of field: spa_cpu_methods::get_count"]
        [::std::mem::offset_of!(spa_cpu_methods, get_count) - 24usize];
    ["Offset of field: spa_cpu_methods::get_max_align"]
        [::std::mem::offset_of!(spa_cpu_methods, get_max_align) - 32usize];
    ["Offset of field: spa_cpu_methods::get_vm_type"]
        [::std::mem::offset_of!(spa_cpu_methods, get_vm_type) - 40usize];
    ["Offset of field: spa_cpu_methods::zero_denormals"]
        [::std::mem::offset_of!(spa_cpu_methods, zero_denormals) - 48usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of tm"][::std::mem::size_of::<tm>() - 56usize];
    ["Alignment of tm"][::std::mem::align_of::<tm>() - 8usize];
    ["Offset of field: tm::tm_sec"][::std::mem::offset_of!(tm, tm_sec) - 0usize];
    ["Offset of field: tm::tm_min"][::std::mem::offset_of!(tm, tm_min) - 4usize];
    ["Offset of field: tm::tm_hour"][::std::mem::offset_of!(tm, tm_hour) - 8usize];
    ["Offset of field: tm::tm_mday"][::std::mem::offset_of!(tm, tm_mday) - 12usize];
    ["Offset of field: tm::tm_mon"][::std::mem::offset_of!(tm, tm_mon) - 16usize];
    ["Offset of field: tm::tm_year"][::std::mem::offset_of!(tm, tm_year) - 20usize];
    ["Offset of field: tm::tm_wday"][::std::mem::offset_of!(tm, tm_wday) - 24usize];
    ["Offset of field: tm::tm_yday"][::std::mem::offset_of!(tm, tm_yday) - 28usize];
    ["Offset of field: tm::tm_isdst"][::std::mem::offset_of!(tm, tm_isdst) - 32usize];
    ["Offset of field: tm::tm_gmtoff"][::std::mem::offset_of!(tm, tm_gmtoff) - 40usize];
    ["Offset of field: tm::tm_zone"][::std::mem::offset_of!(tm, tm_zone) - 48usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of itimerspec"][::std::mem::size_of::<itimerspec>() - 32usize];
    ["Alignment of itimerspec"][::std::mem::align_of::<itimerspec>() - 8usize];
    ["Offset of field: itimerspec::it_interval"]
        [::std::mem::offset_of!(itimerspec, it_interval) - 0usize];
    ["Offset of field: itimerspec::it_value"]
        [::std::mem::offset_of!(itimerspec, it_value) - 16usize];
};
unsafe extern "C" {
    pub fn clock() -> clock_t;
}
unsafe extern "C" {
    pub fn time(__timer: *mut time_t) -> time_t;
}
unsafe extern "C" {
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
}
unsafe extern "C" {
    pub fn mktime(__tp: *mut tm) -> time_t;
}
unsafe extern "C" {
    pub fn strftime(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: usize,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
    ) -> usize;
}
unsafe extern "C" {
    pub fn strftime_l(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: usize,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
        __loc: locale_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
}
unsafe extern "C" {
    pub fn localtime(__timer: *const time_t) -> *mut tm;
}
unsafe extern "C" {
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
unsafe extern "C" {
    pub fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
unsafe extern "C" {
    pub fn asctime(__tp: *const tm) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ctime(__timer: *const time_t) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn asctime_r(
        __tp: *const tm,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ctime_r(
        __timer: *const time_t,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub static mut __tzname: [*mut ::std::os::raw::c_char; 2usize];
}
unsafe extern "C" {
    pub static mut __daylight: ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub static mut __timezone: ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub static mut tzname: [*mut ::std::os::raw::c_char; 2usize];
}
unsafe extern "C" {
    pub fn tzset();
}
unsafe extern "C" {
    pub static mut daylight: ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub static mut timezone: ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn timegm(__tp: *mut tm) -> time_t;
}
unsafe extern "C" {
    pub fn timelocal(__tp: *mut tm) -> time_t;
}
unsafe extern "C" {
    pub fn dysize(__year: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn nanosleep(
        __requested_time: *const timespec,
        __remaining: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clock_nanosleep(
        __clock_id: clockid_t,
        __flags: ::std::os::raw::c_int,
        __req: *const timespec,
        __rem: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn timer_create(
        __clock_id: clockid_t,
        __evp: *mut sigevent,
        __timerid: *mut timer_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn timer_delete(__timerid: timer_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn timer_settime(
        __timerid: timer_t,
        __flags: ::std::os::raw::c_int,
        __value: *const itimerspec,
        __ovalue: *mut itimerspec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn timer_gettime(__timerid: timer_t, __value: *mut itimerspec) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn timer_getoverrun(__timerid: timer_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn timespec_get(
        __ts: *mut timespec,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_system {
    pub iface: spa_interface,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_system"][::std::mem::size_of::<spa_system>() - 32usize];
    ["Alignment of spa_system"][::std::mem::align_of::<spa_system>() - 8usize];
    ["Offset of field: spa_system::iface"][::std::mem::offset_of!(spa_system, iface) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_poll_event {
    pub events: u32,
    pub data: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_poll_event"][::std::mem::size_of::<spa_poll_event>() - 16usize];
    ["Alignment of spa_poll_event"][::std::mem::align_of::<spa_poll_event>() - 8usize];
    ["Offset of field: spa_poll_event::events"]
        [::std::mem::offset_of!(spa_poll_event, events) - 0usize];
    ["Offset of field: spa_poll_event::data"]
        [::std::mem::offset_of!(spa_poll_event, data) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_system_methods {
    pub version: u32,
    pub read: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            fd: ::std::os::raw::c_int,
            buf: *mut ::std::os::raw::c_void,
            count: usize,
        ) -> isize,
    >,
    pub write: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            fd: ::std::os::raw::c_int,
            buf: *const ::std::os::raw::c_void,
            count: usize,
        ) -> isize,
    >,
    pub ioctl: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            fd: ::std::os::raw::c_int,
            request: ::std::os::raw::c_ulong,
            ...
        ) -> ::std::os::raw::c_int,
    >,
    pub close: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            fd: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub clock_gettime: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            clockid: ::std::os::raw::c_int,
            value: *mut timespec,
        ) -> ::std::os::raw::c_int,
    >,
    pub clock_getres: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            clockid: ::std::os::raw::c_int,
            res: *mut timespec,
        ) -> ::std::os::raw::c_int,
    >,
    pub pollfd_create: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            flags: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub pollfd_add: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            pfd: ::std::os::raw::c_int,
            fd: ::std::os::raw::c_int,
            events: u32,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub pollfd_mod: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            pfd: ::std::os::raw::c_int,
            fd: ::std::os::raw::c_int,
            events: u32,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub pollfd_del: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            pfd: ::std::os::raw::c_int,
            fd: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub pollfd_wait: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            pfd: ::std::os::raw::c_int,
            ev: *mut spa_poll_event,
            n_ev: ::std::os::raw::c_int,
            timeout: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub timerfd_create: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            clockid: ::std::os::raw::c_int,
            flags: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub timerfd_settime: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            fd: ::std::os::raw::c_int,
            flags: ::std::os::raw::c_int,
            new_value: *const itimerspec,
            old_value: *mut itimerspec,
        ) -> ::std::os::raw::c_int,
    >,
    pub timerfd_gettime: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            fd: ::std::os::raw::c_int,
            curr_value: *mut itimerspec,
        ) -> ::std::os::raw::c_int,
    >,
    pub timerfd_read: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            fd: ::std::os::raw::c_int,
            expirations: *mut u64,
        ) -> ::std::os::raw::c_int,
    >,
    pub eventfd_create: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            flags: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub eventfd_write: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            fd: ::std::os::raw::c_int,
            count: u64,
        ) -> ::std::os::raw::c_int,
    >,
    pub eventfd_read: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            fd: ::std::os::raw::c_int,
            count: *mut u64,
        ) -> ::std::os::raw::c_int,
    >,
    pub signalfd_create: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            signal: ::std::os::raw::c_int,
            flags: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub signalfd_read: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            fd: ::std::os::raw::c_int,
            signal: *mut ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_system_methods"][::std::mem::size_of::<spa_system_methods>() - 168usize];
    ["Alignment of spa_system_methods"][::std::mem::align_of::<spa_system_methods>() - 8usize];
    ["Offset of field: spa_system_methods::version"]
        [::std::mem::offset_of!(spa_system_methods, version) - 0usize];
    ["Offset of field: spa_system_methods::read"]
        [::std::mem::offset_of!(spa_system_methods, read) - 8usize];
    ["Offset of field: spa_system_methods::write"]
        [::std::mem::offset_of!(spa_system_methods, write) - 16usize];
    ["Offset of field: spa_system_methods::ioctl"]
        [::std::mem::offset_of!(spa_system_methods, ioctl) - 24usize];
    ["Offset of field: spa_system_methods::close"]
        [::std::mem::offset_of!(spa_system_methods, close) - 32usize];
    ["Offset of field: spa_system_methods::clock_gettime"]
        [::std::mem::offset_of!(spa_system_methods, clock_gettime) - 40usize];
    ["Offset of field: spa_system_methods::clock_getres"]
        [::std::mem::offset_of!(spa_system_methods, clock_getres) - 48usize];
    ["Offset of field: spa_system_methods::pollfd_create"]
        [::std::mem::offset_of!(spa_system_methods, pollfd_create) - 56usize];
    ["Offset of field: spa_system_methods::pollfd_add"]
        [::std::mem::offset_of!(spa_system_methods, pollfd_add) - 64usize];
    ["Offset of field: spa_system_methods::pollfd_mod"]
        [::std::mem::offset_of!(spa_system_methods, pollfd_mod) - 72usize];
    ["Offset of field: spa_system_methods::pollfd_del"]
        [::std::mem::offset_of!(spa_system_methods, pollfd_del) - 80usize];
    ["Offset of field: spa_system_methods::pollfd_wait"]
        [::std::mem::offset_of!(spa_system_methods, pollfd_wait) - 88usize];
    ["Offset of field: spa_system_methods::timerfd_create"]
        [::std::mem::offset_of!(spa_system_methods, timerfd_create) - 96usize];
    ["Offset of field: spa_system_methods::timerfd_settime"]
        [::std::mem::offset_of!(spa_system_methods, timerfd_settime) - 104usize];
    ["Offset of field: spa_system_methods::timerfd_gettime"]
        [::std::mem::offset_of!(spa_system_methods, timerfd_gettime) - 112usize];
    ["Offset of field: spa_system_methods::timerfd_read"]
        [::std::mem::offset_of!(spa_system_methods, timerfd_read) - 120usize];
    ["Offset of field: spa_system_methods::eventfd_create"]
        [::std::mem::offset_of!(spa_system_methods, eventfd_create) - 128usize];
    ["Offset of field: spa_system_methods::eventfd_write"]
        [::std::mem::offset_of!(spa_system_methods, eventfd_write) - 136usize];
    ["Offset of field: spa_system_methods::eventfd_read"]
        [::std::mem::offset_of!(spa_system_methods, eventfd_read) - 144usize];
    ["Offset of field: spa_system_methods::signalfd_create"]
        [::std::mem::offset_of!(spa_system_methods, signalfd_create) - 152usize];
    ["Offset of field: spa_system_methods::signalfd_read"]
        [::std::mem::offset_of!(spa_system_methods, signalfd_read) - 160usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_loop {
    pub iface: spa_interface,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_loop"][::std::mem::size_of::<spa_loop>() - 32usize];
    ["Alignment of spa_loop"][::std::mem::align_of::<spa_loop>() - 8usize];
    ["Offset of field: spa_loop::iface"][::std::mem::offset_of!(spa_loop, iface) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_loop_control {
    pub iface: spa_interface,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_loop_control"][::std::mem::size_of::<spa_loop_control>() - 32usize];
    ["Alignment of spa_loop_control"][::std::mem::align_of::<spa_loop_control>() - 8usize];
    ["Offset of field: spa_loop_control::iface"]
        [::std::mem::offset_of!(spa_loop_control, iface) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_loop_utils {
    pub iface: spa_interface,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_loop_utils"][::std::mem::size_of::<spa_loop_utils>() - 32usize];
    ["Alignment of spa_loop_utils"][::std::mem::align_of::<spa_loop_utils>() - 8usize];
    ["Offset of field: spa_loop_utils::iface"]
        [::std::mem::offset_of!(spa_loop_utils, iface) - 0usize];
};
pub type spa_source_func_t = ::std::option::Option<unsafe extern "C" fn(source: *mut spa_source)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_source {
    pub loop_: *mut spa_loop,
    pub func: spa_source_func_t,
    pub data: *mut ::std::os::raw::c_void,
    pub fd: ::std::os::raw::c_int,
    pub mask: u32,
    pub rmask: u32,
    pub priv_: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_source"][::std::mem::size_of::<spa_source>() - 48usize];
    ["Alignment of spa_source"][::std::mem::align_of::<spa_source>() - 8usize];
    ["Offset of field: spa_source::loop_"][::std::mem::offset_of!(spa_source, loop_) - 0usize];
    ["Offset of field: spa_source::func"][::std::mem::offset_of!(spa_source, func) - 8usize];
    ["Offset of field: spa_source::data"][::std::mem::offset_of!(spa_source, data) - 16usize];
    ["Offset of field: spa_source::fd"][::std::mem::offset_of!(spa_source, fd) - 24usize];
    ["Offset of field: spa_source::mask"][::std::mem::offset_of!(spa_source, mask) - 28usize];
    ["Offset of field: spa_source::rmask"][::std::mem::offset_of!(spa_source, rmask) - 32usize];
    ["Offset of field: spa_source::priv_"][::std::mem::offset_of!(spa_source, priv_) - 40usize];
};
pub type spa_invoke_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        loop_: *mut spa_loop,
        async_: bool,
        seq: u32,
        data: *const ::std::os::raw::c_void,
        size: usize,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Register sources and work items to an event loop"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_loop_methods {
    pub version: u32,
    #[doc = " Add a source to the loop. Must be called from the loop's own thread.\n\n \\param[in] object The callbacks data.\n \\param[in] source The source.\n \\return 0 on success, negative errno-style value on failure."]
    pub add_source: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            source: *mut spa_source,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Update the source io mask. Must be called from the loop's own thread.\n\n \\param[in] object The callbacks data.\n \\param[in] source The source.\n \\return 0 on success, negative errno-style value on failure."]
    pub update_source: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            source: *mut spa_source,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Remove a source from the loop. Must be called from the loop's own thread.\n\n \\param[in] object The callbacks data.\n \\param[in] source The source.\n \\return 0 on success, negative errno-style value on failure."]
    pub remove_source: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            source: *mut spa_source,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Invoke a function in the context of this loop.\n May be called from any thread and multiple threads at the same time.\n If called from the loop's thread, all callbacks previously queued with\n invoke() will be run synchronously, which might cause unexpected\n reentrancy problems.\n\n \\param[in] object The callbacks data.\n \\param func The function to be invoked.\n \\param seq An opaque sequence number. This will be made\n            available to func.\n \\param[in] data Data that will be copied into the internal ring buffer and made\n             available to func. Because this data is copied, it is okay to\n             pass a pointer to a local variable, but do not pass a pointer to\n             an object that has identity.\n \\param size The size of data to copy.\n \\param block If \\true, do not return until func has been called. Otherwise,\n              returns immediately. Passing \\true does not risk a deadlock because\n              the data thread is never allowed to wait on any other thread.\n \\param user_data An opaque pointer passed to func.\n \\return `-EPIPE` if the internal ring buffer filled up,\n         if block is \\false, 0 if seq was SPA_ID_INVALID or\n         seq with the ASYNC flag set\n         or the return value of func otherwise."]
    pub invoke: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            func: spa_invoke_func_t,
            seq: u32,
            data: *const ::std::os::raw::c_void,
            size: usize,
            block: bool,
            user_data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_loop_methods"][::std::mem::size_of::<spa_loop_methods>() - 40usize];
    ["Alignment of spa_loop_methods"][::std::mem::align_of::<spa_loop_methods>() - 8usize];
    ["Offset of field: spa_loop_methods::version"]
        [::std::mem::offset_of!(spa_loop_methods, version) - 0usize];
    ["Offset of field: spa_loop_methods::add_source"]
        [::std::mem::offset_of!(spa_loop_methods, add_source) - 8usize];
    ["Offset of field: spa_loop_methods::update_source"]
        [::std::mem::offset_of!(spa_loop_methods, update_source) - 16usize];
    ["Offset of field: spa_loop_methods::remove_source"]
        [::std::mem::offset_of!(spa_loop_methods, remove_source) - 24usize];
    ["Offset of field: spa_loop_methods::invoke"]
        [::std::mem::offset_of!(spa_loop_methods, invoke) - 32usize];
};
#[doc = " Control hooks. These hooks can't be removed from their\n  callbacks and must be removed from a safe place (when the loop\n  is not running or when it is locked)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_loop_control_hooks {
    pub version: u32,
    #[doc = " Executed right before waiting for events. It is typically used to\n release locks."]
    pub before: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " Executed right after waiting for events. It is typically used to\n reacquire locks."]
    pub after: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_loop_control_hooks"][::std::mem::size_of::<spa_loop_control_hooks>() - 24usize];
    ["Alignment of spa_loop_control_hooks"]
        [::std::mem::align_of::<spa_loop_control_hooks>() - 8usize];
    ["Offset of field: spa_loop_control_hooks::version"]
        [::std::mem::offset_of!(spa_loop_control_hooks, version) - 0usize];
    ["Offset of field: spa_loop_control_hooks::before"]
        [::std::mem::offset_of!(spa_loop_control_hooks, before) - 8usize];
    ["Offset of field: spa_loop_control_hooks::after"]
        [::std::mem::offset_of!(spa_loop_control_hooks, after) - 16usize];
};
#[doc = " Control an event loop\n\n The event loop control function provide API to run the event loop.\n\n The below (pseudo)code is a minimal example outlining the use of the loop\n control:\n \\code{.c}\n spa_loop_control_enter(loop);\n while (running) {\n   spa_loop_control_iterate(loop, -1);\n }\n spa_loop_control_leave(loop);\n \\endcode\n\n It is also possible to add the loop to an existing event loop by using the\n spa_loop_control_get_fd() call. This fd will become readable when activity\n has been detected on the sources in the loop. spa_loop_control_iterate() with\n a 0 timeout should be called to process the pending sources.\n\n spa_loop_control_enter() and spa_loop_control_leave() should be called once\n from the thread that will run the iterate() function."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_loop_control_methods {
    pub version: u32,
    #[doc = " get the loop fd\n \\param object the control to query\n\n Get the fd of this loop control. This fd will be readable when a\n source in the loop has activity. The user should call iterate()\n with a 0 timeout to schedule one iteration of the loop and dispatch\n the sources.\n \\return the fd of the loop"]
    pub get_fd: ::std::option::Option<
        unsafe extern "C" fn(object: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    #[doc = " Add a hook\n \\param object the control to change\n \\param hooks the hooks to add\n\n Adds hooks to the loop controlled by \\a ctrl."]
    pub add_hook: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            hook: *mut spa_hook,
            hooks: *const spa_loop_control_hooks,
            data: *mut ::std::os::raw::c_void,
        ),
    >,
    #[doc = " Enter a loop\n \\param object the control\n\n This function should be called before calling iterate and is\n typically used to capture the thread that this loop will run in.\n It should ideally be called once from the thread that will run\n the loop."]
    pub enter: ::std::option::Option<unsafe extern "C" fn(object: *mut ::std::os::raw::c_void)>,
    #[doc = " Leave a loop\n \\param object the control\n\n It should ideally be called once after calling iterate when the loop\n will no longer be iterated from the thread that called enter()."]
    pub leave: ::std::option::Option<unsafe extern "C" fn(object: *mut ::std::os::raw::c_void)>,
    #[doc = " Perform one iteration of the loop.\n \\param ctrl the control\n \\param timeout an optional timeout in milliseconds.\n\t0 for no timeout, -1 for infinite timeout.\n\n This function will block\n up to \\a timeout milliseconds and then dispatch the fds with activity.\n The number of dispatched fds is returned."]
    pub iterate: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            timeout: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Check context of the loop\n \\param ctrl the control\n\n This function will check if the current thread is currently the\n one that did the enter call. Since version 1:1.\n\n returns 1 on success, 0 or negative errno value on error."]
    pub check: ::std::option::Option<
        unsafe extern "C" fn(object: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_loop_control_methods"]
        [::std::mem::size_of::<spa_loop_control_methods>() - 56usize];
    ["Alignment of spa_loop_control_methods"]
        [::std::mem::align_of::<spa_loop_control_methods>() - 8usize];
    ["Offset of field: spa_loop_control_methods::version"]
        [::std::mem::offset_of!(spa_loop_control_methods, version) - 0usize];
    ["Offset of field: spa_loop_control_methods::get_fd"]
        [::std::mem::offset_of!(spa_loop_control_methods, get_fd) - 8usize];
    ["Offset of field: spa_loop_control_methods::add_hook"]
        [::std::mem::offset_of!(spa_loop_control_methods, add_hook) - 16usize];
    ["Offset of field: spa_loop_control_methods::enter"]
        [::std::mem::offset_of!(spa_loop_control_methods, enter) - 24usize];
    ["Offset of field: spa_loop_control_methods::leave"]
        [::std::mem::offset_of!(spa_loop_control_methods, leave) - 32usize];
    ["Offset of field: spa_loop_control_methods::iterate"]
        [::std::mem::offset_of!(spa_loop_control_methods, iterate) - 40usize];
    ["Offset of field: spa_loop_control_methods::check"]
        [::std::mem::offset_of!(spa_loop_control_methods, check) - 48usize];
};
pub type spa_source_io_func_t = ::std::option::Option<
    unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, fd: ::std::os::raw::c_int, mask: u32),
>;
pub type spa_source_idle_func_t =
    ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>;
pub type spa_source_event_func_t =
    ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, count: u64)>;
pub type spa_source_timer_func_t = ::std::option::Option<
    unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, expirations: u64),
>;
pub type spa_source_signal_func_t = ::std::option::Option<
    unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, signal_number: ::std::os::raw::c_int),
>;
#[doc = " Create sources for an event loop"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_loop_utils_methods {
    pub version: u32,
    pub add_io: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            fd: ::std::os::raw::c_int,
            mask: u32,
            close: bool,
            func: spa_source_io_func_t,
            data: *mut ::std::os::raw::c_void,
        ) -> *mut spa_source,
    >,
    pub update_io: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            source: *mut spa_source,
            mask: u32,
        ) -> ::std::os::raw::c_int,
    >,
    pub add_idle: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            enabled: bool,
            func: spa_source_idle_func_t,
            data: *mut ::std::os::raw::c_void,
        ) -> *mut spa_source,
    >,
    pub enable_idle: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            source: *mut spa_source,
            enabled: bool,
        ) -> ::std::os::raw::c_int,
    >,
    pub add_event: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            func: spa_source_event_func_t,
            data: *mut ::std::os::raw::c_void,
        ) -> *mut spa_source,
    >,
    pub signal_event: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            source: *mut spa_source,
        ) -> ::std::os::raw::c_int,
    >,
    pub add_timer: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            func: spa_source_timer_func_t,
            data: *mut ::std::os::raw::c_void,
        ) -> *mut spa_source,
    >,
    pub update_timer: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            source: *mut spa_source,
            value: *mut timespec,
            interval: *mut timespec,
            absolute: bool,
        ) -> ::std::os::raw::c_int,
    >,
    pub add_signal: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            signal_number: ::std::os::raw::c_int,
            func: spa_source_signal_func_t,
            data: *mut ::std::os::raw::c_void,
        ) -> *mut spa_source,
    >,
    #[doc = " destroy a source allocated with this interface. This function\n should only be called when the loop is not running or from the\n context of the running loop"]
    pub destroy_source: ::std::option::Option<
        unsafe extern "C" fn(object: *mut ::std::os::raw::c_void, source: *mut spa_source),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_loop_utils_methods"][::std::mem::size_of::<spa_loop_utils_methods>() - 88usize];
    ["Alignment of spa_loop_utils_methods"]
        [::std::mem::align_of::<spa_loop_utils_methods>() - 8usize];
    ["Offset of field: spa_loop_utils_methods::version"]
        [::std::mem::offset_of!(spa_loop_utils_methods, version) - 0usize];
    ["Offset of field: spa_loop_utils_methods::add_io"]
        [::std::mem::offset_of!(spa_loop_utils_methods, add_io) - 8usize];
    ["Offset of field: spa_loop_utils_methods::update_io"]
        [::std::mem::offset_of!(spa_loop_utils_methods, update_io) - 16usize];
    ["Offset of field: spa_loop_utils_methods::add_idle"]
        [::std::mem::offset_of!(spa_loop_utils_methods, add_idle) - 24usize];
    ["Offset of field: spa_loop_utils_methods::enable_idle"]
        [::std::mem::offset_of!(spa_loop_utils_methods, enable_idle) - 32usize];
    ["Offset of field: spa_loop_utils_methods::add_event"]
        [::std::mem::offset_of!(spa_loop_utils_methods, add_event) - 40usize];
    ["Offset of field: spa_loop_utils_methods::signal_event"]
        [::std::mem::offset_of!(spa_loop_utils_methods, signal_event) - 48usize];
    ["Offset of field: spa_loop_utils_methods::add_timer"]
        [::std::mem::offset_of!(spa_loop_utils_methods, add_timer) - 56usize];
    ["Offset of field: spa_loop_utils_methods::update_timer"]
        [::std::mem::offset_of!(spa_loop_utils_methods, update_timer) - 64usize];
    ["Offset of field: spa_loop_utils_methods::add_signal"]
        [::std::mem::offset_of!(spa_loop_utils_methods, add_signal) - 72usize];
    ["Offset of field: spa_loop_utils_methods::destroy_source"]
        [::std::mem::offset_of!(spa_loop_utils_methods, destroy_source) - 80usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_dbus {
    pub iface: spa_interface,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_dbus"][::std::mem::size_of::<spa_dbus>() - 32usize];
    ["Alignment of spa_dbus"][::std::mem::align_of::<spa_dbus>() - 8usize];
    ["Offset of field: spa_dbus::iface"][::std::mem::offset_of!(spa_dbus, iface) - 0usize];
};
#[doc = "< The login session bus"]
pub const spa_dbus_type_SPA_DBUS_TYPE_SESSION: spa_dbus_type = 0;
#[doc = "< The systemwide bus"]
pub const spa_dbus_type_SPA_DBUS_TYPE_SYSTEM: spa_dbus_type = 1;
#[doc = "< The bus that started us, if any"]
pub const spa_dbus_type_SPA_DBUS_TYPE_STARTER: spa_dbus_type = 2;
pub type spa_dbus_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_dbus_connection_events {
    pub version: u32,
    pub destroy: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    pub disconnected:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_dbus_connection_events"]
        [::std::mem::size_of::<spa_dbus_connection_events>() - 24usize];
    ["Alignment of spa_dbus_connection_events"]
        [::std::mem::align_of::<spa_dbus_connection_events>() - 8usize];
    ["Offset of field: spa_dbus_connection_events::version"]
        [::std::mem::offset_of!(spa_dbus_connection_events, version) - 0usize];
    ["Offset of field: spa_dbus_connection_events::destroy"]
        [::std::mem::offset_of!(spa_dbus_connection_events, destroy) - 8usize];
    ["Offset of field: spa_dbus_connection_events::disconnected"]
        [::std::mem::offset_of!(spa_dbus_connection_events, disconnected) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_dbus_connection {
    pub version: u32,
    #[doc = " Get the DBusConnection from a wrapper\n\n Note that the returned handle is closed and unref'd by spa_dbus\n immediately before emitting the asynchronous \"disconnected\" event.\n The caller must either deal with the invalidation, or keep an extra\n ref on the handle returned.\n\n \\param conn the spa_dbus_connection wrapper\n \\return a pointer of type DBusConnection"]
    pub get: ::std::option::Option<
        unsafe extern "C" fn(conn: *mut spa_dbus_connection) -> *mut ::std::os::raw::c_void,
    >,
    #[doc = " Destroy a dbus connection wrapper\n\n \\param conn the wrapper to destroy"]
    pub destroy: ::std::option::Option<unsafe extern "C" fn(conn: *mut spa_dbus_connection)>,
    #[doc = " Add a listener for events\n\n Since version 1"]
    pub add_listener: ::std::option::Option<
        unsafe extern "C" fn(
            conn: *mut spa_dbus_connection,
            listener: *mut spa_hook,
            events: *const spa_dbus_connection_events,
            data: *mut ::std::os::raw::c_void,
        ),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_dbus_connection"][::std::mem::size_of::<spa_dbus_connection>() - 32usize];
    ["Alignment of spa_dbus_connection"][::std::mem::align_of::<spa_dbus_connection>() - 8usize];
    ["Offset of field: spa_dbus_connection::version"]
        [::std::mem::offset_of!(spa_dbus_connection, version) - 0usize];
    ["Offset of field: spa_dbus_connection::get"]
        [::std::mem::offset_of!(spa_dbus_connection, get) - 8usize];
    ["Offset of field: spa_dbus_connection::destroy"]
        [::std::mem::offset_of!(spa_dbus_connection, destroy) - 16usize];
    ["Offset of field: spa_dbus_connection::add_listener"]
        [::std::mem::offset_of!(spa_dbus_connection, add_listener) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_dbus_methods {
    pub version: u32,
    #[doc = " Get a new connection wrapper for the given bus type.\n\n The connection wrapper is completely configured to operate\n in the main context of the handle that manages the spa_dbus\n interface.\n\n \\param dbus the dbus manager\n \\param type the bus type to wrap\n \\param error location for the DBusError\n \\return a new dbus connection wrapper or NULL on error"]
    pub get_connection: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            type_: spa_dbus_type,
        ) -> *mut spa_dbus_connection,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_dbus_methods"][::std::mem::size_of::<spa_dbus_methods>() - 16usize];
    ["Alignment of spa_dbus_methods"][::std::mem::align_of::<spa_dbus_methods>() - 8usize];
    ["Offset of field: spa_dbus_methods::version"]
        [::std::mem::offset_of!(spa_dbus_methods, version) - 0usize];
    ["Offset of field: spa_dbus_methods::get_connection"]
        [::std::mem::offset_of!(spa_dbus_methods, get_connection) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_i18n {
    pub iface: spa_interface,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_i18n"][::std::mem::size_of::<spa_i18n>() - 32usize];
    ["Alignment of spa_i18n"][::std::mem::align_of::<spa_i18n>() - 8usize];
    ["Offset of field: spa_i18n::iface"][::std::mem::offset_of!(spa_i18n, iface) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_i18n_methods {
    pub version: u32,
    #[doc = " Translate a message\n\n \\param object the i18n interface\n \\param msgid the message\n \\return a translated message"]
    pub text: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            msgid: *const ::std::os::raw::c_char,
        ) -> *const ::std::os::raw::c_char,
    >,
    #[doc = " Translate a message for a number\n\n \\param object the i18n interface\n \\param msgid the message to translate\n \\param msgid_plural the plural form of \\a msgid\n \\param n a number\n \\return a translated message for the number \\a n"]
    pub ntext: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            msgid: *const ::std::os::raw::c_char,
            msgid_plural: *const ::std::os::raw::c_char,
            n: ::std::os::raw::c_ulong,
        ) -> *const ::std::os::raw::c_char,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_i18n_methods"][::std::mem::size_of::<spa_i18n_methods>() - 24usize];
    ["Alignment of spa_i18n_methods"][::std::mem::align_of::<spa_i18n_methods>() - 8usize];
    ["Offset of field: spa_i18n_methods::version"]
        [::std::mem::offset_of!(spa_i18n_methods, version) - 0usize];
    ["Offset of field: spa_i18n_methods::text"]
        [::std::mem::offset_of!(spa_i18n_methods, text) - 8usize];
    ["Offset of field: spa_i18n_methods::ntext"]
        [::std::mem::offset_of!(spa_i18n_methods, ntext) - 16usize];
};
#[doc = " \\addtogroup spa_handle\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_handle {
    pub version: u32,
    #[doc = " Get the interface provided by \\a handle with \\a type.\n\n \\a interface is always a struct spa_interface but depending on\n \\a type, the struct might contain other information.\n\n \\param handle a spa_handle\n \\param type the interface type\n \\param iface result to hold the interface.\n \\return 0 on success\n         -ENOTSUP when there are no interfaces\n         -EINVAL when handle or info is NULL"]
    pub get_interface: ::std::option::Option<
        unsafe extern "C" fn(
            handle: *mut spa_handle,
            type_: *const ::std::os::raw::c_char,
            iface: *mut *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Clean up the memory of \\a handle. After this, \\a handle should not be used\n anymore.\n\n \\param handle a pointer to memory\n \\return 0 on success"]
    pub clear: ::std::option::Option<
        unsafe extern "C" fn(handle: *mut spa_handle) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_handle"][::std::mem::size_of::<spa_handle>() - 24usize];
    ["Alignment of spa_handle"][::std::mem::align_of::<spa_handle>() - 8usize];
    ["Offset of field: spa_handle::version"][::std::mem::offset_of!(spa_handle, version) - 0usize];
    ["Offset of field: spa_handle::get_interface"]
        [::std::mem::offset_of!(spa_handle, get_interface) - 8usize];
    ["Offset of field: spa_handle::clear"][::std::mem::offset_of!(spa_handle, clear) - 16usize];
};
#[doc = " This structure lists the information about available interfaces on\n handles."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_interface_info {
    pub type_: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_interface_info"][::std::mem::size_of::<spa_interface_info>() - 8usize];
    ["Alignment of spa_interface_info"][::std::mem::align_of::<spa_interface_info>() - 8usize];
    ["Offset of field: spa_interface_info::type_"]
        [::std::mem::offset_of!(spa_interface_info, type_) - 0usize];
};
#[doc = " Extra supporting infrastructure passed to the init() function of\n a factory. It can be extra information or interfaces such as logging."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_support {
    pub type_: *const ::std::os::raw::c_char,
    pub data: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_support"][::std::mem::size_of::<spa_support>() - 16usize];
    ["Alignment of spa_support"][::std::mem::align_of::<spa_support>() - 8usize];
    ["Offset of field: spa_support::type_"][::std::mem::offset_of!(spa_support, type_) - 0usize];
    ["Offset of field: spa_support::data"][::std::mem::offset_of!(spa_support, data) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_handle_factory {
    pub version: u32,
    #[doc = " The name of the factory contains a logical name that describes\n the function of the handle. Other plugins might contain an alternative\n implementation with the same name.\n\n See utils/names.h for the list of standard names.\n\n Examples include:\n\n  api.alsa.pcm.sink: an object to write PCM samples to an alsa PLAYBACK\n\t\t\tdevice\n  api.v4l2.source: an object to read from a v4l2 source."]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " Extra information about the handles of this factory."]
    pub info: *const spa_dict,
    #[doc = " Get the size of handles from this factory.\n\n \\param factory a spa_handle_factory\n \\param params extra parameters that determine the size of the\n handle."]
    pub get_size: ::std::option::Option<
        unsafe extern "C" fn(factory: *const spa_handle_factory, params: *const spa_dict) -> usize,
    >,
    #[doc = " Initialize an instance of this factory. The caller should allocate\n memory at least size bytes and pass this as \\a handle.\n\n \\a support can optionally contain extra interfaces or data items that the\n plugin can use such as a logger.\n\n \\param factory a spa_handle_factory\n \\param handle a pointer to memory\n \\param info extra handle specific information, usually obtained\n        from a spa_device. This can be used to configure the handle.\n \\param support support items\n \\param n_support number of elements in \\a support\n \\return 0 on success\n\t   < 0 errno type error"]
    pub init: ::std::option::Option<
        unsafe extern "C" fn(
            factory: *const spa_handle_factory,
            handle: *mut spa_handle,
            info: *const spa_dict,
            support: *const spa_support,
            n_support: u32,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " spa_handle_factory::enum_interface_info:\n \\param factory: a #spa_handle_factory\n \\param info: result to hold spa_interface_info.\n \\param index: index to keep track of the enumeration, 0 for first item\n\n Enumerate the interface information for \\a factory.\n\n \\return 1 when an item is available\n\t   0 when no more items are available\n\t   < 0 errno type error"]
    pub enum_interface_info: ::std::option::Option<
        unsafe extern "C" fn(
            factory: *const spa_handle_factory,
            info: *mut *const spa_interface_info,
            index: *mut u32,
        ) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_handle_factory"][::std::mem::size_of::<spa_handle_factory>() - 48usize];
    ["Alignment of spa_handle_factory"][::std::mem::align_of::<spa_handle_factory>() - 8usize];
    ["Offset of field: spa_handle_factory::version"]
        [::std::mem::offset_of!(spa_handle_factory, version) - 0usize];
    ["Offset of field: spa_handle_factory::name"]
        [::std::mem::offset_of!(spa_handle_factory, name) - 8usize];
    ["Offset of field: spa_handle_factory::info"]
        [::std::mem::offset_of!(spa_handle_factory, info) - 16usize];
    ["Offset of field: spa_handle_factory::get_size"]
        [::std::mem::offset_of!(spa_handle_factory, get_size) - 24usize];
    ["Offset of field: spa_handle_factory::init"]
        [::std::mem::offset_of!(spa_handle_factory, init) - 32usize];
    ["Offset of field: spa_handle_factory::enum_interface_info"]
        [::std::mem::offset_of!(spa_handle_factory, enum_interface_info) - 40usize];
};
#[doc = " The function signature of the entry point in a plugin.\n\n \\param factory a location to hold the factory result\n \\param index index to keep track of the enumeration\n \\return 1 on success\n         0 when there are no more factories\n         -EINVAL when factory is NULL"]
pub type spa_handle_factory_enum_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        factory: *mut *const spa_handle_factory,
        index: *mut u32,
    ) -> ::std::os::raw::c_int,
>;
unsafe extern "C" {
    #[doc = " The entry point in a plugin.\n\n \\param factory a location to hold the factory result\n \\param index index to keep track of the enumeration\n \\return 1 on success\n\t   0 when no more items are available\n\t   < 0 errno type error"]
    pub fn spa_handle_factory_enum(
        factory: *mut *const spa_handle_factory,
        index: *mut u32,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_plugin_loader {
    pub iface: spa_interface,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_plugin_loader"][::std::mem::size_of::<spa_plugin_loader>() - 32usize];
    ["Alignment of spa_plugin_loader"][::std::mem::align_of::<spa_plugin_loader>() - 8usize];
    ["Offset of field: spa_plugin_loader::iface"]
        [::std::mem::offset_of!(spa_plugin_loader, iface) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_plugin_loader_methods {
    pub version: u32,
    #[doc = " Load a SPA plugin.\n\n \\param factory_name Plugin factory name\n \\param info Info dictionary for plugin. NULL if none.\n \\return plugin handle, or NULL on error"]
    pub load: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            factory_name: *const ::std::os::raw::c_char,
            info: *const spa_dict,
        ) -> *mut spa_handle,
    >,
    #[doc = " Unload a SPA plugin.\n\n \\param handle Plugin handle.\n \\return 0 on success, < 0 on error"]
    pub unload: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            handle: *mut spa_handle,
        ) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_plugin_loader_methods"]
        [::std::mem::size_of::<spa_plugin_loader_methods>() - 24usize];
    ["Alignment of spa_plugin_loader_methods"]
        [::std::mem::align_of::<spa_plugin_loader_methods>() - 8usize];
    ["Offset of field: spa_plugin_loader_methods::version"]
        [::std::mem::offset_of!(spa_plugin_loader_methods, version) - 0usize];
    ["Offset of field: spa_plugin_loader_methods::load"]
        [::std::mem::offset_of!(spa_plugin_loader_methods, load) - 8usize];
    ["Offset of field: spa_plugin_loader_methods::unload"]
        [::std::mem::offset_of!(spa_plugin_loader_methods, unload) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_thread {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_thread_utils {
    pub iface: spa_interface,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_thread_utils"][::std::mem::size_of::<spa_thread_utils>() - 32usize];
    ["Alignment of spa_thread_utils"][::std::mem::align_of::<spa_thread_utils>() - 8usize];
    ["Offset of field: spa_thread_utils::iface"]
        [::std::mem::offset_of!(spa_thread_utils, iface) - 0usize];
};
#[doc = " thread utils"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_thread_utils_methods {
    pub version: u32,
    #[doc = " create a new thread that runs \\a start with \\a arg"]
    pub create: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            props: *const spa_dict,
            start: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut ::std::os::raw::c_void,
                ) -> *mut ::std::os::raw::c_void,
            >,
            arg: *mut ::std::os::raw::c_void,
        ) -> *mut spa_thread,
    >,
    #[doc = " stop and join a thread"]
    pub join: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            thread: *mut spa_thread,
            retval: *mut *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " get realtime priority range for threads created with \\a props"]
    pub get_rt_range: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            props: *const spa_dict,
            min: *mut ::std::os::raw::c_int,
            max: *mut ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " acquire realtime priority, a priority of -1 refers to the priority\n configured in the realtime module"]
    pub acquire_rt: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            thread: *mut spa_thread,
            priority: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " drop realtime priority"]
    pub drop_rt: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            thread: *mut spa_thread,
        ) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_thread_utils_methods"]
        [::std::mem::size_of::<spa_thread_utils_methods>() - 48usize];
    ["Alignment of spa_thread_utils_methods"]
        [::std::mem::align_of::<spa_thread_utils_methods>() - 8usize];
    ["Offset of field: spa_thread_utils_methods::version"]
        [::std::mem::offset_of!(spa_thread_utils_methods, version) - 0usize];
    ["Offset of field: spa_thread_utils_methods::create"]
        [::std::mem::offset_of!(spa_thread_utils_methods, create) - 8usize];
    ["Offset of field: spa_thread_utils_methods::join"]
        [::std::mem::offset_of!(spa_thread_utils_methods, join) - 16usize];
    ["Offset of field: spa_thread_utils_methods::get_rt_range"]
        [::std::mem::offset_of!(spa_thread_utils_methods, get_rt_range) - 24usize];
    ["Offset of field: spa_thread_utils_methods::acquire_rt"]
        [::std::mem::offset_of!(spa_thread_utils_methods, acquire_rt) - 32usize];
    ["Offset of field: spa_thread_utils_methods::drop_rt"]
        [::std::mem::offset_of!(spa_thread_utils_methods, drop_rt) - 40usize];
};
pub type float_t = f32;
pub type double_t = f64;
unsafe extern "C" {
    pub fn __fpclassify(__value: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __signbit(__value: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __isinf(__value: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __finite(__value: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __isnan(__value: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __iseqsig(__x: f64, __y: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __issignaling(__value: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn acos(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __acos(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn asin(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __asin(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn atan(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __atan(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn atan2(__y: f64, __x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __atan2(__y: f64, __x: f64) -> f64;
}
unsafe extern "C" {
    pub fn cos(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __cos(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn sin(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __sin(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn tan(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __tan(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn cosh(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __cosh(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn sinh(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __sinh(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn tanh(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __tanh(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn acosh(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __acosh(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn asinh(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __asinh(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn atanh(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __atanh(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn exp(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __exp(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn frexp(__x: f64, __exponent: *mut ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    pub fn __frexp(__x: f64, __exponent: *mut ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    pub fn ldexp(__x: f64, __exponent: ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    pub fn __ldexp(__x: f64, __exponent: ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    pub fn log(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __log(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn log10(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __log10(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn modf(__x: f64, __iptr: *mut f64) -> f64;
}
unsafe extern "C" {
    pub fn __modf(__x: f64, __iptr: *mut f64) -> f64;
}
unsafe extern "C" {
    pub fn expm1(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __expm1(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn log1p(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __log1p(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn logb(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __logb(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn exp2(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __exp2(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn log2(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __log2(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn pow(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __pow(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn sqrt(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __sqrt(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn hypot(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __hypot(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn cbrt(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __cbrt(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn ceil(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __ceil(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn fabs(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __fabs(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn floor(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __floor(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn fmod(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __fmod(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn isinf(__value: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn finite(__value: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn drem(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __drem(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn significand(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __significand(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn copysign(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __copysign(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn nan(__tagb: *const ::std::os::raw::c_char) -> f64;
}
unsafe extern "C" {
    pub fn __nan(__tagb: *const ::std::os::raw::c_char) -> f64;
}
unsafe extern "C" {
    pub fn isnan(__value: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn j0(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn __j0(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn j1(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn __j1(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn __jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn y0(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn __y0(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn y1(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn __y1(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn __yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn erf(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn __erf(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn erfc(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn __erfc(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn lgamma(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn __lgamma(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn tgamma(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn __tgamma(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn gamma(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn __gamma(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn lgamma_r(arg1: f64, __signgamp: *mut ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    pub fn __lgamma_r(arg1: f64, __signgamp: *mut ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    pub fn rint(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __rint(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn nextafter(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __nextafter(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn nexttoward(__x: f64, __y: u128) -> f64;
}
unsafe extern "C" {
    pub fn __nexttoward(__x: f64, __y: u128) -> f64;
}
unsafe extern "C" {
    pub fn remainder(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __remainder(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn scalbn(__x: f64, __n: ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    pub fn __scalbn(__x: f64, __n: ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    pub fn ilogb(__x: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __ilogb(__x: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn scalbln(__x: f64, __n: ::std::os::raw::c_long) -> f64;
}
unsafe extern "C" {
    pub fn __scalbln(__x: f64, __n: ::std::os::raw::c_long) -> f64;
}
unsafe extern "C" {
    pub fn nearbyint(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __nearbyint(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn round(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __round(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn trunc(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __trunc(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn remquo(__x: f64, __y: f64, __quo: *mut ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    pub fn __remquo(__x: f64, __y: f64, __quo: *mut ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    pub fn lrint(__x: f64) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn __lrint(__x: f64) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn llrint(__x: f64) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn __llrint(__x: f64) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn lround(__x: f64) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn __lround(__x: f64) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn llround(__x: f64) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn __llround(__x: f64) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn fdim(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __fdim(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn fmax(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __fmax(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn fmin(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __fmin(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn fma(__x: f64, __y: f64, __z: f64) -> f64;
}
unsafe extern "C" {
    pub fn __fma(__x: f64, __y: f64, __z: f64) -> f64;
}
unsafe extern "C" {
    pub fn scalb(__x: f64, __n: f64) -> f64;
}
unsafe extern "C" {
    pub fn __scalb(__x: f64, __n: f64) -> f64;
}
unsafe extern "C" {
    pub fn __fpclassifyf(__value: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __signbitf(__value: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __isinff(__value: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __finitef(__value: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __isnanf(__value: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __iseqsigf(__x: f32, __y: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __issignalingf(__value: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn acosf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __acosf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn asinf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __asinf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn atanf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __atanf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn atan2f(__y: f32, __x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __atan2f(__y: f32, __x: f32) -> f32;
}
unsafe extern "C" {
    pub fn cosf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __cosf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn sinf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __sinf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn tanf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __tanf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn coshf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __coshf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn sinhf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __sinhf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn tanhf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __tanhf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn acoshf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __acoshf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn asinhf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __asinhf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn atanhf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __atanhf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn expf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __expf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn frexpf(__x: f32, __exponent: *mut ::std::os::raw::c_int) -> f32;
}
unsafe extern "C" {
    pub fn __frexpf(__x: f32, __exponent: *mut ::std::os::raw::c_int) -> f32;
}
unsafe extern "C" {
    pub fn ldexpf(__x: f32, __exponent: ::std::os::raw::c_int) -> f32;
}
unsafe extern "C" {
    pub fn __ldexpf(__x: f32, __exponent: ::std::os::raw::c_int) -> f32;
}
unsafe extern "C" {
    pub fn logf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __logf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn log10f(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __log10f(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn modff(__x: f32, __iptr: *mut f32) -> f32;
}
unsafe extern "C" {
    pub fn __modff(__x: f32, __iptr: *mut f32) -> f32;
}
unsafe extern "C" {
    pub fn expm1f(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __expm1f(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn log1pf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __log1pf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn logbf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __logbf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn exp2f(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __exp2f(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn log2f(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __log2f(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn powf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __powf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn sqrtf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __sqrtf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn hypotf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __hypotf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn cbrtf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __cbrtf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn ceilf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __ceilf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn fabsf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __fabsf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn floorf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __floorf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn fmodf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __fmodf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn isinff(__value: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn finitef(__value: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn dremf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __dremf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn significandf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __significandf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn copysignf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __copysignf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn nanf(__tagb: *const ::std::os::raw::c_char) -> f32;
}
unsafe extern "C" {
    pub fn __nanf(__tagb: *const ::std::os::raw::c_char) -> f32;
}
unsafe extern "C" {
    pub fn isnanf(__value: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn j0f(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn __j0f(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn j1f(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn __j1f(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn jnf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
unsafe extern "C" {
    pub fn __jnf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
unsafe extern "C" {
    pub fn y0f(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn __y0f(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn y1f(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn __y1f(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn ynf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
unsafe extern "C" {
    pub fn __ynf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
unsafe extern "C" {
    pub fn erff(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn __erff(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn erfcf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn __erfcf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn lgammaf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn __lgammaf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn tgammaf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn __tgammaf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn gammaf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn __gammaf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn lgammaf_r(arg1: f32, __signgamp: *mut ::std::os::raw::c_int) -> f32;
}
unsafe extern "C" {
    pub fn __lgammaf_r(arg1: f32, __signgamp: *mut ::std::os::raw::c_int) -> f32;
}
unsafe extern "C" {
    pub fn rintf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __rintf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn nextafterf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __nextafterf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn nexttowardf(__x: f32, __y: u128) -> f32;
}
unsafe extern "C" {
    pub fn __nexttowardf(__x: f32, __y: u128) -> f32;
}
unsafe extern "C" {
    pub fn remainderf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __remainderf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn scalbnf(__x: f32, __n: ::std::os::raw::c_int) -> f32;
}
unsafe extern "C" {
    pub fn __scalbnf(__x: f32, __n: ::std::os::raw::c_int) -> f32;
}
unsafe extern "C" {
    pub fn ilogbf(__x: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __ilogbf(__x: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn scalblnf(__x: f32, __n: ::std::os::raw::c_long) -> f32;
}
unsafe extern "C" {
    pub fn __scalblnf(__x: f32, __n: ::std::os::raw::c_long) -> f32;
}
unsafe extern "C" {
    pub fn nearbyintf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __nearbyintf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn roundf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __roundf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn truncf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __truncf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn remquof(__x: f32, __y: f32, __quo: *mut ::std::os::raw::c_int) -> f32;
}
unsafe extern "C" {
    pub fn __remquof(__x: f32, __y: f32, __quo: *mut ::std::os::raw::c_int) -> f32;
}
unsafe extern "C" {
    pub fn lrintf(__x: f32) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn __lrintf(__x: f32) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn llrintf(__x: f32) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn __llrintf(__x: f32) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn lroundf(__x: f32) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn __lroundf(__x: f32) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn llroundf(__x: f32) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn __llroundf(__x: f32) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn fdimf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __fdimf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn fmaxf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __fmaxf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn fminf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __fminf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn fmaf(__x: f32, __y: f32, __z: f32) -> f32;
}
unsafe extern "C" {
    pub fn __fmaf(__x: f32, __y: f32, __z: f32) -> f32;
}
unsafe extern "C" {
    pub fn scalbf(__x: f32, __n: f32) -> f32;
}
unsafe extern "C" {
    pub fn __scalbf(__x: f32, __n: f32) -> f32;
}
unsafe extern "C" {
    pub fn __fpclassifyl(__value: u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __signbitl(__value: u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __isinfl(__value: u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __finitel(__value: u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __isnanl(__value: u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __iseqsigl(__x: u128, __y: u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __issignalingl(__value: u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn acosl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __acosl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn asinl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __asinl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn atanl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __atanl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn atan2l(__y: u128, __x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __atan2l(__y: u128, __x: u128) -> u128;
}
unsafe extern "C" {
    pub fn cosl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __cosl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn sinl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __sinl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn tanl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __tanl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn coshl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __coshl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn sinhl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __sinhl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn tanhl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __tanhl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn acoshl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __acoshl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn asinhl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __asinhl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn atanhl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __atanhl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn expl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __expl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn frexpl(__x: u128, __exponent: *mut ::std::os::raw::c_int) -> u128;
}
unsafe extern "C" {
    pub fn __frexpl(__x: u128, __exponent: *mut ::std::os::raw::c_int) -> u128;
}
unsafe extern "C" {
    pub fn ldexpl(__x: u128, __exponent: ::std::os::raw::c_int) -> u128;
}
unsafe extern "C" {
    pub fn __ldexpl(__x: u128, __exponent: ::std::os::raw::c_int) -> u128;
}
unsafe extern "C" {
    pub fn logl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __logl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn log10l(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __log10l(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn modfl(__x: u128, __iptr: *mut u128) -> u128;
}
unsafe extern "C" {
    pub fn __modfl(__x: u128, __iptr: *mut u128) -> u128;
}
unsafe extern "C" {
    pub fn expm1l(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __expm1l(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn log1pl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __log1pl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn logbl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __logbl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn exp2l(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __exp2l(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn log2l(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __log2l(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn powl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __powl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn sqrtl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __sqrtl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn hypotl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __hypotl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn cbrtl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __cbrtl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn ceill(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __ceill(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn fabsl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __fabsl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn floorl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __floorl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn fmodl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __fmodl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn isinfl(__value: u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn finitel(__value: u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn dreml(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __dreml(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn significandl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __significandl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn copysignl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __copysignl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn nanl(__tagb: *const ::std::os::raw::c_char) -> u128;
}
unsafe extern "C" {
    pub fn __nanl(__tagb: *const ::std::os::raw::c_char) -> u128;
}
unsafe extern "C" {
    pub fn isnanl(__value: u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn j0l(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn __j0l(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn j1l(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn __j1l(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn jnl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
unsafe extern "C" {
    pub fn __jnl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
unsafe extern "C" {
    pub fn y0l(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn __y0l(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn y1l(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn __y1l(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn ynl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
unsafe extern "C" {
    pub fn __ynl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
unsafe extern "C" {
    pub fn erfl(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn __erfl(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn erfcl(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn __erfcl(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn lgammal(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn __lgammal(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn tgammal(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn __tgammal(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn gammal(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn __gammal(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn lgammal_r(arg1: u128, __signgamp: *mut ::std::os::raw::c_int) -> u128;
}
unsafe extern "C" {
    pub fn __lgammal_r(arg1: u128, __signgamp: *mut ::std::os::raw::c_int) -> u128;
}
unsafe extern "C" {
    pub fn rintl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __rintl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn nextafterl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __nextafterl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn nexttowardl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __nexttowardl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn remainderl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __remainderl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn scalbnl(__x: u128, __n: ::std::os::raw::c_int) -> u128;
}
unsafe extern "C" {
    pub fn __scalbnl(__x: u128, __n: ::std::os::raw::c_int) -> u128;
}
unsafe extern "C" {
    pub fn ilogbl(__x: u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __ilogbl(__x: u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn scalblnl(__x: u128, __n: ::std::os::raw::c_long) -> u128;
}
unsafe extern "C" {
    pub fn __scalblnl(__x: u128, __n: ::std::os::raw::c_long) -> u128;
}
unsafe extern "C" {
    pub fn nearbyintl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __nearbyintl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn roundl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __roundl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn truncl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __truncl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn remquol(__x: u128, __y: u128, __quo: *mut ::std::os::raw::c_int) -> u128;
}
unsafe extern "C" {
    pub fn __remquol(__x: u128, __y: u128, __quo: *mut ::std::os::raw::c_int) -> u128;
}
unsafe extern "C" {
    pub fn lrintl(__x: u128) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn __lrintl(__x: u128) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn llrintl(__x: u128) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn __llrintl(__x: u128) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn lroundl(__x: u128) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn __lroundl(__x: u128) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn llroundl(__x: u128) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn __llroundl(__x: u128) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn fdiml(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __fdiml(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn fmaxl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __fmaxl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn fminl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __fminl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn fmal(__x: u128, __y: u128, __z: u128) -> u128;
}
unsafe extern "C" {
    pub fn __fmal(__x: u128, __y: u128, __z: u128) -> u128;
}
unsafe extern "C" {
    pub fn scalbl(__x: u128, __n: u128) -> u128;
}
unsafe extern "C" {
    pub fn __scalbl(__x: u128, __n: u128) -> u128;
}
unsafe extern "C" {
    pub static mut signgam: ::std::os::raw::c_int;
}
pub const FP_NAN: _bindgen_ty_16 = 0;
pub const FP_INFINITE: _bindgen_ty_16 = 1;
pub const FP_ZERO: _bindgen_ty_16 = 2;
pub const FP_SUBNORMAL: _bindgen_ty_16 = 3;
pub const FP_NORMAL: _bindgen_ty_16 = 4;
pub type _bindgen_ty_16 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_dll {
    pub bw: f64,
    pub z1: f64,
    pub z2: f64,
    pub z3: f64,
    pub w0: f64,
    pub w1: f64,
    pub w2: f64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_dll"][::std::mem::size_of::<spa_dll>() - 56usize];
    ["Alignment of spa_dll"][::std::mem::align_of::<spa_dll>() - 8usize];
    ["Offset of field: spa_dll::bw"][::std::mem::offset_of!(spa_dll, bw) - 0usize];
    ["Offset of field: spa_dll::z1"][::std::mem::offset_of!(spa_dll, z1) - 8usize];
    ["Offset of field: spa_dll::z2"][::std::mem::offset_of!(spa_dll, z2) - 16usize];
    ["Offset of field: spa_dll::z3"][::std::mem::offset_of!(spa_dll, z3) - 24usize];
    ["Offset of field: spa_dll::w0"][::std::mem::offset_of!(spa_dll, w0) - 32usize];
    ["Offset of field: spa_dll::w1"][::std::mem::offset_of!(spa_dll, w1) - 40usize];
    ["Offset of field: spa_dll::w2"][::std::mem::offset_of!(spa_dll, w2) - 48usize];
};
#[doc = " \\addtogroup spa_json\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_json {
    pub cur: *const ::std::os::raw::c_char,
    pub end: *const ::std::os::raw::c_char,
    pub parent: *mut spa_json,
    pub state: u32,
    pub depth: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_json"][::std::mem::size_of::<spa_json>() - 32usize];
    ["Alignment of spa_json"][::std::mem::align_of::<spa_json>() - 8usize];
    ["Offset of field: spa_json::cur"][::std::mem::offset_of!(spa_json, cur) - 0usize];
    ["Offset of field: spa_json::end"][::std::mem::offset_of!(spa_json, end) - 8usize];
    ["Offset of field: spa_json::parent"][::std::mem::offset_of!(spa_json, parent) - 16usize];
    ["Offset of field: spa_json::state"][::std::mem::offset_of!(spa_json, state) - 24usize];
    ["Offset of field: spa_json::depth"][::std::mem::offset_of!(spa_json, depth) - 28usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_ratelimit {
    pub interval: u64,
    pub begin: u64,
    pub burst: ::std::os::raw::c_uint,
    pub n_printed: ::std::os::raw::c_uint,
    pub n_suppressed: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_ratelimit"][::std::mem::size_of::<spa_ratelimit>() - 32usize];
    ["Alignment of spa_ratelimit"][::std::mem::align_of::<spa_ratelimit>() - 8usize];
    ["Offset of field: spa_ratelimit::interval"]
        [::std::mem::offset_of!(spa_ratelimit, interval) - 0usize];
    ["Offset of field: spa_ratelimit::begin"]
        [::std::mem::offset_of!(spa_ratelimit, begin) - 8usize];
    ["Offset of field: spa_ratelimit::burst"]
        [::std::mem::offset_of!(spa_ratelimit, burst) - 16usize];
    ["Offset of field: spa_ratelimit::n_printed"]
        [::std::mem::offset_of!(spa_ratelimit, n_printed) - 20usize];
    ["Offset of field: spa_ratelimit::n_suppressed"]
        [::std::mem::offset_of!(spa_ratelimit, n_suppressed) - 24usize];
};
#[doc = " \\addtogroup spa_ringbuffer\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_ringbuffer {
    pub readindex: u32,
    pub writeindex: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_ringbuffer"][::std::mem::size_of::<spa_ringbuffer>() - 8usize];
    ["Alignment of spa_ringbuffer"][::std::mem::align_of::<spa_ringbuffer>() - 4usize];
    ["Offset of field: spa_ringbuffer::readindex"]
        [::std::mem::offset_of!(spa_ringbuffer, readindex) - 0usize];
    ["Offset of field: spa_ringbuffer::writeindex"]
        [::std::mem::offset_of!(spa_ringbuffer, writeindex) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __va_list_tag"][::std::mem::size_of::<__va_list_tag>() - 24usize];
    ["Alignment of __va_list_tag"][::std::mem::align_of::<__va_list_tag>() - 8usize];
    ["Offset of field: __va_list_tag::gp_offset"]
        [::std::mem::offset_of!(__va_list_tag, gp_offset) - 0usize];
    ["Offset of field: __va_list_tag::fp_offset"]
        [::std::mem::offset_of!(__va_list_tag, fp_offset) - 4usize];
    ["Offset of field: __va_list_tag::overflow_arg_area"]
        [::std::mem::offset_of!(__va_list_tag, overflow_arg_area) - 8usize];
    ["Offset of field: __va_list_tag::reg_save_area"]
        [::std::mem::offset_of!(__va_list_tag, reg_save_area) - 16usize];
};
