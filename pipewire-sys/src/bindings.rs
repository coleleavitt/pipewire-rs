/* automatically generated by rust-bindgen 0.71.1 */

pub const __GENTOO_NOT_FREESTANDING: u32 = 1;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const _ERRNO_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC23: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_TIME_BITS64: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const __GLIBC_USE_C23_STRTOL: u32 = 0;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 40;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const _BITS_ERRNO_H: u32 = 1;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const ENOTBLK: u32 = 15;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const EINVAL: u32 = 22;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const ETXTBSY: u32 = 26;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const ERANGE: u32 = 34;
pub const EDEADLK: u32 = 35;
pub const ENAMETOOLONG: u32 = 36;
pub const ENOLCK: u32 = 37;
pub const ENOSYS: u32 = 38;
pub const ENOTEMPTY: u32 = 39;
pub const ELOOP: u32 = 40;
pub const EWOULDBLOCK: u32 = 11;
pub const ENOMSG: u32 = 42;
pub const EIDRM: u32 = 43;
pub const ECHRNG: u32 = 44;
pub const EL2NSYNC: u32 = 45;
pub const EL3HLT: u32 = 46;
pub const EL3RST: u32 = 47;
pub const ELNRNG: u32 = 48;
pub const EUNATCH: u32 = 49;
pub const ENOCSI: u32 = 50;
pub const EL2HLT: u32 = 51;
pub const EBADE: u32 = 52;
pub const EBADR: u32 = 53;
pub const EXFULL: u32 = 54;
pub const ENOANO: u32 = 55;
pub const EBADRQC: u32 = 56;
pub const EBADSLT: u32 = 57;
pub const EDEADLOCK: u32 = 35;
pub const EBFONT: u32 = 59;
pub const ENOSTR: u32 = 60;
pub const ENODATA: u32 = 61;
pub const ETIME: u32 = 62;
pub const ENOSR: u32 = 63;
pub const ENONET: u32 = 64;
pub const ENOPKG: u32 = 65;
pub const EREMOTE: u32 = 66;
pub const ENOLINK: u32 = 67;
pub const EADV: u32 = 68;
pub const ESRMNT: u32 = 69;
pub const ECOMM: u32 = 70;
pub const EPROTO: u32 = 71;
pub const EMULTIHOP: u32 = 72;
pub const EDOTDOT: u32 = 73;
pub const EBADMSG: u32 = 74;
pub const EOVERFLOW: u32 = 75;
pub const ENOTUNIQ: u32 = 76;
pub const EBADFD: u32 = 77;
pub const EREMCHG: u32 = 78;
pub const ELIBACC: u32 = 79;
pub const ELIBBAD: u32 = 80;
pub const ELIBSCN: u32 = 81;
pub const ELIBMAX: u32 = 82;
pub const ELIBEXEC: u32 = 83;
pub const EILSEQ: u32 = 84;
pub const ERESTART: u32 = 85;
pub const ESTRPIPE: u32 = 86;
pub const EUSERS: u32 = 87;
pub const ENOTSOCK: u32 = 88;
pub const EDESTADDRREQ: u32 = 89;
pub const EMSGSIZE: u32 = 90;
pub const EPROTOTYPE: u32 = 91;
pub const ENOPROTOOPT: u32 = 92;
pub const EPROTONOSUPPORT: u32 = 93;
pub const ESOCKTNOSUPPORT: u32 = 94;
pub const EOPNOTSUPP: u32 = 95;
pub const EPFNOSUPPORT: u32 = 96;
pub const EAFNOSUPPORT: u32 = 97;
pub const EADDRINUSE: u32 = 98;
pub const EADDRNOTAVAIL: u32 = 99;
pub const ENETDOWN: u32 = 100;
pub const ENETUNREACH: u32 = 101;
pub const ENETRESET: u32 = 102;
pub const ECONNABORTED: u32 = 103;
pub const ECONNRESET: u32 = 104;
pub const ENOBUFS: u32 = 105;
pub const EISCONN: u32 = 106;
pub const ENOTCONN: u32 = 107;
pub const ESHUTDOWN: u32 = 108;
pub const ETOOMANYREFS: u32 = 109;
pub const ETIMEDOUT: u32 = 110;
pub const ECONNREFUSED: u32 = 111;
pub const EHOSTDOWN: u32 = 112;
pub const EHOSTUNREACH: u32 = 113;
pub const EALREADY: u32 = 114;
pub const EINPROGRESS: u32 = 115;
pub const ESTALE: u32 = 116;
pub const EUCLEAN: u32 = 117;
pub const ENOTNAM: u32 = 118;
pub const ENAVAIL: u32 = 119;
pub const EISNAM: u32 = 120;
pub const EREMOTEIO: u32 = 121;
pub const EDQUOT: u32 = 122;
pub const ENOMEDIUM: u32 = 123;
pub const EMEDIUMTYPE: u32 = 124;
pub const ECANCELED: u32 = 125;
pub const ENOKEY: u32 = 126;
pub const EKEYEXPIRED: u32 = 127;
pub const EKEYREVOKED: u32 = 128;
pub const EKEYREJECTED: u32 = 129;
pub const EOWNERDEAD: u32 = 130;
pub const ENOTRECOVERABLE: u32 = 131;
pub const ERFKILL: u32 = 132;
pub const EHWPOISON: u32 = 133;
pub const ENOTSUP: u32 = 95;
pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const _INTTYPES_H: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C23: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C23: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const _BITS_STDINT_LEAST_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const ____gwchar_t_defined: u32 = 1;
pub const __PRI64_PREFIX: &[u8; 2] = b"l\0";
pub const __PRIPTR_PREFIX: &[u8; 2] = b"l\0";
pub const PRId8: &[u8; 2] = b"d\0";
pub const PRId16: &[u8; 2] = b"d\0";
pub const PRId32: &[u8; 2] = b"d\0";
pub const PRId64: &[u8; 3] = b"ld\0";
pub const PRIdLEAST8: &[u8; 2] = b"d\0";
pub const PRIdLEAST16: &[u8; 2] = b"d\0";
pub const PRIdLEAST32: &[u8; 2] = b"d\0";
pub const PRIdLEAST64: &[u8; 3] = b"ld\0";
pub const PRIdFAST8: &[u8; 2] = b"d\0";
pub const PRIdFAST16: &[u8; 3] = b"ld\0";
pub const PRIdFAST32: &[u8; 3] = b"ld\0";
pub const PRIdFAST64: &[u8; 3] = b"ld\0";
pub const PRIi8: &[u8; 2] = b"i\0";
pub const PRIi16: &[u8; 2] = b"i\0";
pub const PRIi32: &[u8; 2] = b"i\0";
pub const PRIi64: &[u8; 3] = b"li\0";
pub const PRIiLEAST8: &[u8; 2] = b"i\0";
pub const PRIiLEAST16: &[u8; 2] = b"i\0";
pub const PRIiLEAST32: &[u8; 2] = b"i\0";
pub const PRIiLEAST64: &[u8; 3] = b"li\0";
pub const PRIiFAST8: &[u8; 2] = b"i\0";
pub const PRIiFAST16: &[u8; 3] = b"li\0";
pub const PRIiFAST32: &[u8; 3] = b"li\0";
pub const PRIiFAST64: &[u8; 3] = b"li\0";
pub const PRIo8: &[u8; 2] = b"o\0";
pub const PRIo16: &[u8; 2] = b"o\0";
pub const PRIo32: &[u8; 2] = b"o\0";
pub const PRIo64: &[u8; 3] = b"lo\0";
pub const PRIoLEAST8: &[u8; 2] = b"o\0";
pub const PRIoLEAST16: &[u8; 2] = b"o\0";
pub const PRIoLEAST32: &[u8; 2] = b"o\0";
pub const PRIoLEAST64: &[u8; 3] = b"lo\0";
pub const PRIoFAST8: &[u8; 2] = b"o\0";
pub const PRIoFAST16: &[u8; 3] = b"lo\0";
pub const PRIoFAST32: &[u8; 3] = b"lo\0";
pub const PRIoFAST64: &[u8; 3] = b"lo\0";
pub const PRIu8: &[u8; 2] = b"u\0";
pub const PRIu16: &[u8; 2] = b"u\0";
pub const PRIu32: &[u8; 2] = b"u\0";
pub const PRIu64: &[u8; 3] = b"lu\0";
pub const PRIuLEAST8: &[u8; 2] = b"u\0";
pub const PRIuLEAST16: &[u8; 2] = b"u\0";
pub const PRIuLEAST32: &[u8; 2] = b"u\0";
pub const PRIuLEAST64: &[u8; 3] = b"lu\0";
pub const PRIuFAST8: &[u8; 2] = b"u\0";
pub const PRIuFAST16: &[u8; 3] = b"lu\0";
pub const PRIuFAST32: &[u8; 3] = b"lu\0";
pub const PRIuFAST64: &[u8; 3] = b"lu\0";
pub const PRIx8: &[u8; 2] = b"x\0";
pub const PRIx16: &[u8; 2] = b"x\0";
pub const PRIx32: &[u8; 2] = b"x\0";
pub const PRIx64: &[u8; 3] = b"lx\0";
pub const PRIxLEAST8: &[u8; 2] = b"x\0";
pub const PRIxLEAST16: &[u8; 2] = b"x\0";
pub const PRIxLEAST32: &[u8; 2] = b"x\0";
pub const PRIxLEAST64: &[u8; 3] = b"lx\0";
pub const PRIxFAST8: &[u8; 2] = b"x\0";
pub const PRIxFAST16: &[u8; 3] = b"lx\0";
pub const PRIxFAST32: &[u8; 3] = b"lx\0";
pub const PRIxFAST64: &[u8; 3] = b"lx\0";
pub const PRIX8: &[u8; 2] = b"X\0";
pub const PRIX16: &[u8; 2] = b"X\0";
pub const PRIX32: &[u8; 2] = b"X\0";
pub const PRIX64: &[u8; 3] = b"lX\0";
pub const PRIXLEAST8: &[u8; 2] = b"X\0";
pub const PRIXLEAST16: &[u8; 2] = b"X\0";
pub const PRIXLEAST32: &[u8; 2] = b"X\0";
pub const PRIXLEAST64: &[u8; 3] = b"lX\0";
pub const PRIXFAST8: &[u8; 2] = b"X\0";
pub const PRIXFAST16: &[u8; 3] = b"lX\0";
pub const PRIXFAST32: &[u8; 3] = b"lX\0";
pub const PRIXFAST64: &[u8; 3] = b"lX\0";
pub const PRIdMAX: &[u8; 3] = b"ld\0";
pub const PRIiMAX: &[u8; 3] = b"li\0";
pub const PRIoMAX: &[u8; 3] = b"lo\0";
pub const PRIuMAX: &[u8; 3] = b"lu\0";
pub const PRIxMAX: &[u8; 3] = b"lx\0";
pub const PRIXMAX: &[u8; 3] = b"lX\0";
pub const PRIdPTR: &[u8; 3] = b"ld\0";
pub const PRIiPTR: &[u8; 3] = b"li\0";
pub const PRIoPTR: &[u8; 3] = b"lo\0";
pub const PRIuPTR: &[u8; 3] = b"lu\0";
pub const PRIxPTR: &[u8; 3] = b"lx\0";
pub const PRIXPTR: &[u8; 3] = b"lX\0";
pub const SCNd8: &[u8; 4] = b"hhd\0";
pub const SCNd16: &[u8; 3] = b"hd\0";
pub const SCNd32: &[u8; 2] = b"d\0";
pub const SCNd64: &[u8; 3] = b"ld\0";
pub const SCNdLEAST8: &[u8; 4] = b"hhd\0";
pub const SCNdLEAST16: &[u8; 3] = b"hd\0";
pub const SCNdLEAST32: &[u8; 2] = b"d\0";
pub const SCNdLEAST64: &[u8; 3] = b"ld\0";
pub const SCNdFAST8: &[u8; 4] = b"hhd\0";
pub const SCNdFAST16: &[u8; 3] = b"ld\0";
pub const SCNdFAST32: &[u8; 3] = b"ld\0";
pub const SCNdFAST64: &[u8; 3] = b"ld\0";
pub const SCNi8: &[u8; 4] = b"hhi\0";
pub const SCNi16: &[u8; 3] = b"hi\0";
pub const SCNi32: &[u8; 2] = b"i\0";
pub const SCNi64: &[u8; 3] = b"li\0";
pub const SCNiLEAST8: &[u8; 4] = b"hhi\0";
pub const SCNiLEAST16: &[u8; 3] = b"hi\0";
pub const SCNiLEAST32: &[u8; 2] = b"i\0";
pub const SCNiLEAST64: &[u8; 3] = b"li\0";
pub const SCNiFAST8: &[u8; 4] = b"hhi\0";
pub const SCNiFAST16: &[u8; 3] = b"li\0";
pub const SCNiFAST32: &[u8; 3] = b"li\0";
pub const SCNiFAST64: &[u8; 3] = b"li\0";
pub const SCNu8: &[u8; 4] = b"hhu\0";
pub const SCNu16: &[u8; 3] = b"hu\0";
pub const SCNu32: &[u8; 2] = b"u\0";
pub const SCNu64: &[u8; 3] = b"lu\0";
pub const SCNuLEAST8: &[u8; 4] = b"hhu\0";
pub const SCNuLEAST16: &[u8; 3] = b"hu\0";
pub const SCNuLEAST32: &[u8; 2] = b"u\0";
pub const SCNuLEAST64: &[u8; 3] = b"lu\0";
pub const SCNuFAST8: &[u8; 4] = b"hhu\0";
pub const SCNuFAST16: &[u8; 3] = b"lu\0";
pub const SCNuFAST32: &[u8; 3] = b"lu\0";
pub const SCNuFAST64: &[u8; 3] = b"lu\0";
pub const SCNo8: &[u8; 4] = b"hho\0";
pub const SCNo16: &[u8; 3] = b"ho\0";
pub const SCNo32: &[u8; 2] = b"o\0";
pub const SCNo64: &[u8; 3] = b"lo\0";
pub const SCNoLEAST8: &[u8; 4] = b"hho\0";
pub const SCNoLEAST16: &[u8; 3] = b"ho\0";
pub const SCNoLEAST32: &[u8; 2] = b"o\0";
pub const SCNoLEAST64: &[u8; 3] = b"lo\0";
pub const SCNoFAST8: &[u8; 4] = b"hho\0";
pub const SCNoFAST16: &[u8; 3] = b"lo\0";
pub const SCNoFAST32: &[u8; 3] = b"lo\0";
pub const SCNoFAST64: &[u8; 3] = b"lo\0";
pub const SCNx8: &[u8; 4] = b"hhx\0";
pub const SCNx16: &[u8; 3] = b"hx\0";
pub const SCNx32: &[u8; 2] = b"x\0";
pub const SCNx64: &[u8; 3] = b"lx\0";
pub const SCNxLEAST8: &[u8; 4] = b"hhx\0";
pub const SCNxLEAST16: &[u8; 3] = b"hx\0";
pub const SCNxLEAST32: &[u8; 2] = b"x\0";
pub const SCNxLEAST64: &[u8; 3] = b"lx\0";
pub const SCNxFAST8: &[u8; 4] = b"hhx\0";
pub const SCNxFAST16: &[u8; 3] = b"lx\0";
pub const SCNxFAST32: &[u8; 3] = b"lx\0";
pub const SCNxFAST64: &[u8; 3] = b"lx\0";
pub const SCNdMAX: &[u8; 3] = b"ld\0";
pub const SCNiMAX: &[u8; 3] = b"li\0";
pub const SCNoMAX: &[u8; 3] = b"lo\0";
pub const SCNuMAX: &[u8; 3] = b"lu\0";
pub const SCNxMAX: &[u8; 3] = b"lx\0";
pub const SCNdPTR: &[u8; 3] = b"ld\0";
pub const SCNiPTR: &[u8; 3] = b"li\0";
pub const SCNoPTR: &[u8; 3] = b"lo\0";
pub const SCNuPTR: &[u8; 3] = b"lu\0";
pub const SCNxPTR: &[u8; 3] = b"lx\0";
pub const _BITS_SIGNUM_GENERIC_H: u32 = 1;
pub const SIGINT: u32 = 2;
pub const SIGILL: u32 = 4;
pub const SIGABRT: u32 = 6;
pub const SIGFPE: u32 = 8;
pub const SIGSEGV: u32 = 11;
pub const SIGTERM: u32 = 15;
pub const SIGHUP: u32 = 1;
pub const SIGQUIT: u32 = 3;
pub const SIGTRAP: u32 = 5;
pub const SIGKILL: u32 = 9;
pub const SIGPIPE: u32 = 13;
pub const SIGALRM: u32 = 14;
pub const SIGIOT: u32 = 6;
pub const _BITS_SIGNUM_ARCH_H: u32 = 1;
pub const SIGSTKFLT: u32 = 16;
pub const SIGPWR: u32 = 30;
pub const SIGBUS: u32 = 7;
pub const SIGSYS: u32 = 31;
pub const SIGURG: u32 = 23;
pub const SIGSTOP: u32 = 19;
pub const SIGTSTP: u32 = 20;
pub const SIGCONT: u32 = 18;
pub const SIGCHLD: u32 = 17;
pub const SIGTTIN: u32 = 21;
pub const SIGTTOU: u32 = 22;
pub const SIGPOLL: u32 = 29;
pub const SIGXFSZ: u32 = 25;
pub const SIGXCPU: u32 = 24;
pub const SIGVTALRM: u32 = 26;
pub const SIGPROF: u32 = 27;
pub const SIGUSR1: u32 = 10;
pub const SIGUSR2: u32 = 12;
pub const SIGWINCH: u32 = 28;
pub const SIGIO: u32 = 29;
pub const SIGCLD: u32 = 17;
pub const __SIGRTMIN: u32 = 32;
pub const __SIGRTMAX: u32 = 64;
pub const _NSIG: u32 = 65;
pub const __sig_atomic_t_defined: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const __time_t_defined: u32 = 1;
pub const __siginfo_t_defined: u32 = 1;
pub const __SI_MAX_SIZE: u32 = 128;
pub const _BITS_SIGINFO_ARCH_H: u32 = 1;
pub const __SI_ERRNO_THEN_CODE: u32 = 1;
pub const __SI_HAVE_SIGSYS: u32 = 1;
pub const _BITS_SIGINFO_CONSTS_H: u32 = 1;
pub const __SI_ASYNCIO_AFTER_SIGIO: u32 = 1;
pub const __sigevent_t_defined: u32 = 1;
pub const __SIGEV_MAX_SIZE: u32 = 64;
pub const __have_pthread_attr_t: u32 = 1;
pub const _BITS_SIGEVENT_CONSTS_H: u32 = 1;
pub const NSIG: u32 = 65;
pub const _BITS_SIGACTION_H: u32 = 1;
pub const SA_NOCLDSTOP: u32 = 1;
pub const SA_NOCLDWAIT: u32 = 2;
pub const SA_SIGINFO: u32 = 4;
pub const SA_ONSTACK: u32 = 134217728;
pub const SA_RESTART: u32 = 268435456;
pub const SA_NODEFER: u32 = 1073741824;
pub const SA_RESETHAND: u32 = 2147483648;
pub const SA_INTERRUPT: u32 = 536870912;
pub const SA_NOMASK: u32 = 1073741824;
pub const SA_ONESHOT: u32 = 2147483648;
pub const SA_STACK: u32 = 134217728;
pub const SIG_BLOCK: u32 = 0;
pub const SIG_UNBLOCK: u32 = 1;
pub const SIG_SETMASK: u32 = 2;
pub const _BITS_SIGCONTEXT_H: u32 = 1;
pub const FP_XSTATE_MAGIC1: u32 = 1179670611;
pub const FP_XSTATE_MAGIC2: u32 = 1179670597;
pub const __stack_t_defined: u32 = 1;
pub const _SYS_UCONTEXT_H: u32 = 1;
pub const __NGREG: u32 = 23;
pub const NGREG: u32 = 23;
pub const _BITS_SIGSTACK_H: u32 = 1;
pub const MINSIGSTKSZ: u32 = 2048;
pub const SIGSTKSZ: u32 = 8192;
pub const _BITS_SS_FLAGS_H: u32 = 1;
pub const __sigstack_defined: u32 = 1;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const _BITS_SIGTHREAD_H: u32 = 1;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _SYS_TYPES_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _ALLOCA_H: u32 = 1;
pub const _STRING_H: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const _STDIO_H: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const __cookie_io_functions_t_defined: u32 = 1;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &[u8; 5] = b"/tmp\0";
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const SPA_NSEC_PER_SEC: u32 = 1000000000;
pub const SPA_NSEC_PER_MSEC: u32 = 1000000;
pub const SPA_NSEC_PER_USEC: u32 = 1000;
pub const SPA_USEC_PER_SEC: u32 = 1000000;
pub const SPA_USEC_PER_MSEC: u32 = 1000;
pub const SPA_MSEC_PER_SEC: u32 = 1000;
pub const SPA_DICT_FLAG_SORTED: u32 = 1;
pub const SPA_VERSION_HANDLE: u32 = 0;
pub const SPA_VERSION_HANDLE_FACTORY: u32 = 1;
pub const SPA_HANDLE_FACTORY_ENUM_FUNC_NAME: &[u8; 24] = b"spa_handle_factory_enum\0";
pub const SPA_KEY_FACTORY_NAME: &[u8; 13] = b"factory.name\0";
pub const SPA_KEY_FACTORY_AUTHOR: &[u8; 15] = b"factory.author\0";
pub const SPA_KEY_FACTORY_DESCRIPTION: &[u8; 20] = b"factory.description\0";
pub const SPA_KEY_FACTORY_USAGE: &[u8; 14] = b"factory.usage\0";
pub const SPA_KEY_LIBRARY_NAME: &[u8; 13] = b"library.name\0";
pub const SPA_PARAM_INFO_SERIAL: u32 = 1;
pub const SPA_PARAM_INFO_READ: u32 = 2;
pub const SPA_PARAM_INFO_WRITE: u32 = 4;
pub const SPA_PARAM_INFO_READWRITE: u32 = 6;
pub const _LOCALE_H: u32 = 1;
pub const _BITS_LOCALE_H: u32 = 1;
pub const __LC_CTYPE: u32 = 0;
pub const __LC_NUMERIC: u32 = 1;
pub const __LC_TIME: u32 = 2;
pub const __LC_COLLATE: u32 = 3;
pub const __LC_MONETARY: u32 = 4;
pub const __LC_MESSAGES: u32 = 5;
pub const __LC_ALL: u32 = 6;
pub const __LC_PAPER: u32 = 7;
pub const __LC_NAME: u32 = 8;
pub const __LC_ADDRESS: u32 = 9;
pub const __LC_TELEPHONE: u32 = 10;
pub const __LC_MEASUREMENT: u32 = 11;
pub const __LC_IDENTIFICATION: u32 = 12;
pub const LC_CTYPE: u32 = 0;
pub const LC_NUMERIC: u32 = 1;
pub const LC_TIME: u32 = 2;
pub const LC_COLLATE: u32 = 3;
pub const LC_MONETARY: u32 = 4;
pub const LC_MESSAGES: u32 = 5;
pub const LC_ALL: u32 = 6;
pub const LC_PAPER: u32 = 7;
pub const LC_NAME: u32 = 8;
pub const LC_ADDRESS: u32 = 9;
pub const LC_TELEPHONE: u32 = 10;
pub const LC_MEASUREMENT: u32 = 11;
pub const LC_IDENTIFICATION: u32 = 12;
pub const LC_CTYPE_MASK: u32 = 1;
pub const LC_NUMERIC_MASK: u32 = 2;
pub const LC_TIME_MASK: u32 = 4;
pub const LC_COLLATE_MASK: u32 = 8;
pub const LC_MONETARY_MASK: u32 = 16;
pub const LC_MESSAGES_MASK: u32 = 32;
pub const LC_PAPER_MASK: u32 = 128;
pub const LC_NAME_MASK: u32 = 256;
pub const LC_ADDRESS_MASK: u32 = 512;
pub const LC_TELEPHONE_MASK: u32 = 1024;
pub const LC_MEASUREMENT_MASK: u32 = 2048;
pub const LC_IDENTIFICATION_MASK: u32 = 4096;
pub const LC_ALL_MASK: u32 = 8127;
pub const SPA_TYPE_INFO_BASE: &[u8; 5] = b"Spa:\0";
pub const SPA_TYPE_INFO_Flags: &[u8; 10] = b"Spa:Flags\0";
pub const SPA_TYPE_INFO_FLAGS_BASE: &[u8; 11] = b"Spa:Flags:\0";
pub const SPA_TYPE_INFO_Enum: &[u8; 9] = b"Spa:Enum\0";
pub const SPA_TYPE_INFO_ENUM_BASE: &[u8; 10] = b"Spa:Enum:\0";
pub const SPA_TYPE_INFO_Pod: &[u8; 8] = b"Spa:Pod\0";
pub const SPA_TYPE_INFO_POD_BASE: &[u8; 9] = b"Spa:Pod:\0";
pub const SPA_TYPE_INFO_Struct: &[u8; 15] = b"Spa:Pod:Struct\0";
pub const SPA_TYPE_INFO_STRUCT_BASE: &[u8; 16] = b"Spa:Pod:Struct:\0";
pub const SPA_TYPE_INFO_Object: &[u8; 15] = b"Spa:Pod:Object\0";
pub const SPA_TYPE_INFO_OBJECT_BASE: &[u8; 16] = b"Spa:Pod:Object:\0";
pub const SPA_TYPE_INFO_Pointer: &[u8; 12] = b"Spa:Pointer\0";
pub const SPA_TYPE_INFO_POINTER_BASE: &[u8; 13] = b"Spa:Pointer:\0";
pub const SPA_TYPE_INFO_Interface: &[u8; 22] = b"Spa:Pointer:Interface\0";
pub const SPA_TYPE_INFO_INTERFACE_BASE: &[u8; 23] = b"Spa:Pointer:Interface:\0";
pub const SPA_TYPE_INFO_Event: &[u8; 21] = b"Spa:Pod:Object:Event\0";
pub const SPA_TYPE_INFO_EVENT_BASE: &[u8; 22] = b"Spa:Pod:Object:Event:\0";
pub const SPA_TYPE_INFO_Command: &[u8; 23] = b"Spa:Pod:Object:Command\0";
pub const SPA_TYPE_INFO_COMMAND_BASE: &[u8; 24] = b"Spa:Pod:Object:Command:\0";
pub const PW_TYPE_INFO_BASE: &[u8; 10] = b"PipeWire:\0";
pub const PW_TYPE_INFO_Object: &[u8; 16] = b"PipeWire:Object\0";
pub const PW_TYPE_INFO_OBJECT_BASE: &[u8; 17] = b"PipeWire:Object:\0";
pub const PW_TYPE_INFO_Interface: &[u8; 19] = b"PipeWire:Interface\0";
pub const PW_TYPE_INFO_INTERFACE_BASE: &[u8; 20] = b"PipeWire:Interface:\0";
pub const PW_TYPE_INTERFACE_Core: &[u8; 24] = b"PipeWire:Interface:Core\0";
pub const PW_TYPE_INTERFACE_Registry: &[u8; 28] = b"PipeWire:Interface:Registry\0";
pub const PW_VERSION_CORE: u32 = 4;
pub const PW_VERSION_REGISTRY: u32 = 3;
pub const PW_DEFAULT_REMOTE: &[u8; 11] = b"pipewire-0\0";
pub const PW_ID_CORE: u32 = 0;
pub const PW_CORE_CHANGE_MASK_PROPS: u32 = 1;
pub const PW_CORE_CHANGE_MASK_ALL: u32 = 1;
pub const _UNISTD_H: u32 = 1;
pub const _POSIX_VERSION: u32 = 200809;
pub const __POSIX2_THIS_VERSION: u32 = 200809;
pub const _POSIX2_VERSION: u32 = 200809;
pub const _POSIX2_C_VERSION: u32 = 200809;
pub const _POSIX2_C_BIND: u32 = 200809;
pub const _POSIX2_C_DEV: u32 = 200809;
pub const _POSIX2_SW_DEV: u32 = 200809;
pub const _POSIX2_LOCALEDEF: u32 = 200809;
pub const _XOPEN_VERSION: u32 = 700;
pub const _XOPEN_XCU_VERSION: u32 = 4;
pub const _XOPEN_XPG2: u32 = 1;
pub const _XOPEN_XPG3: u32 = 1;
pub const _XOPEN_XPG4: u32 = 1;
pub const _XOPEN_UNIX: u32 = 1;
pub const _XOPEN_ENH_I18N: u32 = 1;
pub const _XOPEN_LEGACY: u32 = 1;
pub const _BITS_POSIX_OPT_H: u32 = 1;
pub const _POSIX_JOB_CONTROL: u32 = 1;
pub const _POSIX_SAVED_IDS: u32 = 1;
pub const _POSIX_PRIORITY_SCHEDULING: u32 = 200809;
pub const _POSIX_SYNCHRONIZED_IO: u32 = 200809;
pub const _POSIX_FSYNC: u32 = 200809;
pub const _POSIX_MAPPED_FILES: u32 = 200809;
pub const _POSIX_MEMLOCK: u32 = 200809;
pub const _POSIX_MEMLOCK_RANGE: u32 = 200809;
pub const _POSIX_MEMORY_PROTECTION: u32 = 200809;
pub const _POSIX_CHOWN_RESTRICTED: u32 = 0;
pub const _POSIX_VDISABLE: u8 = 0u8;
pub const _POSIX_NO_TRUNC: u32 = 1;
pub const _XOPEN_REALTIME: u32 = 1;
pub const _XOPEN_REALTIME_THREADS: u32 = 1;
pub const _XOPEN_SHM: u32 = 1;
pub const _POSIX_THREADS: u32 = 200809;
pub const _POSIX_REENTRANT_FUNCTIONS: u32 = 1;
pub const _POSIX_THREAD_SAFE_FUNCTIONS: u32 = 200809;
pub const _POSIX_THREAD_PRIORITY_SCHEDULING: u32 = 200809;
pub const _POSIX_THREAD_ATTR_STACKSIZE: u32 = 200809;
pub const _POSIX_THREAD_ATTR_STACKADDR: u32 = 200809;
pub const _POSIX_THREAD_PRIO_INHERIT: u32 = 200809;
pub const _POSIX_THREAD_PRIO_PROTECT: u32 = 200809;
pub const _POSIX_THREAD_ROBUST_PRIO_INHERIT: u32 = 200809;
pub const _POSIX_THREAD_ROBUST_PRIO_PROTECT: i32 = -1;
pub const _POSIX_SEMAPHORES: u32 = 200809;
pub const _POSIX_REALTIME_SIGNALS: u32 = 200809;
pub const _POSIX_ASYNCHRONOUS_IO: u32 = 200809;
pub const _POSIX_ASYNC_IO: u32 = 1;
pub const _LFS_ASYNCHRONOUS_IO: u32 = 1;
pub const _POSIX_PRIORITIZED_IO: u32 = 200809;
pub const _LFS64_ASYNCHRONOUS_IO: u32 = 1;
pub const _LFS_LARGEFILE: u32 = 1;
pub const _LFS64_LARGEFILE: u32 = 1;
pub const _LFS64_STDIO: u32 = 1;
pub const _POSIX_SHARED_MEMORY_OBJECTS: u32 = 200809;
pub const _POSIX_CPUTIME: u32 = 0;
pub const _POSIX_THREAD_CPUTIME: u32 = 0;
pub const _POSIX_REGEXP: u32 = 1;
pub const _POSIX_READER_WRITER_LOCKS: u32 = 200809;
pub const _POSIX_SHELL: u32 = 1;
pub const _POSIX_TIMEOUTS: u32 = 200809;
pub const _POSIX_SPIN_LOCKS: u32 = 200809;
pub const _POSIX_SPAWN: u32 = 200809;
pub const _POSIX_TIMERS: u32 = 200809;
pub const _POSIX_BARRIERS: u32 = 200809;
pub const _POSIX_MESSAGE_PASSING: u32 = 200809;
pub const _POSIX_THREAD_PROCESS_SHARED: u32 = 200809;
pub const _POSIX_MONOTONIC_CLOCK: u32 = 0;
pub const _POSIX_CLOCK_SELECTION: u32 = 200809;
pub const _POSIX_ADVISORY_INFO: u32 = 200809;
pub const _POSIX_IPV6: u32 = 200809;
pub const _POSIX_RAW_SOCKETS: u32 = 200809;
pub const _POSIX2_CHAR_TERM: u32 = 200809;
pub const _POSIX_SPORADIC_SERVER: i32 = -1;
pub const _POSIX_THREAD_SPORADIC_SERVER: i32 = -1;
pub const _POSIX_TRACE: i32 = -1;
pub const _POSIX_TRACE_EVENT_FILTER: i32 = -1;
pub const _POSIX_TRACE_INHERIT: i32 = -1;
pub const _POSIX_TRACE_LOG: i32 = -1;
pub const _POSIX_TYPED_MEMORY_OBJECTS: i32 = -1;
pub const _POSIX_V7_LPBIG_OFFBIG: i32 = -1;
pub const _POSIX_V6_LPBIG_OFFBIG: i32 = -1;
pub const _XBS5_LPBIG_OFFBIG: i32 = -1;
pub const _POSIX_V7_LP64_OFF64: u32 = 1;
pub const _POSIX_V6_LP64_OFF64: u32 = 1;
pub const _XBS5_LP64_OFF64: u32 = 1;
pub const __ILP32_OFF32_CFLAGS: &[u8; 5] = b"-m32\0";
pub const __ILP32_OFF32_LDFLAGS: &[u8; 5] = b"-m32\0";
pub const __ILP32_OFFBIG_CFLAGS: &[u8; 48] = b"-m32 -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64\0";
pub const __ILP32_OFFBIG_LDFLAGS: &[u8; 5] = b"-m32\0";
pub const __LP64_OFF64_CFLAGS: &[u8; 5] = b"-m64\0";
pub const __LP64_OFF64_LDFLAGS: &[u8; 5] = b"-m64\0";
pub const STDIN_FILENO: u32 = 0;
pub const STDOUT_FILENO: u32 = 1;
pub const STDERR_FILENO: u32 = 2;
pub const R_OK: u32 = 4;
pub const W_OK: u32 = 2;
pub const X_OK: u32 = 1;
pub const F_OK: u32 = 0;
pub const L_SET: u32 = 0;
pub const L_INCR: u32 = 1;
pub const L_XTND: u32 = 2;
pub const _GETOPT_POSIX_H: u32 = 1;
pub const _GETOPT_CORE_H: u32 = 1;
pub const F_ULOCK: u32 = 0;
pub const F_LOCK: u32 = 1;
pub const F_TLOCK: u32 = 2;
pub const F_TEST: u32 = 3;
pub const _DIRENT_H: u32 = 1;
pub const _DIRENT_MATCHES_DIRENT64: u32 = 1;
pub const _BITS_POSIX1_LIM_H: u32 = 1;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const PTHREAD_KEYS_MAX: u32 = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const AIO_PRIO_DELTA_MAX: u32 = 20;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const DELAYTIMER_MAX: u32 = 2147483647;
pub const TTY_NAME_MAX: u32 = 32;
pub const LOGIN_NAME_MAX: u32 = 256;
pub const HOST_NAME_MAX: u32 = 64;
pub const MQ_PRIO_MAX: u32 = 32768;
pub const SEM_VALUE_MAX: u32 = 2147483647;
pub const MAXNAMLEN: u32 = 255;
pub const PW_PROPERTIES_FLAG_NL: u32 = 1;
pub const PW_PROPERTIES_FLAG_RECURSE: u32 = 2;
pub const PW_PROPERTIES_FLAG_ENCLOSE: u32 = 4;
pub const PW_PROPERTIES_FLAG_ARRAY: u32 = 8;
pub const PW_PROPERTIES_FLAG_COLORS: u32 = 16;
pub const PW_CORE_EVENT_INFO: u32 = 0;
pub const PW_CORE_EVENT_DONE: u32 = 1;
pub const PW_CORE_EVENT_PING: u32 = 2;
pub const PW_CORE_EVENT_ERROR: u32 = 3;
pub const PW_CORE_EVENT_REMOVE_ID: u32 = 4;
pub const PW_CORE_EVENT_BOUND_ID: u32 = 5;
pub const PW_CORE_EVENT_ADD_MEM: u32 = 6;
pub const PW_CORE_EVENT_REMOVE_MEM: u32 = 7;
pub const PW_CORE_EVENT_BOUND_PROPS: u32 = 8;
pub const PW_CORE_EVENT_NUM: u32 = 9;
pub const PW_VERSION_CORE_EVENTS: u32 = 1;
pub const PW_CORE_METHOD_ADD_LISTENER: u32 = 0;
pub const PW_CORE_METHOD_HELLO: u32 = 1;
pub const PW_CORE_METHOD_SYNC: u32 = 2;
pub const PW_CORE_METHOD_PONG: u32 = 3;
pub const PW_CORE_METHOD_ERROR: u32 = 4;
pub const PW_CORE_METHOD_GET_REGISTRY: u32 = 5;
pub const PW_CORE_METHOD_CREATE_OBJECT: u32 = 6;
pub const PW_CORE_METHOD_DESTROY: u32 = 7;
pub const PW_CORE_METHOD_NUM: u32 = 8;
pub const PW_VERSION_CORE_METHODS: u32 = 0;
pub const PW_REGISTRY_EVENT_GLOBAL: u32 = 0;
pub const PW_REGISTRY_EVENT_GLOBAL_REMOVE: u32 = 1;
pub const PW_REGISTRY_EVENT_NUM: u32 = 2;
pub const PW_VERSION_REGISTRY_EVENTS: u32 = 0;
pub const PW_REGISTRY_METHOD_ADD_LISTENER: u32 = 0;
pub const PW_REGISTRY_METHOD_BIND: u32 = 1;
pub const PW_REGISTRY_METHOD_DESTROY: u32 = 2;
pub const PW_REGISTRY_METHOD_NUM: u32 = 3;
pub const PW_VERSION_REGISTRY_METHODS: u32 = 0;
pub const _TIME_H: u32 = 1;
pub const _BITS_TIME_H: u32 = 1;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_MONOTONIC: u32 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 3;
pub const CLOCK_MONOTONIC_RAW: u32 = 4;
pub const CLOCK_REALTIME_COARSE: u32 = 5;
pub const CLOCK_MONOTONIC_COARSE: u32 = 6;
pub const CLOCK_BOOTTIME: u32 = 7;
pub const CLOCK_REALTIME_ALARM: u32 = 8;
pub const CLOCK_BOOTTIME_ALARM: u32 = 9;
pub const CLOCK_TAI: u32 = 11;
pub const TIMER_ABSTIME: u32 = 1;
pub const __struct_tm_defined: u32 = 1;
pub const __itimerspec_defined: u32 = 1;
pub const TIME_UTC: u32 = 1;
pub const SPA_TYPE_INTERFACE_System: &[u8; 29] = b"Spa:Pointer:Interface:System\0";
pub const SPA_TYPE_INTERFACE_DataSystem: &[u8; 33] = b"Spa:Pointer:Interface:DataSystem\0";
pub const SPA_VERSION_SYSTEM: u32 = 0;
pub const SPA_IO_IN: u32 = 1;
pub const SPA_IO_OUT: u32 = 4;
pub const SPA_IO_ERR: u32 = 8;
pub const SPA_IO_HUP: u32 = 16;
pub const SPA_FD_CLOEXEC: u32 = 1;
pub const SPA_FD_NONBLOCK: u32 = 2;
pub const SPA_FD_EVENT_SEMAPHORE: u32 = 4;
pub const SPA_FD_TIMER_ABSTIME: u32 = 8;
pub const SPA_FD_TIMER_CANCEL_ON_SET: u32 = 16;
pub const SPA_VERSION_SYSTEM_METHODS: u32 = 0;
pub const SPA_TYPE_INTERFACE_Loop: &[u8; 27] = b"Spa:Pointer:Interface:Loop\0";
pub const SPA_TYPE_INTERFACE_DataLoop: &[u8; 31] = b"Spa:Pointer:Interface:DataLoop\0";
pub const SPA_VERSION_LOOP: u32 = 0;
pub const SPA_TYPE_INTERFACE_LoopControl: &[u8; 34] = b"Spa:Pointer:Interface:LoopControl\0";
pub const SPA_VERSION_LOOP_CONTROL: u32 = 1;
pub const SPA_TYPE_INTERFACE_LoopUtils: &[u8; 32] = b"Spa:Pointer:Interface:LoopUtils\0";
pub const SPA_VERSION_LOOP_UTILS: u32 = 0;
pub const SPA_VERSION_LOOP_METHODS: u32 = 0;
pub const SPA_VERSION_LOOP_CONTROL_HOOKS: u32 = 0;
pub const SPA_VERSION_LOOP_CONTROL_METHODS: u32 = 1;
pub const SPA_VERSION_LOOP_UTILS_METHODS: u32 = 0;
pub const PW_VERSION_CONTEXT_EVENTS: u32 = 1;
pub const _SYS_UN_H: u32 = 1;
pub const _BITS_SOCKADDR_H: u32 = 1;
pub const _SS_SIZE: u32 = 128;
pub const SPA_POD_PROP_FLAG_READONLY: u32 = 1;
pub const SPA_POD_PROP_FLAG_HARDWARE: u32 = 2;
pub const SPA_POD_PROP_FLAG_HINT_DICT: u32 = 4;
pub const SPA_POD_PROP_FLAG_MANDATORY: u32 = 8;
pub const SPA_POD_PROP_FLAG_DONT_FIXATE: u32 = 16;
pub const PW_TYPE_INFO_Protocol: &[u8; 18] = b"PipeWire:Protocol\0";
pub const PW_TYPE_INFO_PROTOCOL_BASE: &[u8; 19] = b"PipeWire:Protocol:\0";
pub const PW_PROTOCOL_MARSHAL_FLAG_IMPL: u32 = 1;
pub const PW_VERSION_PROTOCOL_IMPLEMENTATION: u32 = 1;
pub const PW_VERSION_PROTOCOL_EVENTS: u32 = 0;
pub const PW_VERSION_PROXY_EVENTS: u32 = 1;
pub const PW_PERM_R: u32 = 256;
pub const PW_PERM_W: u32 = 128;
pub const PW_PERM_X: u32 = 64;
pub const PW_PERM_M: u32 = 8;
pub const PW_PERM_L: u32 = 16;
pub const PW_PERM_RW: u32 = 384;
pub const PW_PERM_RWX: u32 = 448;
pub const PW_PERM_RWXM: u32 = 456;
pub const PW_PERM_RWXML: u32 = 472;
pub const PW_PERM_ALL: u32 = 456;
pub const PW_PERMISSION_FORMAT: &[u8; 11] = b"%c%c%c%c%c\0";
pub const PW_TYPE_INTERFACE_Client: &[u8; 26] = b"PipeWire:Interface:Client\0";
pub const PW_CLIENT_PERM_MASK: u32 = 456;
pub const PW_VERSION_CLIENT: u32 = 3;
pub const PW_ID_CLIENT: u32 = 1;
pub const PW_CLIENT_CHANGE_MASK_PROPS: u32 = 1;
pub const PW_CLIENT_CHANGE_MASK_ALL: u32 = 1;
pub const PW_CLIENT_EVENT_INFO: u32 = 0;
pub const PW_CLIENT_EVENT_PERMISSIONS: u32 = 1;
pub const PW_CLIENT_EVENT_NUM: u32 = 2;
pub const PW_VERSION_CLIENT_EVENTS: u32 = 0;
pub const PW_CLIENT_METHOD_ADD_LISTENER: u32 = 0;
pub const PW_CLIENT_METHOD_ERROR: u32 = 1;
pub const PW_CLIENT_METHOD_UPDATE_PROPERTIES: u32 = 2;
pub const PW_CLIENT_METHOD_GET_PERMISSIONS: u32 = 3;
pub const PW_CLIENT_METHOD_UPDATE_PERMISSIONS: u32 = 4;
pub const PW_CLIENT_METHOD_NUM: u32 = 5;
pub const PW_VERSION_CLIENT_METHODS: u32 = 0;
pub const _MATH_H: u32 = 1;
pub const _BITS_LIBM_SIMD_DECL_STUBS_H: u32 = 1;
pub const __FP_LOGB0_IS_MIN: u32 = 1;
pub const __FP_LOGBNAN_IS_MIN: u32 = 1;
pub const FP_ILOGB0: i32 = -2147483648;
pub const FP_ILOGBNAN: i32 = -2147483648;
pub const __MATH_DECLARING_DOUBLE: u32 = 1;
pub const __MATH_DECLARING_FLOATN: u32 = 0;
pub const __MATH_DECLARE_LDOUBLE: u32 = 1;
pub const FP_NAN: u32 = 0;
pub const FP_INFINITE: u32 = 1;
pub const FP_ZERO: u32 = 2;
pub const FP_SUBNORMAL: u32 = 3;
pub const FP_NORMAL: u32 = 4;
pub const MATH_ERRNO: u32 = 1;
pub const MATH_ERREXCEPT: u32 = 2;
pub const math_errhandling: u32 = 3;
pub const M_E: f64 = 2.718281828459045;
pub const M_LOG2E: f64 = 1.4426950408889634;
pub const M_LOG10E: f64 = 0.4342944819032518;
pub const M_LN2: f64 = 0.6931471805599453;
pub const M_LN10: f64 = 2.302585092994046;
pub const M_PI: f64 = 3.141592653589793;
pub const M_PI_2: f64 = 1.5707963267948966;
pub const M_PI_4: f64 = 0.7853981633974483;
pub const M_1_PI: f64 = 0.3183098861837907;
pub const M_2_PI: f64 = 0.6366197723675814;
pub const M_2_SQRTPI: f64 = 1.1283791670955126;
pub const M_SQRT2: f64 = 1.4142135623730951;
pub const M_SQRT1_2: f64 = 0.7071067811865476;
pub const SPA_JSON_ERROR_FLAG: u32 = 256;
pub const PW_TYPE_INTERFACE_Device: &[u8; 26] = b"PipeWire:Interface:Device\0";
pub const PW_DEVICE_PERM_MASK: u32 = 456;
pub const PW_VERSION_DEVICE: u32 = 3;
pub const PW_DEVICE_CHANGE_MASK_PROPS: u32 = 1;
pub const PW_DEVICE_CHANGE_MASK_PARAMS: u32 = 2;
pub const PW_DEVICE_CHANGE_MASK_ALL: u32 = 3;
pub const PW_DEVICE_EVENT_INFO: u32 = 0;
pub const PW_DEVICE_EVENT_PARAM: u32 = 1;
pub const PW_DEVICE_EVENT_NUM: u32 = 2;
pub const PW_VERSION_DEVICE_EVENTS: u32 = 0;
pub const PW_DEVICE_METHOD_ADD_LISTENER: u32 = 0;
pub const PW_DEVICE_METHOD_SUBSCRIBE_PARAMS: u32 = 1;
pub const PW_DEVICE_METHOD_ENUM_PARAMS: u32 = 2;
pub const PW_DEVICE_METHOD_SET_PARAM: u32 = 3;
pub const PW_DEVICE_METHOD_NUM: u32 = 4;
pub const PW_VERSION_DEVICE_METHODS: u32 = 0;
pub const SPA_META_HEADER_FLAG_DISCONT: u32 = 1;
pub const SPA_META_HEADER_FLAG_CORRUPTED: u32 = 2;
pub const SPA_META_HEADER_FLAG_MARKER: u32 = 4;
pub const SPA_META_HEADER_FLAG_HEADER: u32 = 8;
pub const SPA_META_HEADER_FLAG_GAP: u32 = 16;
pub const SPA_META_HEADER_FLAG_DELTA_UNIT: u32 = 32;
pub const SPA_CHUNK_FLAG_NONE: u32 = 0;
pub const SPA_CHUNK_FLAG_CORRUPTED: u32 = 1;
pub const SPA_CHUNK_FLAG_EMPTY: u32 = 2;
pub const SPA_DATA_FLAG_NONE: u32 = 0;
pub const SPA_DATA_FLAG_READABLE: u32 = 1;
pub const SPA_DATA_FLAG_WRITABLE: u32 = 2;
pub const SPA_DATA_FLAG_DYNAMIC: u32 = 4;
pub const SPA_DATA_FLAG_READWRITE: u32 = 3;
pub const SPA_DATA_FLAG_MAPPABLE: u32 = 8;
pub const SPA_TYPE_INTERFACE_Node: &[u8; 27] = b"Spa:Pointer:Interface:Node\0";
pub const SPA_VERSION_NODE: u32 = 0;
pub const SPA_NODE_CHANGE_MASK_FLAGS: u32 = 1;
pub const SPA_NODE_CHANGE_MASK_PROPS: u32 = 2;
pub const SPA_NODE_CHANGE_MASK_PARAMS: u32 = 4;
pub const SPA_NODE_FLAG_RT: u32 = 1;
pub const SPA_NODE_FLAG_IN_DYNAMIC_PORTS: u32 = 2;
pub const SPA_NODE_FLAG_OUT_DYNAMIC_PORTS: u32 = 4;
pub const SPA_NODE_FLAG_IN_PORT_CONFIG: u32 = 8;
pub const SPA_NODE_FLAG_OUT_PORT_CONFIG: u32 = 16;
pub const SPA_NODE_FLAG_NEED_CONFIGURE: u32 = 32;
pub const SPA_NODE_FLAG_ASYNC: u32 = 64;
pub const SPA_PORT_CHANGE_MASK_FLAGS: u32 = 1;
pub const SPA_PORT_CHANGE_MASK_RATE: u32 = 2;
pub const SPA_PORT_CHANGE_MASK_PROPS: u32 = 4;
pub const SPA_PORT_CHANGE_MASK_PARAMS: u32 = 8;
pub const SPA_PORT_FLAG_REMOVABLE: u32 = 1;
pub const SPA_PORT_FLAG_OPTIONAL: u32 = 2;
pub const SPA_PORT_FLAG_CAN_ALLOC_BUFFERS: u32 = 4;
pub const SPA_PORT_FLAG_IN_PLACE: u32 = 8;
pub const SPA_PORT_FLAG_NO_REF: u32 = 16;
pub const SPA_PORT_FLAG_LIVE: u32 = 32;
pub const SPA_PORT_FLAG_PHYSICAL: u32 = 64;
pub const SPA_PORT_FLAG_TERMINAL: u32 = 128;
pub const SPA_PORT_FLAG_DYNAMIC_DATA: u32 = 256;
pub const SPA_RESULT_TYPE_NODE_ERROR: u32 = 1;
pub const SPA_RESULT_TYPE_NODE_PARAMS: u32 = 2;
pub const SPA_NODE_EVENT_INFO: u32 = 0;
pub const SPA_NODE_EVENT_PORT_INFO: u32 = 1;
pub const SPA_NODE_EVENT_RESULT: u32 = 2;
pub const SPA_NODE_EVENT_EVENT: u32 = 3;
pub const SPA_NODE_EVENT_NUM: u32 = 4;
pub const SPA_VERSION_NODE_EVENTS: u32 = 0;
pub const SPA_NODE_CALLBACK_READY: u32 = 0;
pub const SPA_NODE_CALLBACK_REUSE_BUFFER: u32 = 1;
pub const SPA_NODE_CALLBACK_XRUN: u32 = 2;
pub const SPA_NODE_CALLBACK_NUM: u32 = 3;
pub const SPA_VERSION_NODE_CALLBACKS: u32 = 0;
pub const SPA_NODE_PARAM_FLAG_TEST_ONLY: u32 = 1;
pub const SPA_NODE_PARAM_FLAG_FIXATE: u32 = 2;
pub const SPA_NODE_PARAM_FLAG_NEAREST: u32 = 4;
pub const SPA_NODE_BUFFERS_FLAG_ALLOC: u32 = 1;
pub const SPA_NODE_METHOD_ADD_LISTENER: u32 = 0;
pub const SPA_NODE_METHOD_SET_CALLBACKS: u32 = 1;
pub const SPA_NODE_METHOD_SYNC: u32 = 2;
pub const SPA_NODE_METHOD_ENUM_PARAMS: u32 = 3;
pub const SPA_NODE_METHOD_SET_PARAM: u32 = 4;
pub const SPA_NODE_METHOD_SET_IO: u32 = 5;
pub const SPA_NODE_METHOD_SEND_COMMAND: u32 = 6;
pub const SPA_NODE_METHOD_ADD_PORT: u32 = 7;
pub const SPA_NODE_METHOD_REMOVE_PORT: u32 = 8;
pub const SPA_NODE_METHOD_PORT_ENUM_PARAMS: u32 = 9;
pub const SPA_NODE_METHOD_PORT_SET_PARAM: u32 = 10;
pub const SPA_NODE_METHOD_PORT_USE_BUFFERS: u32 = 11;
pub const SPA_NODE_METHOD_PORT_SET_IO: u32 = 12;
pub const SPA_NODE_METHOD_PORT_REUSE_BUFFER: u32 = 13;
pub const SPA_NODE_METHOD_PROCESS: u32 = 14;
pub const SPA_NODE_METHOD_NUM: u32 = 15;
pub const SPA_VERSION_NODE_METHODS: u32 = 0;
pub const PW_VERSION_MEMPOOL_EVENTS: u32 = 0;
pub const PW_BUFFERS_FLAG_NONE: u32 = 0;
pub const PW_BUFFERS_FLAG_NO_MEM: u32 = 1;
pub const PW_BUFFERS_FLAG_SHARED: u32 = 2;
pub const PW_BUFFERS_FLAG_DYNAMIC: u32 = 4;
pub const PW_BUFFERS_FLAG_SHARED_MEM: u32 = 8;
pub const PW_BUFFERS_FLAG_IN_PRIORITY: u32 = 16;
pub const PW_BUFFERS_FLAG_ASYNC: u32 = 32;
pub const PW_TYPE_INTERFACE_Factory: &[u8; 27] = b"PipeWire:Interface:Factory\0";
pub const PW_FACTORY_PERM_MASK: u32 = 264;
pub const PW_VERSION_FACTORY: u32 = 3;
pub const PW_FACTORY_CHANGE_MASK_PROPS: u32 = 1;
pub const PW_FACTORY_CHANGE_MASK_ALL: u32 = 1;
pub const PW_FACTORY_EVENT_INFO: u32 = 0;
pub const PW_FACTORY_EVENT_NUM: u32 = 1;
pub const PW_VERSION_FACTORY_EVENTS: u32 = 0;
pub const PW_FACTORY_METHOD_ADD_LISTENER: u32 = 0;
pub const PW_FACTORY_METHOD_NUM: u32 = 1;
pub const PW_VERSION_FACTORY_METHODS: u32 = 0;
pub const PW_KEY_PROTOCOL: &[u8; 18] = b"pipewire.protocol\0";
pub const PW_KEY_ACCESS: &[u8; 16] = b"pipewire.access\0";
pub const PW_KEY_CLIENT_ACCESS: &[u8; 23] = b"pipewire.client.access\0";
pub const PW_KEY_SEC_PID: &[u8; 17] = b"pipewire.sec.pid\0";
pub const PW_KEY_SEC_UID: &[u8; 17] = b"pipewire.sec.uid\0";
pub const PW_KEY_SEC_GID: &[u8; 17] = b"pipewire.sec.gid\0";
pub const PW_KEY_SEC_LABEL: &[u8; 19] = b"pipewire.sec.label\0";
pub const PW_KEY_SEC_SOCKET: &[u8; 20] = b"pipewire.sec.socket\0";
pub const PW_KEY_SEC_ENGINE: &[u8; 20] = b"pipewire.sec.engine\0";
pub const PW_KEY_SEC_APP_ID: &[u8; 20] = b"pipewire.sec.app-id\0";
pub const PW_KEY_SEC_INSTANCE_ID: &[u8; 25] = b"pipewire.sec.instance-id\0";
pub const PW_KEY_LIBRARY_NAME_SYSTEM: &[u8; 20] = b"library.name.system\0";
pub const PW_KEY_LIBRARY_NAME_LOOP: &[u8; 18] = b"library.name.loop\0";
pub const PW_KEY_LIBRARY_NAME_DBUS: &[u8; 18] = b"library.name.dbus\0";
pub const PW_KEY_OBJECT_PATH: &[u8; 12] = b"object.path\0";
pub const PW_KEY_OBJECT_ID: &[u8; 10] = b"object.id\0";
pub const PW_KEY_OBJECT_SERIAL: &[u8; 14] = b"object.serial\0";
pub const PW_KEY_OBJECT_LINGER: &[u8; 14] = b"object.linger\0";
pub const PW_KEY_OBJECT_REGISTER: &[u8; 16] = b"object.register\0";
pub const PW_KEY_OBJECT_EXPORT: &[u8; 14] = b"object.export\0";
pub const PW_KEY_CONFIG_PREFIX: &[u8; 14] = b"config.prefix\0";
pub const PW_KEY_CONFIG_NAME: &[u8; 12] = b"config.name\0";
pub const PW_KEY_CONFIG_OVERRIDE_PREFIX: &[u8; 23] = b"config.override.prefix\0";
pub const PW_KEY_CONFIG_OVERRIDE_NAME: &[u8; 21] = b"config.override.name\0";
pub const PW_KEY_LOOP_NAME: &[u8; 10] = b"loop.name\0";
pub const PW_KEY_LOOP_CLASS: &[u8; 11] = b"loop.class\0";
pub const PW_KEY_LOOP_RT_PRIO: &[u8; 13] = b"loop.rt-prio\0";
pub const PW_KEY_LOOP_CANCEL: &[u8; 12] = b"loop.cancel\0";
pub const PW_KEY_CONTEXT_PROFILE_MODULES: &[u8; 24] = b"context.profile.modules\0";
pub const PW_KEY_USER_NAME: &[u8; 18] = b"context.user-name\0";
pub const PW_KEY_HOST_NAME: &[u8; 18] = b"context.host-name\0";
pub const PW_KEY_CORE_NAME: &[u8; 10] = b"core.name\0";
pub const PW_KEY_CORE_VERSION: &[u8; 13] = b"core.version\0";
pub const PW_KEY_CORE_DAEMON: &[u8; 12] = b"core.daemon\0";
pub const PW_KEY_CORE_ID: &[u8; 8] = b"core.id\0";
pub const PW_KEY_CORE_MONITORS: &[u8; 14] = b"core.monitors\0";
pub const PW_KEY_CPU_MAX_ALIGN: &[u8; 14] = b"cpu.max-align\0";
pub const PW_KEY_CPU_CORES: &[u8; 10] = b"cpu.cores\0";
pub const PW_KEY_PRIORITY_SESSION: &[u8; 17] = b"priority.session\0";
pub const PW_KEY_PRIORITY_DRIVER: &[u8; 16] = b"priority.driver\0";
pub const PW_KEY_REMOTE_NAME: &[u8; 12] = b"remote.name\0";
pub const PW_KEY_REMOTE_INTENTION: &[u8; 17] = b"remote.intention\0";
pub const PW_KEY_APP_NAME: &[u8; 17] = b"application.name\0";
pub const PW_KEY_APP_ID: &[u8; 15] = b"application.id\0";
pub const PW_KEY_APP_VERSION: &[u8; 20] = b"application.version\0";
pub const PW_KEY_APP_ICON: &[u8; 17] = b"application.icon\0";
pub const PW_KEY_APP_ICON_NAME: &[u8; 22] = b"application.icon-name\0";
pub const PW_KEY_APP_LANGUAGE: &[u8; 21] = b"application.language\0";
pub const PW_KEY_APP_PROCESS_ID: &[u8; 23] = b"application.process.id\0";
pub const PW_KEY_APP_PROCESS_BINARY: &[u8; 27] = b"application.process.binary\0";
pub const PW_KEY_APP_PROCESS_USER: &[u8; 25] = b"application.process.user\0";
pub const PW_KEY_APP_PROCESS_HOST: &[u8; 25] = b"application.process.host\0";
pub const PW_KEY_APP_PROCESS_MACHINE_ID: &[u8; 31] = b"application.process.machine-id\0";
pub const PW_KEY_APP_PROCESS_SESSION_ID: &[u8; 31] = b"application.process.session-id\0";
pub const PW_KEY_WINDOW_X11_DISPLAY: &[u8; 19] = b"window.x11.display\0";
pub const PW_KEY_CLIENT_ID: &[u8; 10] = b"client.id\0";
pub const PW_KEY_CLIENT_NAME: &[u8; 12] = b"client.name\0";
pub const PW_KEY_CLIENT_API: &[u8; 11] = b"client.api\0";
pub const PW_KEY_NODE_ID: &[u8; 8] = b"node.id\0";
pub const PW_KEY_NODE_NAME: &[u8; 10] = b"node.name\0";
pub const PW_KEY_NODE_NICK: &[u8; 10] = b"node.nick\0";
pub const PW_KEY_NODE_DESCRIPTION: &[u8; 17] = b"node.description\0";
pub const PW_KEY_NODE_PLUGGED: &[u8; 13] = b"node.plugged\0";
pub const PW_KEY_NODE_SESSION: &[u8; 13] = b"node.session\0";
pub const PW_KEY_NODE_GROUP: &[u8; 11] = b"node.group\0";
pub const PW_KEY_NODE_SYNC_GROUP: &[u8; 16] = b"node.sync-group\0";
pub const PW_KEY_NODE_SYNC: &[u8; 10] = b"node.sync\0";
pub const PW_KEY_NODE_TRANSPORT: &[u8; 15] = b"node.transport\0";
pub const PW_KEY_NODE_EXCLUSIVE: &[u8; 15] = b"node.exclusive\0";
pub const PW_KEY_NODE_AUTOCONNECT: &[u8; 17] = b"node.autoconnect\0";
pub const PW_KEY_NODE_LATENCY: &[u8; 13] = b"node.latency\0";
pub const PW_KEY_NODE_MAX_LATENCY: &[u8; 17] = b"node.max-latency\0";
pub const PW_KEY_NODE_LOCK_QUANTUM: &[u8; 18] = b"node.lock-quantum\0";
pub const PW_KEY_NODE_FORCE_QUANTUM: &[u8; 19] = b"node.force-quantum\0";
pub const PW_KEY_NODE_RATE: &[u8; 10] = b"node.rate\0";
pub const PW_KEY_NODE_LOCK_RATE: &[u8; 15] = b"node.lock-rate\0";
pub const PW_KEY_NODE_FORCE_RATE: &[u8; 16] = b"node.force-rate\0";
pub const PW_KEY_NODE_DONT_RECONNECT: &[u8; 20] = b"node.dont-reconnect\0";
pub const PW_KEY_NODE_ALWAYS_PROCESS: &[u8; 20] = b"node.always-process\0";
pub const PW_KEY_NODE_WANT_DRIVER: &[u8; 17] = b"node.want-driver\0";
pub const PW_KEY_NODE_PAUSE_ON_IDLE: &[u8; 19] = b"node.pause-on-idle\0";
pub const PW_KEY_NODE_SUSPEND_ON_IDLE: &[u8; 21] = b"node.suspend-on-idle\0";
pub const PW_KEY_NODE_CACHE_PARAMS: &[u8; 18] = b"node.cache-params\0";
pub const PW_KEY_NODE_TRANSPORT_SYNC: &[u8; 20] = b"node.transport.sync\0";
pub const PW_KEY_NODE_DRIVER: &[u8; 12] = b"node.driver\0";
pub const PW_KEY_NODE_SUPPORTS_LAZY: &[u8; 19] = b"node.supports-lazy\0";
pub const PW_KEY_NODE_SUPPORTS_REQUEST: &[u8; 22] = b"node.supports-request\0";
pub const PW_KEY_NODE_DRIVER_ID: &[u8; 15] = b"node.driver-id\0";
pub const PW_KEY_NODE_ASYNC: &[u8; 11] = b"node.async\0";
pub const PW_KEY_NODE_LOOP_NAME: &[u8; 15] = b"node.loop.name\0";
pub const PW_KEY_NODE_LOOP_CLASS: &[u8; 16] = b"node.loop.class\0";
pub const PW_KEY_NODE_STREAM: &[u8; 12] = b"node.stream\0";
pub const PW_KEY_NODE_VIRTUAL: &[u8; 13] = b"node.virtual\0";
pub const PW_KEY_NODE_PASSIVE: &[u8; 13] = b"node.passive\0";
pub const PW_KEY_NODE_LINK_GROUP: &[u8; 16] = b"node.link-group\0";
pub const PW_KEY_NODE_NETWORK: &[u8; 13] = b"node.network\0";
pub const PW_KEY_NODE_TRIGGER: &[u8; 13] = b"node.trigger\0";
pub const PW_KEY_NODE_CHANNELNAMES: &[u8; 19] = b"node.channel-names\0";
pub const PW_KEY_NODE_DEVICE_PORT_NAME_PREFIX: &[u8; 29] = b"node.device-port-name-prefix\0";
pub const PW_KEY_PORT_ID: &[u8; 8] = b"port.id\0";
pub const PW_KEY_PORT_NAME: &[u8; 10] = b"port.name\0";
pub const PW_KEY_PORT_DIRECTION: &[u8; 15] = b"port.direction\0";
pub const PW_KEY_PORT_ALIAS: &[u8; 11] = b"port.alias\0";
pub const PW_KEY_PORT_PHYSICAL: &[u8; 14] = b"port.physical\0";
pub const PW_KEY_PORT_TERMINAL: &[u8; 14] = b"port.terminal\0";
pub const PW_KEY_PORT_CONTROL: &[u8; 13] = b"port.control\0";
pub const PW_KEY_PORT_MONITOR: &[u8; 13] = b"port.monitor\0";
pub const PW_KEY_PORT_CACHE_PARAMS: &[u8; 18] = b"port.cache-params\0";
pub const PW_KEY_PORT_EXTRA: &[u8; 11] = b"port.extra\0";
pub const PW_KEY_PORT_PASSIVE: &[u8; 13] = b"port.passive\0";
pub const PW_KEY_PORT_IGNORE_LATENCY: &[u8; 20] = b"port.ignore-latency\0";
pub const PW_KEY_PORT_GROUP: &[u8; 11] = b"port.group\0";
pub const PW_KEY_LINK_ID: &[u8; 8] = b"link.id\0";
pub const PW_KEY_LINK_INPUT_NODE: &[u8; 16] = b"link.input.node\0";
pub const PW_KEY_LINK_INPUT_PORT: &[u8; 16] = b"link.input.port\0";
pub const PW_KEY_LINK_OUTPUT_NODE: &[u8; 17] = b"link.output.node\0";
pub const PW_KEY_LINK_OUTPUT_PORT: &[u8; 17] = b"link.output.port\0";
pub const PW_KEY_LINK_PASSIVE: &[u8; 13] = b"link.passive\0";
pub const PW_KEY_LINK_FEEDBACK: &[u8; 14] = b"link.feedback\0";
pub const PW_KEY_LINK_ASYNC: &[u8; 11] = b"link.async\0";
pub const PW_KEY_DEVICE_ID: &[u8; 10] = b"device.id\0";
pub const PW_KEY_DEVICE_NAME: &[u8; 12] = b"device.name\0";
pub const PW_KEY_DEVICE_PLUGGED: &[u8; 15] = b"device.plugged\0";
pub const PW_KEY_DEVICE_NICK: &[u8; 12] = b"device.nick\0";
pub const PW_KEY_DEVICE_STRING: &[u8; 14] = b"device.string\0";
pub const PW_KEY_DEVICE_API: &[u8; 11] = b"device.api\0";
pub const PW_KEY_DEVICE_DESCRIPTION: &[u8; 19] = b"device.description\0";
pub const PW_KEY_DEVICE_BUS_PATH: &[u8; 16] = b"device.bus-path\0";
pub const PW_KEY_DEVICE_SERIAL: &[u8; 14] = b"device.serial\0";
pub const PW_KEY_DEVICE_VENDOR_ID: &[u8; 17] = b"device.vendor.id\0";
pub const PW_KEY_DEVICE_VENDOR_NAME: &[u8; 19] = b"device.vendor.name\0";
pub const PW_KEY_DEVICE_PRODUCT_ID: &[u8; 18] = b"device.product.id\0";
pub const PW_KEY_DEVICE_PRODUCT_NAME: &[u8; 20] = b"device.product.name\0";
pub const PW_KEY_DEVICE_CLASS: &[u8; 13] = b"device.class\0";
pub const PW_KEY_DEVICE_FORM_FACTOR: &[u8; 19] = b"device.form-factor\0";
pub const PW_KEY_DEVICE_BUS: &[u8; 11] = b"device.bus\0";
pub const PW_KEY_DEVICE_SUBSYSTEM: &[u8; 17] = b"device.subsystem\0";
pub const PW_KEY_DEVICE_SYSFS_PATH: &[u8; 18] = b"device.sysfs.path\0";
pub const PW_KEY_DEVICE_ICON: &[u8; 12] = b"device.icon\0";
pub const PW_KEY_DEVICE_ICON_NAME: &[u8; 17] = b"device.icon-name\0";
pub const PW_KEY_DEVICE_INTENDED_ROLES: &[u8; 22] = b"device.intended-roles\0";
pub const PW_KEY_DEVICE_CACHE_PARAMS: &[u8; 20] = b"device.cache-params\0";
pub const PW_KEY_MODULE_ID: &[u8; 10] = b"module.id\0";
pub const PW_KEY_MODULE_NAME: &[u8; 12] = b"module.name\0";
pub const PW_KEY_MODULE_AUTHOR: &[u8; 14] = b"module.author\0";
pub const PW_KEY_MODULE_DESCRIPTION: &[u8; 19] = b"module.description\0";
pub const PW_KEY_MODULE_USAGE: &[u8; 13] = b"module.usage\0";
pub const PW_KEY_MODULE_VERSION: &[u8; 15] = b"module.version\0";
pub const PW_KEY_MODULE_DEPRECATED: &[u8; 18] = b"module.deprecated\0";
pub const PW_KEY_FACTORY_ID: &[u8; 11] = b"factory.id\0";
pub const PW_KEY_FACTORY_NAME: &[u8; 13] = b"factory.name\0";
pub const PW_KEY_FACTORY_USAGE: &[u8; 14] = b"factory.usage\0";
pub const PW_KEY_FACTORY_TYPE_NAME: &[u8; 18] = b"factory.type.name\0";
pub const PW_KEY_FACTORY_TYPE_VERSION: &[u8; 21] = b"factory.type.version\0";
pub const PW_KEY_STREAM_IS_LIVE: &[u8; 15] = b"stream.is-live\0";
pub const PW_KEY_STREAM_LATENCY_MIN: &[u8; 19] = b"stream.latency.min\0";
pub const PW_KEY_STREAM_LATENCY_MAX: &[u8; 19] = b"stream.latency.max\0";
pub const PW_KEY_STREAM_MONITOR: &[u8; 15] = b"stream.monitor\0";
pub const PW_KEY_STREAM_DONT_REMIX: &[u8; 18] = b"stream.dont-remix\0";
pub const PW_KEY_STREAM_CAPTURE_SINK: &[u8; 20] = b"stream.capture.sink\0";
pub const PW_KEY_MEDIA_TYPE: &[u8; 11] = b"media.type\0";
pub const PW_KEY_MEDIA_CATEGORY: &[u8; 15] = b"media.category\0";
pub const PW_KEY_MEDIA_ROLE: &[u8; 11] = b"media.role\0";
pub const PW_KEY_MEDIA_CLASS: &[u8; 12] = b"media.class\0";
pub const PW_KEY_MEDIA_NAME: &[u8; 11] = b"media.name\0";
pub const PW_KEY_MEDIA_TITLE: &[u8; 12] = b"media.title\0";
pub const PW_KEY_MEDIA_ARTIST: &[u8; 13] = b"media.artist\0";
pub const PW_KEY_MEDIA_ALBUM: &[u8; 12] = b"media.album\0";
pub const PW_KEY_MEDIA_COPYRIGHT: &[u8; 16] = b"media.copyright\0";
pub const PW_KEY_MEDIA_SOFTWARE: &[u8; 15] = b"media.software\0";
pub const PW_KEY_MEDIA_LANGUAGE: &[u8; 15] = b"media.language\0";
pub const PW_KEY_MEDIA_FILENAME: &[u8; 15] = b"media.filename\0";
pub const PW_KEY_MEDIA_ICON: &[u8; 11] = b"media.icon\0";
pub const PW_KEY_MEDIA_ICON_NAME: &[u8; 16] = b"media.icon-name\0";
pub const PW_KEY_MEDIA_COMMENT: &[u8; 14] = b"media.comment\0";
pub const PW_KEY_MEDIA_DATE: &[u8; 11] = b"media.date\0";
pub const PW_KEY_MEDIA_FORMAT: &[u8; 13] = b"media.format\0";
pub const PW_KEY_FORMAT_DSP: &[u8; 11] = b"format.dsp\0";
pub const PW_KEY_AUDIO_CHANNEL: &[u8; 14] = b"audio.channel\0";
pub const PW_KEY_AUDIO_RATE: &[u8; 11] = b"audio.rate\0";
pub const PW_KEY_AUDIO_CHANNELS: &[u8; 15] = b"audio.channels\0";
pub const PW_KEY_AUDIO_FORMAT: &[u8; 13] = b"audio.format\0";
pub const PW_KEY_AUDIO_ALLOWED_RATES: &[u8; 20] = b"audio.allowed-rates\0";
pub const PW_KEY_VIDEO_RATE: &[u8; 16] = b"video.framerate\0";
pub const PW_KEY_VIDEO_FORMAT: &[u8; 13] = b"video.format\0";
pub const PW_KEY_VIDEO_SIZE: &[u8; 11] = b"video.size\0";
pub const PW_KEY_TARGET_OBJECT: &[u8; 14] = b"target.object\0";
pub const SPA_TYPE_INTERFACE_Log: &[u8; 26] = b"Spa:Pointer:Interface:Log\0";
pub const SPA_VERSION_LOG: u32 = 0;
pub const SPA_VERSION_LOG_TOPIC: u32 = 0;
pub const SPA_VERSION_LOG_TOPIC_ENUM: u32 = 0;
pub const SPA_VERSION_LOG_METHODS: u32 = 1;
pub const SPA_LOG_TOPIC_ENUM_NAME: &[u8; 19] = b"spa_log_topic_enum\0";
pub const SPA_KEY_LOG_LEVEL: &[u8; 10] = b"log.level\0";
pub const SPA_KEY_LOG_COLORS: &[u8; 11] = b"log.colors\0";
pub const SPA_KEY_LOG_FILE: &[u8; 9] = b"log.file\0";
pub const SPA_KEY_LOG_TIMESTAMP: &[u8; 14] = b"log.timestamp\0";
pub const SPA_KEY_LOG_LINE: &[u8; 9] = b"log.line\0";
pub const SPA_KEY_LOG_PATTERNS: &[u8; 13] = b"log.patterns\0";
pub const PW_TYPE_INTERFACE_Link: &[u8; 24] = b"PipeWire:Interface:Link\0";
pub const PW_LINK_PERM_MASK: u32 = 320;
pub const PW_VERSION_LINK: u32 = 3;
pub const PW_LINK_CHANGE_MASK_STATE: u32 = 1;
pub const PW_LINK_CHANGE_MASK_FORMAT: u32 = 2;
pub const PW_LINK_CHANGE_MASK_PROPS: u32 = 4;
pub const PW_LINK_CHANGE_MASK_ALL: u32 = 7;
pub const PW_LINK_EVENT_INFO: u32 = 0;
pub const PW_LINK_EVENT_NUM: u32 = 1;
pub const PW_VERSION_LINK_EVENTS: u32 = 0;
pub const PW_LINK_METHOD_ADD_LISTENER: u32 = 0;
pub const PW_LINK_METHOD_NUM: u32 = 1;
pub const PW_VERSION_LINK_METHODS: u32 = 0;
pub const PW_VERSION_MAIN_LOOP_EVENTS: u32 = 0;
pub const PW_TYPE_INTERFACE_Module: &[u8; 26] = b"PipeWire:Interface:Module\0";
pub const PW_MODULE_PERM_MASK: u32 = 264;
pub const PW_VERSION_MODULE: u32 = 3;
pub const PW_MODULE_CHANGE_MASK_PROPS: u32 = 1;
pub const PW_MODULE_CHANGE_MASK_ALL: u32 = 1;
pub const PW_MODULE_EVENT_INFO: u32 = 0;
pub const PW_MODULE_EVENT_NUM: u32 = 1;
pub const PW_VERSION_MODULE_EVENTS: u32 = 0;
pub const PW_MODULE_METHOD_ADD_LISTENER: u32 = 0;
pub const PW_MODULE_METHOD_NUM: u32 = 1;
pub const PW_VERSION_MODULE_METHODS: u32 = 0;
pub const PW_TYPE_INTERFACE_Node: &[u8; 24] = b"PipeWire:Interface:Node\0";
pub const PW_NODE_PERM_MASK: u32 = 472;
pub const PW_VERSION_NODE: u32 = 3;
pub const PW_NODE_CHANGE_MASK_INPUT_PORTS: u32 = 1;
pub const PW_NODE_CHANGE_MASK_OUTPUT_PORTS: u32 = 2;
pub const PW_NODE_CHANGE_MASK_STATE: u32 = 4;
pub const PW_NODE_CHANGE_MASK_PROPS: u32 = 8;
pub const PW_NODE_CHANGE_MASK_PARAMS: u32 = 16;
pub const PW_NODE_CHANGE_MASK_ALL: u32 = 31;
pub const PW_NODE_EVENT_INFO: u32 = 0;
pub const PW_NODE_EVENT_PARAM: u32 = 1;
pub const PW_NODE_EVENT_NUM: u32 = 2;
pub const PW_VERSION_NODE_EVENTS: u32 = 0;
pub const PW_NODE_METHOD_ADD_LISTENER: u32 = 0;
pub const PW_NODE_METHOD_SUBSCRIBE_PARAMS: u32 = 1;
pub const PW_NODE_METHOD_ENUM_PARAMS: u32 = 2;
pub const PW_NODE_METHOD_SET_PARAM: u32 = 3;
pub const PW_NODE_METHOD_SEND_COMMAND: u32 = 4;
pub const PW_NODE_METHOD_NUM: u32 = 5;
pub const PW_VERSION_NODE_METHODS: u32 = 0;
pub const PW_TYPE_INTERFACE_Port: &[u8; 24] = b"PipeWire:Interface:Port\0";
pub const PW_PORT_PERM_MASK: u32 = 328;
pub const PW_VERSION_PORT: u32 = 3;
pub const PW_PORT_CHANGE_MASK_PROPS: u32 = 1;
pub const PW_PORT_CHANGE_MASK_PARAMS: u32 = 2;
pub const PW_PORT_CHANGE_MASK_ALL: u32 = 3;
pub const PW_PORT_EVENT_INFO: u32 = 0;
pub const PW_PORT_EVENT_PARAM: u32 = 1;
pub const PW_PORT_EVENT_NUM: u32 = 2;
pub const PW_VERSION_PORT_EVENTS: u32 = 0;
pub const PW_PORT_METHOD_ADD_LISTENER: u32 = 0;
pub const PW_PORT_METHOD_SUBSCRIBE_PARAMS: u32 = 1;
pub const PW_PORT_METHOD_ENUM_PARAMS: u32 = 2;
pub const PW_PORT_METHOD_NUM: u32 = 3;
pub const PW_VERSION_PORT_METHODS: u32 = 0;
pub const PW_VERSION_STREAM_EVENTS: u32 = 2;
pub const SPA_STATUS_OK: u32 = 0;
pub const SPA_STATUS_NEED_DATA: u32 = 1;
pub const SPA_STATUS_HAVE_DATA: u32 = 2;
pub const SPA_STATUS_STOPPED: u32 = 4;
pub const SPA_STATUS_DRAINED: u32 = 8;
pub const SPA_IO_CLOCK_FLAG_FREEWHEEL: u32 = 1;
pub const SPA_IO_CLOCK_FLAG_XRUN_RECOVER: u32 = 2;
pub const SPA_IO_CLOCK_FLAG_LAZY: u32 = 4;
pub const SPA_IO_CLOCK_FLAG_NO_RATE: u32 = 8;
pub const SPA_IO_VIDEO_SIZE_VALID: u32 = 1;
pub const SPA_IO_SEGMENT_BAR_FLAG_VALID: u32 = 1;
pub const SPA_IO_SEGMENT_VIDEO_FLAG_VALID: u32 = 1;
pub const SPA_IO_SEGMENT_VIDEO_FLAG_DROP_FRAME: u32 = 2;
pub const SPA_IO_SEGMENT_VIDEO_FLAG_PULL_DOWN: u32 = 4;
pub const SPA_IO_SEGMENT_VIDEO_FLAG_INTERLACED: u32 = 8;
pub const SPA_IO_SEGMENT_FLAG_LOOPING: u32 = 1;
pub const SPA_IO_SEGMENT_FLAG_NO_POSITION: u32 = 2;
pub const SPA_IO_POSITION_MAX_SEGMENTS: u32 = 8;
pub const SPA_IO_RATE_MATCH_FLAG_ACTIVE: u32 = 1;
pub const PW_VERSION_FILTER_EVENTS: u32 = 1;
pub const PW_VERSION_THREAD_LOOP_EVENTS: u32 = 0;
pub const SPA_TYPE_INFO_Thread: &[u8; 19] = b"Spa:Pointer:Thread\0";
pub const SPA_TYPE_INTERFACE_ThreadUtils: &[u8; 34] = b"Spa:Pointer:Interface:ThreadUtils\0";
pub const SPA_VERSION_THREAD_UTILS: u32 = 0;
pub const SPA_VERSION_THREAD_UTILS_METHODS: u32 = 0;
pub const SPA_KEY_THREAD_NAME: &[u8; 12] = b"thread.name\0";
pub const SPA_KEY_THREAD_STACK_SIZE: &[u8; 18] = b"thread.stack-size\0";
pub const SPA_KEY_THREAD_AFFINITY: &[u8; 16] = b"thread.affinity\0";
pub const SPA_KEY_THREAD_CREATOR: &[u8; 15] = b"thread.creator\0";
pub const PW_VERSION_DATA_LOOP_EVENTS: u32 = 0;
pub const PW_API_VERSION: &[u8; 4] = b"0.3\0";
pub const PW_MAJOR: u32 = 1;
pub const PW_MINOR: u32 = 4;
pub const PW_MICRO: u32 = 2;
pub const PW_TYPE_INTERFACE_ClientNode: &[u8; 30] = b"PipeWire:Interface:ClientNode\0";
pub const PW_VERSION_CLIENT_NODE: u32 = 6;
pub const PW_CLIENT_NODE_EVENT_TRANSPORT: u32 = 0;
pub const PW_CLIENT_NODE_EVENT_SET_PARAM: u32 = 1;
pub const PW_CLIENT_NODE_EVENT_SET_IO: u32 = 2;
pub const PW_CLIENT_NODE_EVENT_EVENT: u32 = 3;
pub const PW_CLIENT_NODE_EVENT_COMMAND: u32 = 4;
pub const PW_CLIENT_NODE_EVENT_ADD_PORT: u32 = 5;
pub const PW_CLIENT_NODE_EVENT_REMOVE_PORT: u32 = 6;
pub const PW_CLIENT_NODE_EVENT_PORT_SET_PARAM: u32 = 7;
pub const PW_CLIENT_NODE_EVENT_PORT_USE_BUFFERS: u32 = 8;
pub const PW_CLIENT_NODE_EVENT_PORT_SET_IO: u32 = 9;
pub const PW_CLIENT_NODE_EVENT_SET_ACTIVATION: u32 = 10;
pub const PW_CLIENT_NODE_EVENT_PORT_SET_MIX_INFO: u32 = 11;
pub const PW_CLIENT_NODE_EVENT_NUM: u32 = 12;
pub const PW_VERSION_CLIENT_NODE_EVENTS: u32 = 1;
pub const PW_CLIENT_NODE_METHOD_ADD_LISTENER: u32 = 0;
pub const PW_CLIENT_NODE_METHOD_GET_NODE: u32 = 1;
pub const PW_CLIENT_NODE_METHOD_UPDATE: u32 = 2;
pub const PW_CLIENT_NODE_METHOD_PORT_UPDATE: u32 = 3;
pub const PW_CLIENT_NODE_METHOD_SET_ACTIVE: u32 = 4;
pub const PW_CLIENT_NODE_METHOD_EVENT: u32 = 5;
pub const PW_CLIENT_NODE_METHOD_PORT_BUFFERS: u32 = 6;
pub const PW_CLIENT_NODE_METHOD_NUM: u32 = 7;
pub const PW_VERSION_CLIENT_NODE_METHODS: u32 = 0;
pub const PW_CLIENT_NODE_UPDATE_PARAMS: u32 = 1;
pub const PW_CLIENT_NODE_UPDATE_INFO: u32 = 2;
pub const PW_CLIENT_NODE_PORT_UPDATE_PARAMS: u32 = 1;
pub const PW_CLIENT_NODE_PORT_UPDATE_INFO: u32 = 2;
pub const PW_TYPE_INTERFACE_Metadata: &[u8; 28] = b"PipeWire:Interface:Metadata\0";
pub const PW_METADATA_PERM_MASK: u32 = 448;
pub const PW_VERSION_METADATA: u32 = 3;
pub const PW_METADATA_EVENT_PROPERTY: u32 = 0;
pub const PW_METADATA_EVENT_NUM: u32 = 1;
pub const PW_VERSION_METADATA_EVENTS: u32 = 0;
pub const PW_METADATA_METHOD_ADD_LISTENER: u32 = 0;
pub const PW_METADATA_METHOD_SET_PROPERTY: u32 = 1;
pub const PW_METADATA_METHOD_CLEAR: u32 = 2;
pub const PW_METADATA_METHOD_NUM: u32 = 3;
pub const PW_VERSION_METADATA_METHODS: u32 = 0;
pub const PW_KEY_METADATA_NAME: &[u8; 14] = b"metadata.name\0";
pub const PW_KEY_METADATA_VALUES: &[u8; 16] = b"metadata.values\0";
pub const PW_TYPE_INTERFACE_Profiler: &[u8; 28] = b"PipeWire:Interface:Profiler\0";
pub const PW_VERSION_PROFILER: u32 = 3;
pub const PW_PROFILER_PERM_MASK: u32 = 256;
pub const PW_PROFILER_EVENT_PROFILE: u32 = 0;
pub const PW_PROFILER_EVENT_NUM: u32 = 1;
pub const PW_VERSION_PROFILER_EVENTS: u32 = 0;
pub const PW_PROFILER_METHOD_ADD_LISTENER: u32 = 0;
pub const PW_PROFILER_METHOD_NUM: u32 = 1;
pub const PW_VERSION_PROFILER_METHODS: u32 = 0;
pub const PW_KEY_PROFILER_NAME: &[u8; 14] = b"profiler.name\0";
pub const PW_VERSION_CONTROL_EVENTS: u32 = 0;
pub const PW_VERSION_IMPL_CORE_EVENTS: u32 = 0;
pub const SPA_TYPE_INTERFACE_Device: &[u8; 29] = b"Spa:Pointer:Interface:Device\0";
pub const SPA_VERSION_DEVICE: u32 = 0;
pub const SPA_VERSION_DEVICE_INFO: u32 = 0;
pub const SPA_DEVICE_CHANGE_MASK_FLAGS: u32 = 1;
pub const SPA_DEVICE_CHANGE_MASK_PROPS: u32 = 2;
pub const SPA_DEVICE_CHANGE_MASK_PARAMS: u32 = 4;
pub const SPA_VERSION_DEVICE_OBJECT_INFO: u32 = 0;
pub const SPA_DEVICE_OBJECT_CHANGE_MASK_FLAGS: u32 = 1;
pub const SPA_DEVICE_OBJECT_CHANGE_MASK_PROPS: u32 = 2;
pub const SPA_RESULT_TYPE_DEVICE_PARAMS: u32 = 1;
pub const SPA_DEVICE_EVENT_INFO: u32 = 0;
pub const SPA_DEVICE_EVENT_RESULT: u32 = 1;
pub const SPA_DEVICE_EVENT_EVENT: u32 = 2;
pub const SPA_DEVICE_EVENT_OBJECT_INFO: u32 = 3;
pub const SPA_DEVICE_EVENT_NUM: u32 = 4;
pub const SPA_VERSION_DEVICE_EVENTS: u32 = 0;
pub const SPA_DEVICE_METHOD_ADD_LISTENER: u32 = 0;
pub const SPA_DEVICE_METHOD_SYNC: u32 = 1;
pub const SPA_DEVICE_METHOD_ENUM_PARAMS: u32 = 2;
pub const SPA_DEVICE_METHOD_SET_PARAM: u32 = 3;
pub const SPA_DEVICE_METHOD_NUM: u32 = 4;
pub const SPA_VERSION_DEVICE_METHODS: u32 = 0;
pub const SPA_KEY_DEVICE_ENUM_API: &[u8; 16] = b"device.enum.api\0";
pub const SPA_KEY_DEVICE_API: &[u8; 11] = b"device.api\0";
pub const SPA_KEY_DEVICE_NAME: &[u8; 12] = b"device.name\0";
pub const SPA_KEY_DEVICE_ALIAS: &[u8; 13] = b"device.alias\0";
pub const SPA_KEY_DEVICE_NICK: &[u8; 12] = b"device.nick\0";
pub const SPA_KEY_DEVICE_DESCRIPTION: &[u8; 19] = b"device.description\0";
pub const SPA_KEY_DEVICE_ICON: &[u8; 12] = b"device.icon\0";
pub const SPA_KEY_DEVICE_ICON_NAME: &[u8; 17] = b"device.icon-name\0";
pub const SPA_KEY_DEVICE_PLUGGED_USEC: &[u8; 20] = b"device.plugged.usec\0";
pub const SPA_KEY_DEVICE_BUS_ID: &[u8; 14] = b"device.bus-id\0";
pub const SPA_KEY_DEVICE_BUS_PATH: &[u8; 16] = b"device.bus-path\0";
pub const SPA_KEY_DEVICE_BUS: &[u8; 11] = b"device.bus\0";
pub const SPA_KEY_DEVICE_SUBSYSTEM: &[u8; 17] = b"device.subsystem\0";
pub const SPA_KEY_DEVICE_SYSFS_PATH: &[u8; 18] = b"device.sysfs.path\0";
pub const SPA_KEY_DEVICE_VENDOR_ID: &[u8; 17] = b"device.vendor.id\0";
pub const SPA_KEY_DEVICE_VENDOR_NAME: &[u8; 19] = b"device.vendor.name\0";
pub const SPA_KEY_DEVICE_PRODUCT_ID: &[u8; 18] = b"device.product.id\0";
pub const SPA_KEY_DEVICE_PRODUCT_NAME: &[u8; 20] = b"device.product.name\0";
pub const SPA_KEY_DEVICE_SERIAL: &[u8; 14] = b"device.serial\0";
pub const SPA_KEY_DEVICE_CLASS: &[u8; 13] = b"device.class\0";
pub const SPA_KEY_DEVICE_CAPABILITIES: &[u8; 20] = b"device.capabilities\0";
pub const SPA_KEY_DEVICE_FORM_FACTOR: &[u8; 19] = b"device.form-factor\0";
pub const SPA_KEY_DEVICE_PROFILE: &[u8; 15] = b"device.profile\0";
pub const SPA_KEY_DEVICE_PROFILE_SET: &[u8; 19] = b"device.profile-set\0";
pub const SPA_KEY_DEVICE_STRING: &[u8; 14] = b"device.string\0";
pub const SPA_KEY_DEVICE_DEVIDS: &[u8; 14] = b"device.devids\0";
pub const PW_VERSION_IMPL_DEVICE_EVENTS: u32 = 0;
pub const PW_VERSION_IMPL_FACTORY_EVENTS: u32 = 0;
pub const PW_VERSION_IMPL_FACTORY_IMPLEMENTATION: u32 = 0;
pub const PW_VERSION_IMPL_LINK_EVENTS: u32 = 0;
pub const PW_VERSION_IMPL_METADATA_EVENTS: u32 = 0;
pub const PIPEWIRE_SYMBOL_MODULE_INIT: &[u8; 22] = b"pipewire__module_init\0";
pub const PIPEWIRE_MODULE_PREFIX: &[u8; 13] = b"libpipewire-\0";
pub const PW_VERSION_IMPL_MODULE_EVENTS: u32 = 0;
pub const PW_VERSION_IMPL_NODE_EVENTS: u32 = 0;
pub const PW_VERSION_IMPL_NODE_RT_EVENTS: u32 = 0;
pub const PW_VERSION_IMPL_PORT_EVENTS: u32 = 3;
pub const PW_VERSION_GLOBAL_EVENTS: u32 = 0;
pub const PW_VERSION_IMPL_CLIENT_EVENTS: u32 = 0;
pub const PW_VERSION_RESOURCE_EVENTS: u32 = 0;
pub const PW_TYPE_INFO_PROTOCOL_Native: &[u8; 25] = b"PipeWire:Protocol:Native\0";
pub const PW_VERSION_PROTOCOL_NATIVE_EXT: u32 = 0;
pub const PW_VERSION_SESSION_INFO: u32 = 0;
pub const PW_SESSION_CHANGE_MASK_PROPS: u32 = 1;
pub const PW_SESSION_CHANGE_MASK_PARAMS: u32 = 2;
pub const PW_SESSION_CHANGE_MASK_ALL: u32 = 3;
pub const PW_VERSION_ENDPOINT_INFO: u32 = 0;
pub const PW_ENDPOINT_FLAG_PROVIDES_SESSION: u32 = 1;
pub const PW_ENDPOINT_CHANGE_MASK_STREAMS: u32 = 1;
pub const PW_ENDPOINT_CHANGE_MASK_SESSION: u32 = 2;
pub const PW_ENDPOINT_CHANGE_MASK_PROPS: u32 = 4;
pub const PW_ENDPOINT_CHANGE_MASK_PARAMS: u32 = 8;
pub const PW_ENDPOINT_CHANGE_MASK_ALL: u32 = 15;
pub const PW_VERSION_ENDPOINT_STREAM_INFO: u32 = 0;
pub const PW_ENDPOINT_STREAM_CHANGE_MASK_LINK_PARAMS: u32 = 1;
pub const PW_ENDPOINT_STREAM_CHANGE_MASK_PROPS: u32 = 2;
pub const PW_ENDPOINT_STREAM_CHANGE_MASK_PARAMS: u32 = 4;
pub const PW_ENDPOINT_STREAM_CHANGE_MASK_ALL: u32 = 7;
pub const PW_VERSION_ENDPOINT_LINK_INFO: u32 = 0;
pub const PW_ENDPOINT_LINK_CHANGE_MASK_STATE: u32 = 1;
pub const PW_ENDPOINT_LINK_CHANGE_MASK_PROPS: u32 = 2;
pub const PW_ENDPOINT_LINK_CHANGE_MASK_PARAMS: u32 = 4;
pub const PW_ENDPOINT_LINK_CHANGE_MASK_ALL: u32 = 7;
pub const PW_TYPE_INTERFACE_Session: &[u8; 27] = b"PipeWire:Interface:Session\0";
pub const PW_SESSION_PERM_MASK: u32 = 448;
pub const PW_VERSION_SESSION: u32 = 0;
pub const PW_TYPE_INTERFACE_Endpoint: &[u8; 28] = b"PipeWire:Interface:Endpoint\0";
pub const PW_ENDPOINT_PERM_MASK: u32 = 448;
pub const PW_VERSION_ENDPOINT: u32 = 0;
pub const PW_TYPE_INTERFACE_EndpointStream: &[u8; 34] = b"PipeWire:Interface:EndpointStream\0";
pub const PW_ENDPOINT_STREAM_PERM_MASK: u32 = 448;
pub const PW_VERSION_ENDPOINT_STREAM: u32 = 0;
pub const PW_TYPE_INTERFACE_EndpointLink: &[u8; 32] = b"PipeWire:Interface:EndpointLink\0";
pub const PW_ENDPOINT_LINK_PERM_MASK: u32 = 448;
pub const PW_VERSION_ENDPOINT_LINK: u32 = 0;
pub const PW_SESSION_EVENT_INFO: u32 = 0;
pub const PW_SESSION_EVENT_PARAM: u32 = 1;
pub const PW_SESSION_EVENT_NUM: u32 = 2;
pub const PW_VERSION_SESSION_EVENTS: u32 = 0;
pub const PW_SESSION_METHOD_ADD_LISTENER: u32 = 0;
pub const PW_SESSION_METHOD_SUBSCRIBE_PARAMS: u32 = 1;
pub const PW_SESSION_METHOD_ENUM_PARAMS: u32 = 2;
pub const PW_SESSION_METHOD_SET_PARAM: u32 = 3;
pub const PW_SESSION_METHOD_CREATE_LINK: u32 = 4;
pub const PW_SESSION_METHOD_NUM: u32 = 5;
pub const PW_VERSION_SESSION_METHODS: u32 = 0;
pub const PW_ENDPOINT_EVENT_INFO: u32 = 0;
pub const PW_ENDPOINT_EVENT_PARAM: u32 = 1;
pub const PW_ENDPOINT_EVENT_NUM: u32 = 2;
pub const PW_VERSION_ENDPOINT_EVENTS: u32 = 0;
pub const PW_ENDPOINT_METHOD_ADD_LISTENER: u32 = 0;
pub const PW_ENDPOINT_METHOD_SUBSCRIBE_PARAMS: u32 = 1;
pub const PW_ENDPOINT_METHOD_ENUM_PARAMS: u32 = 2;
pub const PW_ENDPOINT_METHOD_SET_PARAM: u32 = 3;
pub const PW_ENDPOINT_METHOD_CREATE_LINK: u32 = 4;
pub const PW_ENDPOINT_METHOD_NUM: u32 = 5;
pub const PW_VERSION_ENDPOINT_METHODS: u32 = 0;
pub const PW_ENDPOINT_STREAM_EVENT_INFO: u32 = 0;
pub const PW_ENDPOINT_STREAM_EVENT_PARAM: u32 = 1;
pub const PW_ENDPOINT_STREAM_EVENT_NUM: u32 = 2;
pub const PW_VERSION_ENDPOINT_STREAM_EVENTS: u32 = 0;
pub const PW_ENDPOINT_STREAM_METHOD_ADD_LISTENER: u32 = 0;
pub const PW_ENDPOINT_STREAM_METHOD_SUBSCRIBE_PARAMS: u32 = 1;
pub const PW_ENDPOINT_STREAM_METHOD_ENUM_PARAMS: u32 = 2;
pub const PW_ENDPOINT_STREAM_METHOD_SET_PARAM: u32 = 3;
pub const PW_ENDPOINT_STREAM_METHOD_NUM: u32 = 4;
pub const PW_VERSION_ENDPOINT_STREAM_METHODS: u32 = 0;
pub const PW_ENDPOINT_LINK_EVENT_INFO: u32 = 0;
pub const PW_ENDPOINT_LINK_EVENT_PARAM: u32 = 1;
pub const PW_ENDPOINT_LINK_EVENT_NUM: u32 = 2;
pub const PW_VERSION_ENDPOINT_LINK_EVENTS: u32 = 0;
pub const PW_ENDPOINT_LINK_METHOD_ADD_LISTENER: u32 = 0;
pub const PW_ENDPOINT_LINK_METHOD_SUBSCRIBE_PARAMS: u32 = 1;
pub const PW_ENDPOINT_LINK_METHOD_ENUM_PARAMS: u32 = 2;
pub const PW_ENDPOINT_LINK_METHOD_SET_PARAM: u32 = 3;
pub const PW_ENDPOINT_LINK_METHOD_REQUEST_STATE: u32 = 4;
pub const PW_ENDPOINT_LINK_METHOD_DESTROY: u32 = 5;
pub const PW_ENDPOINT_LINK_METHOD_NUM: u32 = 6;
pub const PW_VERSION_ENDPOINT_LINK_METHODS: u32 = 0;
pub const PW_TYPE_INTERFACE_ClientEndpoint: &[u8; 34] = b"PipeWire:Interface:ClientEndpoint\0";
pub const PW_VERSION_CLIENT_ENDPOINT: u32 = 0;
pub const PW_CLIENT_ENDPOINT_EVENT_SET_SESSION_ID: u32 = 0;
pub const PW_CLIENT_ENDPOINT_EVENT_SET_PARAM: u32 = 1;
pub const PW_CLIENT_ENDPOINT_EVENT_STREAM_SET_PARAM: u32 = 2;
pub const PW_CLIENT_ENDPOINT_EVENT_CREATE_LINK: u32 = 3;
pub const PW_CLIENT_ENDPOINT_EVENT_NUM: u32 = 4;
pub const PW_VERSION_CLIENT_ENDPOINT_EVENTS: u32 = 0;
pub const PW_CLIENT_ENDPOINT_METHOD_ADD_LISTENER: u32 = 0;
pub const PW_CLIENT_ENDPOINT_METHOD_UPDATE: u32 = 1;
pub const PW_CLIENT_ENDPOINT_METHOD_STREAM_UPDATE: u32 = 2;
pub const PW_CLIENT_ENDPOINT_METHOD_NUM: u32 = 3;
pub const PW_VERSION_CLIENT_ENDPOINT_METHODS: u32 = 0;
pub const PW_CLIENT_ENDPOINT_UPDATE_PARAMS: u32 = 1;
pub const PW_CLIENT_ENDPOINT_UPDATE_INFO: u32 = 2;
pub const PW_CLIENT_ENDPOINT_STREAM_UPDATE_PARAMS: u32 = 1;
pub const PW_CLIENT_ENDPOINT_STREAM_UPDATE_INFO: u32 = 2;
pub const PW_CLIENT_ENDPOINT_STREAM_UPDATE_DESTROYED: u32 = 4;
pub const PW_TYPE_INTERFACE_ClientSession: &[u8; 33] = b"PipeWire:Interface:ClientSession\0";
pub const PW_VERSION_CLIENT_SESSION: u32 = 0;
pub const PW_CLIENT_SESSION_EVENT_SET_PARAM: u32 = 0;
pub const PW_CLIENT_SESSION_EVENT_LINK_SET_PARAM: u32 = 1;
pub const PW_CLIENT_SESSION_EVENT_LINK_REQUEST_STATE: u32 = 2;
pub const PW_CLIENT_SESSION_EVENT_NUM: u32 = 3;
pub const PW_VERSION_CLIENT_SESSION_EVENTS: u32 = 0;
pub const PW_CLIENT_SESSION_METHOD_ADD_LISTENER: u32 = 0;
pub const PW_CLIENT_SESSION_METHOD_UPDATE: u32 = 1;
pub const PW_CLIENT_SESSION_METHOD_LINK_UPDATE: u32 = 2;
pub const PW_CLIENT_SESSION_METHOD_NUM: u32 = 3;
pub const PW_VERSION_CLIENT_SESSION_METHODS: u32 = 0;
pub const PW_CLIENT_SESSION_UPDATE_PARAMS: u32 = 1;
pub const PW_CLIENT_SESSION_UPDATE_INFO: u32 = 2;
pub const PW_CLIENT_SESSION_LINK_UPDATE_PARAMS: u32 = 1;
pub const PW_CLIENT_SESSION_LINK_UPDATE_INFO: u32 = 2;
pub const PW_CLIENT_SESSION_LINK_UPDATE_DESTROYED: u32 = 4;
pub const PW_KEY_SESSION_ID: &[u8; 11] = b"session.id\0";
pub const PW_KEY_ENDPOINT_ID: &[u8; 12] = b"endpoint.id\0";
pub const PW_KEY_ENDPOINT_NAME: &[u8; 14] = b"endpoint.name\0";
pub const PW_KEY_ENDPOINT_MONITOR: &[u8; 17] = b"endpoint.monitor\0";
pub const PW_KEY_ENDPOINT_CLIENT_ID: &[u8; 19] = b"endpoint.client.id\0";
pub const PW_KEY_ENDPOINT_ICON_NAME: &[u8; 19] = b"endpoint.icon-name\0";
pub const PW_KEY_ENDPOINT_AUTOCONNECT: &[u8; 21] = b"endpoint.autoconnect\0";
pub const PW_KEY_ENDPOINT_TARGET: &[u8; 16] = b"endpoint.target\0";
pub const PW_KEY_ENDPOINT_STREAM_ID: &[u8; 19] = b"endpoint-stream.id\0";
pub const PW_KEY_ENDPOINT_STREAM_NAME: &[u8; 21] = b"endpoint-stream.name\0";
pub const PW_KEY_ENDPOINT_STREAM_DESCRIPTION: &[u8; 28] = b"endpoint-stream.description\0";
pub const PW_KEY_ENDPOINT_LINK_OUTPUT_ENDPOINT: &[u8; 30] = b"endpoint-link.output.endpoint\0";
pub const PW_KEY_ENDPOINT_LINK_OUTPUT_STREAM: &[u8; 28] = b"endpoint-link.output.stream\0";
pub const PW_KEY_ENDPOINT_LINK_INPUT_ENDPOINT: &[u8; 29] = b"endpoint-link.input.endpoint\0";
pub const PW_KEY_ENDPOINT_LINK_INPUT_STREAM: &[u8; 27] = b"endpoint-link.input.stream\0";
unsafe extern "C" {
    pub fn __errno_location() -> *mut ::std::os::raw::c_int;
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __fsid_t"][::std::mem::size_of::<__fsid_t>() - 8usize];
    ["Alignment of __fsid_t"][::std::mem::align_of::<__fsid_t>() - 4usize];
    ["Offset of field: __fsid_t::__val"][::std::mem::offset_of!(__fsid_t, __val) - 0usize];
};
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type __gwchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of imaxdiv_t"][::std::mem::size_of::<imaxdiv_t>() - 16usize];
    ["Alignment of imaxdiv_t"][::std::mem::align_of::<imaxdiv_t>() - 8usize];
    ["Offset of field: imaxdiv_t::quot"][::std::mem::offset_of!(imaxdiv_t, quot) - 0usize];
    ["Offset of field: imaxdiv_t::rem"][::std::mem::offset_of!(imaxdiv_t, rem) - 8usize];
};
unsafe extern "C" {
    pub fn imaxabs(__n: intmax_t) -> intmax_t;
}
unsafe extern "C" {
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
}
unsafe extern "C" {
    pub fn strtoimax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
unsafe extern "C" {
    pub fn strtoumax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
unsafe extern "C" {
    pub fn wcstoimax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
unsafe extern "C" {
    pub fn wcstoumax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
pub type sig_atomic_t = __sig_atomic_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __sigset_t"][::std::mem::size_of::<__sigset_t>() - 128usize];
    ["Alignment of __sigset_t"][::std::mem::align_of::<__sigset_t>() - 8usize];
    ["Offset of field: __sigset_t::__val"][::std::mem::offset_of!(__sigset_t, __val) - 0usize];
};
pub type sigset_t = __sigset_t;
pub type pid_t = __pid_t;
pub type uid_t = __uid_t;
pub type time_t = __time_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of timespec"][::std::mem::size_of::<timespec>() - 16usize];
    ["Alignment of timespec"][::std::mem::align_of::<timespec>() - 8usize];
    ["Offset of field: timespec::tv_sec"][::std::mem::offset_of!(timespec, tv_sec) - 0usize];
    ["Offset of field: timespec::tv_nsec"][::std::mem::offset_of!(timespec, tv_nsec) - 8usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigval {
    pub sival_int: ::std::os::raw::c_int,
    pub sival_ptr: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sigval"][::std::mem::size_of::<sigval>() - 8usize];
    ["Alignment of sigval"][::std::mem::align_of::<sigval>() - 8usize];
    ["Offset of field: sigval::sival_int"][::std::mem::offset_of!(sigval, sival_int) - 0usize];
    ["Offset of field: sigval::sival_ptr"][::std::mem::offset_of!(sigval, sival_ptr) - 0usize];
};
pub type __sigval_t = sigval;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t {
    pub si_signo: ::std::os::raw::c_int,
    pub si_errno: ::std::os::raw::c_int,
    pub si_code: ::std::os::raw::c_int,
    pub __pad0: ::std::os::raw::c_int,
    pub _sifields: siginfo_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union siginfo_t__bindgen_ty_1 {
    pub _pad: [::std::os::raw::c_int; 28usize],
    pub _kill: siginfo_t__bindgen_ty_1__bindgen_ty_1,
    pub _timer: siginfo_t__bindgen_ty_1__bindgen_ty_2,
    pub _rt: siginfo_t__bindgen_ty_1__bindgen_ty_3,
    pub _sigchld: siginfo_t__bindgen_ty_1__bindgen_ty_4,
    pub _sigfault: siginfo_t__bindgen_ty_1__bindgen_ty_5,
    pub _sigpoll: siginfo_t__bindgen_ty_1__bindgen_ty_6,
    pub _sigsys: siginfo_t__bindgen_ty_1__bindgen_ty_7,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_1 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of siginfo_t__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_1>() - 8usize];
    ["Alignment of siginfo_t__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_1>() - 4usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_1::si_pid"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_1, si_pid) - 0usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_1::si_uid"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_1, si_uid) - 4usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_2 {
    pub si_tid: ::std::os::raw::c_int,
    pub si_overrun: ::std::os::raw::c_int,
    pub si_sigval: __sigval_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of siginfo_t__bindgen_ty_1__bindgen_ty_2"]
        [::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_2>() - 16usize];
    ["Alignment of siginfo_t__bindgen_ty_1__bindgen_ty_2"]
        [::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_2>() - 8usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_2::si_tid"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_2, si_tid) - 0usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_2::si_overrun"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_2, si_overrun) - 4usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_2::si_sigval"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_2, si_sigval) - 8usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_3 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
    pub si_sigval: __sigval_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of siginfo_t__bindgen_ty_1__bindgen_ty_3"]
        [::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_3>() - 16usize];
    ["Alignment of siginfo_t__bindgen_ty_1__bindgen_ty_3"]
        [::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_3>() - 8usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_3::si_pid"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_3, si_pid) - 0usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_3::si_uid"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_3, si_uid) - 4usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_3::si_sigval"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_3, si_sigval) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_4 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
    pub si_status: ::std::os::raw::c_int,
    pub si_utime: __clock_t,
    pub si_stime: __clock_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of siginfo_t__bindgen_ty_1__bindgen_ty_4"]
        [::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_4>() - 32usize];
    ["Alignment of siginfo_t__bindgen_ty_1__bindgen_ty_4"]
        [::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_4>() - 8usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_4::si_pid"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_4, si_pid) - 0usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_4::si_uid"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_4, si_uid) - 4usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_4::si_status"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_4, si_status) - 8usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_4::si_utime"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_4, si_utime) - 16usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_4::si_stime"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_4, si_stime) - 24usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_5 {
    pub si_addr: *mut ::std::os::raw::c_void,
    pub si_addr_lsb: ::std::os::raw::c_short,
    pub _bounds: siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 {
    pub _addr_bnd: siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1,
    pub _pkey: __uint32_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 {
    pub _lower: *mut ::std::os::raw::c_void,
    pub _upper: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1>(
        ) - 16usize];
    ["Alignment of siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1>(
        ) - 8usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1::_lower"] [:: std :: mem :: offset_of ! (siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 , _lower) - 0usize] ;
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1::_upper"] [:: std :: mem :: offset_of ! (siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 , _upper) - 8usize] ;
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1"]
        [::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1>() - 16usize];
    ["Alignment of siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1"]
        [::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1>() - 8usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1::_addr_bnd"][::std::mem::offset_of!(
        siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1,
        _addr_bnd
    ) - 0usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1::_pkey"][::std::mem::offset_of!(
        siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1,
        _pkey
    ) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of siginfo_t__bindgen_ty_1__bindgen_ty_5"]
        [::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5>() - 32usize];
    ["Alignment of siginfo_t__bindgen_ty_1__bindgen_ty_5"]
        [::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5>() - 8usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_5::si_addr"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_5, si_addr) - 0usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_5::si_addr_lsb"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_5, si_addr_lsb) - 8usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_5::_bounds"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_5, _bounds) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_6 {
    pub si_band: ::std::os::raw::c_long,
    pub si_fd: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of siginfo_t__bindgen_ty_1__bindgen_ty_6"]
        [::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_6>() - 16usize];
    ["Alignment of siginfo_t__bindgen_ty_1__bindgen_ty_6"]
        [::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_6>() - 8usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_6::si_band"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_6, si_band) - 0usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_6::si_fd"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_6, si_fd) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_7 {
    pub _call_addr: *mut ::std::os::raw::c_void,
    pub _syscall: ::std::os::raw::c_int,
    pub _arch: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of siginfo_t__bindgen_ty_1__bindgen_ty_7"]
        [::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_7>() - 16usize];
    ["Alignment of siginfo_t__bindgen_ty_1__bindgen_ty_7"]
        [::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_7>() - 8usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_7::_call_addr"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_7, _call_addr) - 0usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_7::_syscall"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_7, _syscall) - 8usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_7::_arch"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_7, _arch) - 12usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of siginfo_t__bindgen_ty_1"]
        [::std::mem::size_of::<siginfo_t__bindgen_ty_1>() - 112usize];
    ["Alignment of siginfo_t__bindgen_ty_1"]
        [::std::mem::align_of::<siginfo_t__bindgen_ty_1>() - 8usize];
    ["Offset of field: siginfo_t__bindgen_ty_1::_pad"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1, _pad) - 0usize];
    ["Offset of field: siginfo_t__bindgen_ty_1::_kill"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1, _kill) - 0usize];
    ["Offset of field: siginfo_t__bindgen_ty_1::_timer"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1, _timer) - 0usize];
    ["Offset of field: siginfo_t__bindgen_ty_1::_rt"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1, _rt) - 0usize];
    ["Offset of field: siginfo_t__bindgen_ty_1::_sigchld"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1, _sigchld) - 0usize];
    ["Offset of field: siginfo_t__bindgen_ty_1::_sigfault"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1, _sigfault) - 0usize];
    ["Offset of field: siginfo_t__bindgen_ty_1::_sigpoll"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1, _sigpoll) - 0usize];
    ["Offset of field: siginfo_t__bindgen_ty_1::_sigsys"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1, _sigsys) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of siginfo_t"][::std::mem::size_of::<siginfo_t>() - 128usize];
    ["Alignment of siginfo_t"][::std::mem::align_of::<siginfo_t>() - 8usize];
    ["Offset of field: siginfo_t::si_signo"][::std::mem::offset_of!(siginfo_t, si_signo) - 0usize];
    ["Offset of field: siginfo_t::si_errno"][::std::mem::offset_of!(siginfo_t, si_errno) - 4usize];
    ["Offset of field: siginfo_t::si_code"][::std::mem::offset_of!(siginfo_t, si_code) - 8usize];
    ["Offset of field: siginfo_t::__pad0"][::std::mem::offset_of!(siginfo_t, __pad0) - 12usize];
    ["Offset of field: siginfo_t::_sifields"]
        [::std::mem::offset_of!(siginfo_t, _sifields) - 16usize];
};
pub const SI_ASYNCNL: _bindgen_ty_1 = -60;
pub const SI_DETHREAD: _bindgen_ty_1 = -7;
pub const SI_TKILL: _bindgen_ty_1 = -6;
pub const SI_SIGIO: _bindgen_ty_1 = -5;
pub const SI_ASYNCIO: _bindgen_ty_1 = -4;
pub const SI_MESGQ: _bindgen_ty_1 = -3;
pub const SI_TIMER: _bindgen_ty_1 = -2;
pub const SI_QUEUE: _bindgen_ty_1 = -1;
pub const SI_USER: _bindgen_ty_1 = 0;
pub const SI_KERNEL: _bindgen_ty_1 = 128;
pub type _bindgen_ty_1 = ::std::os::raw::c_int;
pub const ILL_ILLOPC: _bindgen_ty_2 = 1;
pub const ILL_ILLOPN: _bindgen_ty_2 = 2;
pub const ILL_ILLADR: _bindgen_ty_2 = 3;
pub const ILL_ILLTRP: _bindgen_ty_2 = 4;
pub const ILL_PRVOPC: _bindgen_ty_2 = 5;
pub const ILL_PRVREG: _bindgen_ty_2 = 6;
pub const ILL_COPROC: _bindgen_ty_2 = 7;
pub const ILL_BADSTK: _bindgen_ty_2 = 8;
pub const ILL_BADIADDR: _bindgen_ty_2 = 9;
pub type _bindgen_ty_2 = ::std::os::raw::c_uint;
pub const FPE_INTDIV: _bindgen_ty_3 = 1;
pub const FPE_INTOVF: _bindgen_ty_3 = 2;
pub const FPE_FLTDIV: _bindgen_ty_3 = 3;
pub const FPE_FLTOVF: _bindgen_ty_3 = 4;
pub const FPE_FLTUND: _bindgen_ty_3 = 5;
pub const FPE_FLTRES: _bindgen_ty_3 = 6;
pub const FPE_FLTINV: _bindgen_ty_3 = 7;
pub const FPE_FLTSUB: _bindgen_ty_3 = 8;
pub const FPE_FLTUNK: _bindgen_ty_3 = 14;
pub const FPE_CONDTRAP: _bindgen_ty_3 = 15;
pub type _bindgen_ty_3 = ::std::os::raw::c_uint;
pub const SEGV_MAPERR: _bindgen_ty_4 = 1;
pub const SEGV_ACCERR: _bindgen_ty_4 = 2;
pub const SEGV_BNDERR: _bindgen_ty_4 = 3;
pub const SEGV_PKUERR: _bindgen_ty_4 = 4;
pub const SEGV_ACCADI: _bindgen_ty_4 = 5;
pub const SEGV_ADIDERR: _bindgen_ty_4 = 6;
pub const SEGV_ADIPERR: _bindgen_ty_4 = 7;
pub const SEGV_MTEAERR: _bindgen_ty_4 = 8;
pub const SEGV_MTESERR: _bindgen_ty_4 = 9;
pub const SEGV_CPERR: _bindgen_ty_4 = 10;
pub type _bindgen_ty_4 = ::std::os::raw::c_uint;
pub const BUS_ADRALN: _bindgen_ty_5 = 1;
pub const BUS_ADRERR: _bindgen_ty_5 = 2;
pub const BUS_OBJERR: _bindgen_ty_5 = 3;
pub const BUS_MCEERR_AR: _bindgen_ty_5 = 4;
pub const BUS_MCEERR_AO: _bindgen_ty_5 = 5;
pub type _bindgen_ty_5 = ::std::os::raw::c_uint;
pub const CLD_EXITED: _bindgen_ty_6 = 1;
pub const CLD_KILLED: _bindgen_ty_6 = 2;
pub const CLD_DUMPED: _bindgen_ty_6 = 3;
pub const CLD_TRAPPED: _bindgen_ty_6 = 4;
pub const CLD_STOPPED: _bindgen_ty_6 = 5;
pub const CLD_CONTINUED: _bindgen_ty_6 = 6;
pub type _bindgen_ty_6 = ::std::os::raw::c_uint;
pub const POLL_IN: _bindgen_ty_7 = 1;
pub const POLL_OUT: _bindgen_ty_7 = 2;
pub const POLL_MSG: _bindgen_ty_7 = 3;
pub const POLL_ERR: _bindgen_ty_7 = 4;
pub const POLL_PRI: _bindgen_ty_7 = 5;
pub const POLL_HUP: _bindgen_ty_7 = 6;
pub type _bindgen_ty_7 = ::std::os::raw::c_uint;
pub type sigval_t = __sigval_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigevent {
    pub sigev_value: __sigval_t,
    pub sigev_signo: ::std::os::raw::c_int,
    pub sigev_notify: ::std::os::raw::c_int,
    pub _sigev_un: sigevent__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigevent__bindgen_ty_1 {
    pub _pad: [::std::os::raw::c_int; 12usize],
    pub _tid: __pid_t,
    pub _sigev_thread: sigevent__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent__bindgen_ty_1__bindgen_ty_1 {
    pub _function: ::std::option::Option<unsafe extern "C" fn(arg1: __sigval_t)>,
    pub _attribute: *mut pthread_attr_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sigevent__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::size_of::<sigevent__bindgen_ty_1__bindgen_ty_1>() - 16usize];
    ["Alignment of sigevent__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::align_of::<sigevent__bindgen_ty_1__bindgen_ty_1>() - 8usize];
    ["Offset of field: sigevent__bindgen_ty_1__bindgen_ty_1::_function"]
        [::std::mem::offset_of!(sigevent__bindgen_ty_1__bindgen_ty_1, _function) - 0usize];
    ["Offset of field: sigevent__bindgen_ty_1__bindgen_ty_1::_attribute"]
        [::std::mem::offset_of!(sigevent__bindgen_ty_1__bindgen_ty_1, _attribute) - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sigevent__bindgen_ty_1"][::std::mem::size_of::<sigevent__bindgen_ty_1>() - 48usize];
    ["Alignment of sigevent__bindgen_ty_1"]
        [::std::mem::align_of::<sigevent__bindgen_ty_1>() - 8usize];
    ["Offset of field: sigevent__bindgen_ty_1::_pad"]
        [::std::mem::offset_of!(sigevent__bindgen_ty_1, _pad) - 0usize];
    ["Offset of field: sigevent__bindgen_ty_1::_tid"]
        [::std::mem::offset_of!(sigevent__bindgen_ty_1, _tid) - 0usize];
    ["Offset of field: sigevent__bindgen_ty_1::_sigev_thread"]
        [::std::mem::offset_of!(sigevent__bindgen_ty_1, _sigev_thread) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sigevent"][::std::mem::size_of::<sigevent>() - 64usize];
    ["Alignment of sigevent"][::std::mem::align_of::<sigevent>() - 8usize];
    ["Offset of field: sigevent::sigev_value"]
        [::std::mem::offset_of!(sigevent, sigev_value) - 0usize];
    ["Offset of field: sigevent::sigev_signo"]
        [::std::mem::offset_of!(sigevent, sigev_signo) - 8usize];
    ["Offset of field: sigevent::sigev_notify"]
        [::std::mem::offset_of!(sigevent, sigev_notify) - 12usize];
    ["Offset of field: sigevent::_sigev_un"][::std::mem::offset_of!(sigevent, _sigev_un) - 16usize];
};
pub type sigevent_t = sigevent;
pub const SIGEV_SIGNAL: _bindgen_ty_8 = 0;
pub const SIGEV_NONE: _bindgen_ty_8 = 1;
pub const SIGEV_THREAD: _bindgen_ty_8 = 2;
pub const SIGEV_THREAD_ID: _bindgen_ty_8 = 4;
pub type _bindgen_ty_8 = ::std::os::raw::c_uint;
pub type __sighandler_t = ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
unsafe extern "C" {
    pub fn __sysv_signal(__sig: ::std::os::raw::c_int, __handler: __sighandler_t)
        -> __sighandler_t;
}
unsafe extern "C" {
    pub fn signal(__sig: ::std::os::raw::c_int, __handler: __sighandler_t) -> __sighandler_t;
}
unsafe extern "C" {
    pub fn kill(__pid: __pid_t, __sig: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn killpg(__pgrp: __pid_t, __sig: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn raise(__sig: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ssignal(__sig: ::std::os::raw::c_int, __handler: __sighandler_t) -> __sighandler_t;
}
unsafe extern "C" {
    pub fn gsignal(__sig: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn psignal(__sig: ::std::os::raw::c_int, __s: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn psiginfo(__pinfo: *const siginfo_t, __s: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn sigblock(__mask: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sigsetmask(__mask: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn siggetmask() -> ::std::os::raw::c_int;
}
pub type sig_t = __sighandler_t;
unsafe extern "C" {
    pub fn sigemptyset(__set: *mut sigset_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sigfillset(__set: *mut sigset_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sigaddset(__set: *mut sigset_t, __signo: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sigdelset(__set: *mut sigset_t, __signo: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sigismember(
        __set: *const sigset_t,
        __signo: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigaction {
    pub __sigaction_handler: sigaction__bindgen_ty_1,
    pub sa_mask: __sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
    pub sa_restorer: ::std::option::Option<unsafe extern "C" fn()>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigaction__bindgen_ty_1 {
    pub sa_handler: __sighandler_t,
    pub sa_sigaction: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut siginfo_t,
            arg3: *mut ::std::os::raw::c_void,
        ),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sigaction__bindgen_ty_1"][::std::mem::size_of::<sigaction__bindgen_ty_1>() - 8usize];
    ["Alignment of sigaction__bindgen_ty_1"]
        [::std::mem::align_of::<sigaction__bindgen_ty_1>() - 8usize];
    ["Offset of field: sigaction__bindgen_ty_1::sa_handler"]
        [::std::mem::offset_of!(sigaction__bindgen_ty_1, sa_handler) - 0usize];
    ["Offset of field: sigaction__bindgen_ty_1::sa_sigaction"]
        [::std::mem::offset_of!(sigaction__bindgen_ty_1, sa_sigaction) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sigaction"][::std::mem::size_of::<sigaction>() - 152usize];
    ["Alignment of sigaction"][::std::mem::align_of::<sigaction>() - 8usize];
    ["Offset of field: sigaction::__sigaction_handler"]
        [::std::mem::offset_of!(sigaction, __sigaction_handler) - 0usize];
    ["Offset of field: sigaction::sa_mask"][::std::mem::offset_of!(sigaction, sa_mask) - 8usize];
    ["Offset of field: sigaction::sa_flags"]
        [::std::mem::offset_of!(sigaction, sa_flags) - 136usize];
    ["Offset of field: sigaction::sa_restorer"]
        [::std::mem::offset_of!(sigaction, sa_restorer) - 144usize];
};
unsafe extern "C" {
    pub fn sigprocmask(
        __how: ::std::os::raw::c_int,
        __set: *const sigset_t,
        __oset: *mut sigset_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sigsuspend(__set: *const sigset_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sigaction(
        __sig: ::std::os::raw::c_int,
        __act: *const sigaction,
        __oact: *mut sigaction,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sigpending(__set: *mut sigset_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sigwait(
        __set: *const sigset_t,
        __sig: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sigwaitinfo(__set: *const sigset_t, __info: *mut siginfo_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sigtimedwait(
        __set: *const sigset_t,
        __info: *mut siginfo_t,
        __timeout: *const timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sigqueue(
        __pid: __pid_t,
        __sig: ::std::os::raw::c_int,
        __val: sigval,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fpx_sw_bytes {
    pub magic1: __uint32_t,
    pub extended_size: __uint32_t,
    pub xstate_bv: __uint64_t,
    pub xstate_size: __uint32_t,
    pub __glibc_reserved1: [__uint32_t; 7usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _fpx_sw_bytes"][::std::mem::size_of::<_fpx_sw_bytes>() - 48usize];
    ["Alignment of _fpx_sw_bytes"][::std::mem::align_of::<_fpx_sw_bytes>() - 8usize];
    ["Offset of field: _fpx_sw_bytes::magic1"]
        [::std::mem::offset_of!(_fpx_sw_bytes, magic1) - 0usize];
    ["Offset of field: _fpx_sw_bytes::extended_size"]
        [::std::mem::offset_of!(_fpx_sw_bytes, extended_size) - 4usize];
    ["Offset of field: _fpx_sw_bytes::xstate_bv"]
        [::std::mem::offset_of!(_fpx_sw_bytes, xstate_bv) - 8usize];
    ["Offset of field: _fpx_sw_bytes::xstate_size"]
        [::std::mem::offset_of!(_fpx_sw_bytes, xstate_size) - 16usize];
    ["Offset of field: _fpx_sw_bytes::__glibc_reserved1"]
        [::std::mem::offset_of!(_fpx_sw_bytes, __glibc_reserved1) - 20usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fpreg {
    pub significand: [::std::os::raw::c_ushort; 4usize],
    pub exponent: ::std::os::raw::c_ushort,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _fpreg"][::std::mem::size_of::<_fpreg>() - 10usize];
    ["Alignment of _fpreg"][::std::mem::align_of::<_fpreg>() - 2usize];
    ["Offset of field: _fpreg::significand"][::std::mem::offset_of!(_fpreg, significand) - 0usize];
    ["Offset of field: _fpreg::exponent"][::std::mem::offset_of!(_fpreg, exponent) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fpxreg {
    pub significand: [::std::os::raw::c_ushort; 4usize],
    pub exponent: ::std::os::raw::c_ushort,
    pub __glibc_reserved1: [::std::os::raw::c_ushort; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _fpxreg"][::std::mem::size_of::<_fpxreg>() - 16usize];
    ["Alignment of _fpxreg"][::std::mem::align_of::<_fpxreg>() - 2usize];
    ["Offset of field: _fpxreg::significand"]
        [::std::mem::offset_of!(_fpxreg, significand) - 0usize];
    ["Offset of field: _fpxreg::exponent"][::std::mem::offset_of!(_fpxreg, exponent) - 8usize];
    ["Offset of field: _fpxreg::__glibc_reserved1"]
        [::std::mem::offset_of!(_fpxreg, __glibc_reserved1) - 10usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmmreg {
    pub element: [__uint32_t; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _xmmreg"][::std::mem::size_of::<_xmmreg>() - 16usize];
    ["Alignment of _xmmreg"][::std::mem::align_of::<_xmmreg>() - 4usize];
    ["Offset of field: _xmmreg::element"][::std::mem::offset_of!(_xmmreg, element) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fpstate {
    pub cwd: __uint16_t,
    pub swd: __uint16_t,
    pub ftw: __uint16_t,
    pub fop: __uint16_t,
    pub rip: __uint64_t,
    pub rdp: __uint64_t,
    pub mxcsr: __uint32_t,
    pub mxcr_mask: __uint32_t,
    pub _st: [_fpxreg; 8usize],
    pub _xmm: [_xmmreg; 16usize],
    pub __glibc_reserved1: [__uint32_t; 24usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _fpstate"][::std::mem::size_of::<_fpstate>() - 512usize];
    ["Alignment of _fpstate"][::std::mem::align_of::<_fpstate>() - 8usize];
    ["Offset of field: _fpstate::cwd"][::std::mem::offset_of!(_fpstate, cwd) - 0usize];
    ["Offset of field: _fpstate::swd"][::std::mem::offset_of!(_fpstate, swd) - 2usize];
    ["Offset of field: _fpstate::ftw"][::std::mem::offset_of!(_fpstate, ftw) - 4usize];
    ["Offset of field: _fpstate::fop"][::std::mem::offset_of!(_fpstate, fop) - 6usize];
    ["Offset of field: _fpstate::rip"][::std::mem::offset_of!(_fpstate, rip) - 8usize];
    ["Offset of field: _fpstate::rdp"][::std::mem::offset_of!(_fpstate, rdp) - 16usize];
    ["Offset of field: _fpstate::mxcsr"][::std::mem::offset_of!(_fpstate, mxcsr) - 24usize];
    ["Offset of field: _fpstate::mxcr_mask"][::std::mem::offset_of!(_fpstate, mxcr_mask) - 28usize];
    ["Offset of field: _fpstate::_st"][::std::mem::offset_of!(_fpstate, _st) - 32usize];
    ["Offset of field: _fpstate::_xmm"][::std::mem::offset_of!(_fpstate, _xmm) - 160usize];
    ["Offset of field: _fpstate::__glibc_reserved1"]
        [::std::mem::offset_of!(_fpstate, __glibc_reserved1) - 416usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigcontext {
    pub r8: __uint64_t,
    pub r9: __uint64_t,
    pub r10: __uint64_t,
    pub r11: __uint64_t,
    pub r12: __uint64_t,
    pub r13: __uint64_t,
    pub r14: __uint64_t,
    pub r15: __uint64_t,
    pub rdi: __uint64_t,
    pub rsi: __uint64_t,
    pub rbp: __uint64_t,
    pub rbx: __uint64_t,
    pub rdx: __uint64_t,
    pub rax: __uint64_t,
    pub rcx: __uint64_t,
    pub rsp: __uint64_t,
    pub rip: __uint64_t,
    pub eflags: __uint64_t,
    pub cs: ::std::os::raw::c_ushort,
    pub gs: ::std::os::raw::c_ushort,
    pub fs: ::std::os::raw::c_ushort,
    pub __pad0: ::std::os::raw::c_ushort,
    pub err: __uint64_t,
    pub trapno: __uint64_t,
    pub oldmask: __uint64_t,
    pub cr2: __uint64_t,
    pub __bindgen_anon_1: sigcontext__bindgen_ty_1,
    pub __reserved1: [__uint64_t; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigcontext__bindgen_ty_1 {
    pub fpstate: *mut _fpstate,
    pub __fpstate_word: __uint64_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sigcontext__bindgen_ty_1"]
        [::std::mem::size_of::<sigcontext__bindgen_ty_1>() - 8usize];
    ["Alignment of sigcontext__bindgen_ty_1"]
        [::std::mem::align_of::<sigcontext__bindgen_ty_1>() - 8usize];
    ["Offset of field: sigcontext__bindgen_ty_1::fpstate"]
        [::std::mem::offset_of!(sigcontext__bindgen_ty_1, fpstate) - 0usize];
    ["Offset of field: sigcontext__bindgen_ty_1::__fpstate_word"]
        [::std::mem::offset_of!(sigcontext__bindgen_ty_1, __fpstate_word) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sigcontext"][::std::mem::size_of::<sigcontext>() - 256usize];
    ["Alignment of sigcontext"][::std::mem::align_of::<sigcontext>() - 8usize];
    ["Offset of field: sigcontext::r8"][::std::mem::offset_of!(sigcontext, r8) - 0usize];
    ["Offset of field: sigcontext::r9"][::std::mem::offset_of!(sigcontext, r9) - 8usize];
    ["Offset of field: sigcontext::r10"][::std::mem::offset_of!(sigcontext, r10) - 16usize];
    ["Offset of field: sigcontext::r11"][::std::mem::offset_of!(sigcontext, r11) - 24usize];
    ["Offset of field: sigcontext::r12"][::std::mem::offset_of!(sigcontext, r12) - 32usize];
    ["Offset of field: sigcontext::r13"][::std::mem::offset_of!(sigcontext, r13) - 40usize];
    ["Offset of field: sigcontext::r14"][::std::mem::offset_of!(sigcontext, r14) - 48usize];
    ["Offset of field: sigcontext::r15"][::std::mem::offset_of!(sigcontext, r15) - 56usize];
    ["Offset of field: sigcontext::rdi"][::std::mem::offset_of!(sigcontext, rdi) - 64usize];
    ["Offset of field: sigcontext::rsi"][::std::mem::offset_of!(sigcontext, rsi) - 72usize];
    ["Offset of field: sigcontext::rbp"][::std::mem::offset_of!(sigcontext, rbp) - 80usize];
    ["Offset of field: sigcontext::rbx"][::std::mem::offset_of!(sigcontext, rbx) - 88usize];
    ["Offset of field: sigcontext::rdx"][::std::mem::offset_of!(sigcontext, rdx) - 96usize];
    ["Offset of field: sigcontext::rax"][::std::mem::offset_of!(sigcontext, rax) - 104usize];
    ["Offset of field: sigcontext::rcx"][::std::mem::offset_of!(sigcontext, rcx) - 112usize];
    ["Offset of field: sigcontext::rsp"][::std::mem::offset_of!(sigcontext, rsp) - 120usize];
    ["Offset of field: sigcontext::rip"][::std::mem::offset_of!(sigcontext, rip) - 128usize];
    ["Offset of field: sigcontext::eflags"][::std::mem::offset_of!(sigcontext, eflags) - 136usize];
    ["Offset of field: sigcontext::cs"][::std::mem::offset_of!(sigcontext, cs) - 144usize];
    ["Offset of field: sigcontext::gs"][::std::mem::offset_of!(sigcontext, gs) - 146usize];
    ["Offset of field: sigcontext::fs"][::std::mem::offset_of!(sigcontext, fs) - 148usize];
    ["Offset of field: sigcontext::__pad0"][::std::mem::offset_of!(sigcontext, __pad0) - 150usize];
    ["Offset of field: sigcontext::err"][::std::mem::offset_of!(sigcontext, err) - 152usize];
    ["Offset of field: sigcontext::trapno"][::std::mem::offset_of!(sigcontext, trapno) - 160usize];
    ["Offset of field: sigcontext::oldmask"]
        [::std::mem::offset_of!(sigcontext, oldmask) - 168usize];
    ["Offset of field: sigcontext::cr2"][::std::mem::offset_of!(sigcontext, cr2) - 176usize];
    ["Offset of field: sigcontext::__reserved1"]
        [::std::mem::offset_of!(sigcontext, __reserved1) - 192usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xsave_hdr {
    pub xstate_bv: __uint64_t,
    pub __glibc_reserved1: [__uint64_t; 2usize],
    pub __glibc_reserved2: [__uint64_t; 5usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _xsave_hdr"][::std::mem::size_of::<_xsave_hdr>() - 64usize];
    ["Alignment of _xsave_hdr"][::std::mem::align_of::<_xsave_hdr>() - 8usize];
    ["Offset of field: _xsave_hdr::xstate_bv"]
        [::std::mem::offset_of!(_xsave_hdr, xstate_bv) - 0usize];
    ["Offset of field: _xsave_hdr::__glibc_reserved1"]
        [::std::mem::offset_of!(_xsave_hdr, __glibc_reserved1) - 8usize];
    ["Offset of field: _xsave_hdr::__glibc_reserved2"]
        [::std::mem::offset_of!(_xsave_hdr, __glibc_reserved2) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ymmh_state {
    pub ymmh_space: [__uint32_t; 64usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ymmh_state"][::std::mem::size_of::<_ymmh_state>() - 256usize];
    ["Alignment of _ymmh_state"][::std::mem::align_of::<_ymmh_state>() - 4usize];
    ["Offset of field: _ymmh_state::ymmh_space"]
        [::std::mem::offset_of!(_ymmh_state, ymmh_space) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xstate {
    pub fpstate: _fpstate,
    pub xstate_hdr: _xsave_hdr,
    pub ymmh: _ymmh_state,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _xstate"][::std::mem::size_of::<_xstate>() - 832usize];
    ["Alignment of _xstate"][::std::mem::align_of::<_xstate>() - 8usize];
    ["Offset of field: _xstate::fpstate"][::std::mem::offset_of!(_xstate, fpstate) - 0usize];
    ["Offset of field: _xstate::xstate_hdr"]
        [::std::mem::offset_of!(_xstate, xstate_hdr) - 512usize];
    ["Offset of field: _xstate::ymmh"][::std::mem::offset_of!(_xstate, ymmh) - 576usize];
};
unsafe extern "C" {
    pub fn sigreturn(__scp: *mut sigcontext) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_t {
    pub ss_sp: *mut ::std::os::raw::c_void,
    pub ss_flags: ::std::os::raw::c_int,
    pub ss_size: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of stack_t"][::std::mem::size_of::<stack_t>() - 24usize];
    ["Alignment of stack_t"][::std::mem::align_of::<stack_t>() - 8usize];
    ["Offset of field: stack_t::ss_sp"][::std::mem::offset_of!(stack_t, ss_sp) - 0usize];
    ["Offset of field: stack_t::ss_flags"][::std::mem::offset_of!(stack_t, ss_flags) - 8usize];
    ["Offset of field: stack_t::ss_size"][::std::mem::offset_of!(stack_t, ss_size) - 16usize];
};
pub type greg_t = ::std::os::raw::c_longlong;
pub type gregset_t = [greg_t; 23usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _libc_fpxreg {
    pub significand: [::std::os::raw::c_ushort; 4usize],
    pub exponent: ::std::os::raw::c_ushort,
    pub __glibc_reserved1: [::std::os::raw::c_ushort; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _libc_fpxreg"][::std::mem::size_of::<_libc_fpxreg>() - 16usize];
    ["Alignment of _libc_fpxreg"][::std::mem::align_of::<_libc_fpxreg>() - 2usize];
    ["Offset of field: _libc_fpxreg::significand"]
        [::std::mem::offset_of!(_libc_fpxreg, significand) - 0usize];
    ["Offset of field: _libc_fpxreg::exponent"]
        [::std::mem::offset_of!(_libc_fpxreg, exponent) - 8usize];
    ["Offset of field: _libc_fpxreg::__glibc_reserved1"]
        [::std::mem::offset_of!(_libc_fpxreg, __glibc_reserved1) - 10usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _libc_xmmreg {
    pub element: [__uint32_t; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _libc_xmmreg"][::std::mem::size_of::<_libc_xmmreg>() - 16usize];
    ["Alignment of _libc_xmmreg"][::std::mem::align_of::<_libc_xmmreg>() - 4usize];
    ["Offset of field: _libc_xmmreg::element"]
        [::std::mem::offset_of!(_libc_xmmreg, element) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _libc_fpstate {
    pub cwd: __uint16_t,
    pub swd: __uint16_t,
    pub ftw: __uint16_t,
    pub fop: __uint16_t,
    pub rip: __uint64_t,
    pub rdp: __uint64_t,
    pub mxcsr: __uint32_t,
    pub mxcr_mask: __uint32_t,
    pub _st: [_libc_fpxreg; 8usize],
    pub _xmm: [_libc_xmmreg; 16usize],
    pub __glibc_reserved1: [__uint32_t; 24usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _libc_fpstate"][::std::mem::size_of::<_libc_fpstate>() - 512usize];
    ["Alignment of _libc_fpstate"][::std::mem::align_of::<_libc_fpstate>() - 8usize];
    ["Offset of field: _libc_fpstate::cwd"][::std::mem::offset_of!(_libc_fpstate, cwd) - 0usize];
    ["Offset of field: _libc_fpstate::swd"][::std::mem::offset_of!(_libc_fpstate, swd) - 2usize];
    ["Offset of field: _libc_fpstate::ftw"][::std::mem::offset_of!(_libc_fpstate, ftw) - 4usize];
    ["Offset of field: _libc_fpstate::fop"][::std::mem::offset_of!(_libc_fpstate, fop) - 6usize];
    ["Offset of field: _libc_fpstate::rip"][::std::mem::offset_of!(_libc_fpstate, rip) - 8usize];
    ["Offset of field: _libc_fpstate::rdp"][::std::mem::offset_of!(_libc_fpstate, rdp) - 16usize];
    ["Offset of field: _libc_fpstate::mxcsr"]
        [::std::mem::offset_of!(_libc_fpstate, mxcsr) - 24usize];
    ["Offset of field: _libc_fpstate::mxcr_mask"]
        [::std::mem::offset_of!(_libc_fpstate, mxcr_mask) - 28usize];
    ["Offset of field: _libc_fpstate::_st"][::std::mem::offset_of!(_libc_fpstate, _st) - 32usize];
    ["Offset of field: _libc_fpstate::_xmm"]
        [::std::mem::offset_of!(_libc_fpstate, _xmm) - 160usize];
    ["Offset of field: _libc_fpstate::__glibc_reserved1"]
        [::std::mem::offset_of!(_libc_fpstate, __glibc_reserved1) - 416usize];
};
pub type fpregset_t = *mut _libc_fpstate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mcontext_t {
    pub gregs: gregset_t,
    pub fpregs: fpregset_t,
    pub __reserved1: [::std::os::raw::c_ulonglong; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of mcontext_t"][::std::mem::size_of::<mcontext_t>() - 256usize];
    ["Alignment of mcontext_t"][::std::mem::align_of::<mcontext_t>() - 8usize];
    ["Offset of field: mcontext_t::gregs"][::std::mem::offset_of!(mcontext_t, gregs) - 0usize];
    ["Offset of field: mcontext_t::fpregs"][::std::mem::offset_of!(mcontext_t, fpregs) - 184usize];
    ["Offset of field: mcontext_t::__reserved1"]
        [::std::mem::offset_of!(mcontext_t, __reserved1) - 192usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucontext_t {
    pub uc_flags: ::std::os::raw::c_ulong,
    pub uc_link: *mut ucontext_t,
    pub uc_stack: stack_t,
    pub uc_mcontext: mcontext_t,
    pub uc_sigmask: sigset_t,
    pub __fpregs_mem: _libc_fpstate,
    pub __ssp: [::std::os::raw::c_ulonglong; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ucontext_t"][::std::mem::size_of::<ucontext_t>() - 968usize];
    ["Alignment of ucontext_t"][::std::mem::align_of::<ucontext_t>() - 8usize];
    ["Offset of field: ucontext_t::uc_flags"]
        [::std::mem::offset_of!(ucontext_t, uc_flags) - 0usize];
    ["Offset of field: ucontext_t::uc_link"][::std::mem::offset_of!(ucontext_t, uc_link) - 8usize];
    ["Offset of field: ucontext_t::uc_stack"]
        [::std::mem::offset_of!(ucontext_t, uc_stack) - 16usize];
    ["Offset of field: ucontext_t::uc_mcontext"]
        [::std::mem::offset_of!(ucontext_t, uc_mcontext) - 40usize];
    ["Offset of field: ucontext_t::uc_sigmask"]
        [::std::mem::offset_of!(ucontext_t, uc_sigmask) - 296usize];
    ["Offset of field: ucontext_t::__fpregs_mem"]
        [::std::mem::offset_of!(ucontext_t, __fpregs_mem) - 424usize];
    ["Offset of field: ucontext_t::__ssp"][::std::mem::offset_of!(ucontext_t, __ssp) - 936usize];
};
unsafe extern "C" {
    pub fn siginterrupt(
        __sig: ::std::os::raw::c_int,
        __interrupt: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub const SS_ONSTACK: _bindgen_ty_9 = 1;
pub const SS_DISABLE: _bindgen_ty_9 = 2;
pub type _bindgen_ty_9 = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn sigaltstack(__ss: *const stack_t, __oss: *mut stack_t) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigstack {
    pub ss_sp: *mut ::std::os::raw::c_void,
    pub ss_onstack: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sigstack"][::std::mem::size_of::<sigstack>() - 16usize];
    ["Alignment of sigstack"][::std::mem::align_of::<sigstack>() - 8usize];
    ["Offset of field: sigstack::ss_sp"][::std::mem::offset_of!(sigstack, ss_sp) - 0usize];
    ["Offset of field: sigstack::ss_onstack"]
        [::std::mem::offset_of!(sigstack, ss_onstack) - 8usize];
};
unsafe extern "C" {
    pub fn sigstack(__ss: *mut sigstack, __oss: *mut sigstack) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __atomic_wide_counter {
    pub __value64: ::std::os::raw::c_ulonglong,
    pub __value32: __atomic_wide_counter__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __atomic_wide_counter__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __atomic_wide_counter__bindgen_ty_1"]
        [::std::mem::size_of::<__atomic_wide_counter__bindgen_ty_1>() - 8usize];
    ["Alignment of __atomic_wide_counter__bindgen_ty_1"]
        [::std::mem::align_of::<__atomic_wide_counter__bindgen_ty_1>() - 4usize];
    ["Offset of field: __atomic_wide_counter__bindgen_ty_1::__low"]
        [::std::mem::offset_of!(__atomic_wide_counter__bindgen_ty_1, __low) - 0usize];
    ["Offset of field: __atomic_wide_counter__bindgen_ty_1::__high"]
        [::std::mem::offset_of!(__atomic_wide_counter__bindgen_ty_1, __high) - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __atomic_wide_counter"][::std::mem::size_of::<__atomic_wide_counter>() - 8usize];
    ["Alignment of __atomic_wide_counter"]
        [::std::mem::align_of::<__atomic_wide_counter>() - 8usize];
    ["Offset of field: __atomic_wide_counter::__value64"]
        [::std::mem::offset_of!(__atomic_wide_counter, __value64) - 0usize];
    ["Offset of field: __atomic_wide_counter::__value32"]
        [::std::mem::offset_of!(__atomic_wide_counter, __value32) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_internal_list"][::std::mem::size_of::<__pthread_internal_list>() - 16usize];
    ["Alignment of __pthread_internal_list"]
        [::std::mem::align_of::<__pthread_internal_list>() - 8usize];
    ["Offset of field: __pthread_internal_list::__prev"]
        [::std::mem::offset_of!(__pthread_internal_list, __prev) - 0usize];
    ["Offset of field: __pthread_internal_list::__next"]
        [::std::mem::offset_of!(__pthread_internal_list, __next) - 8usize];
};
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_internal_slist"]
        [::std::mem::size_of::<__pthread_internal_slist>() - 8usize];
    ["Alignment of __pthread_internal_slist"]
        [::std::mem::align_of::<__pthread_internal_slist>() - 8usize];
    ["Offset of field: __pthread_internal_slist::__next"]
        [::std::mem::offset_of!(__pthread_internal_slist, __next) - 0usize];
};
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_mutex_s"][::std::mem::size_of::<__pthread_mutex_s>() - 40usize];
    ["Alignment of __pthread_mutex_s"][::std::mem::align_of::<__pthread_mutex_s>() - 8usize];
    ["Offset of field: __pthread_mutex_s::__lock"]
        [::std::mem::offset_of!(__pthread_mutex_s, __lock) - 0usize];
    ["Offset of field: __pthread_mutex_s::__count"]
        [::std::mem::offset_of!(__pthread_mutex_s, __count) - 4usize];
    ["Offset of field: __pthread_mutex_s::__owner"]
        [::std::mem::offset_of!(__pthread_mutex_s, __owner) - 8usize];
    ["Offset of field: __pthread_mutex_s::__nusers"]
        [::std::mem::offset_of!(__pthread_mutex_s, __nusers) - 12usize];
    ["Offset of field: __pthread_mutex_s::__kind"]
        [::std::mem::offset_of!(__pthread_mutex_s, __kind) - 16usize];
    ["Offset of field: __pthread_mutex_s::__spins"]
        [::std::mem::offset_of!(__pthread_mutex_s, __spins) - 20usize];
    ["Offset of field: __pthread_mutex_s::__elision"]
        [::std::mem::offset_of!(__pthread_mutex_s, __elision) - 22usize];
    ["Offset of field: __pthread_mutex_s::__list"]
        [::std::mem::offset_of!(__pthread_mutex_s, __list) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_rwlock_arch_t"][::std::mem::size_of::<__pthread_rwlock_arch_t>() - 56usize];
    ["Alignment of __pthread_rwlock_arch_t"]
        [::std::mem::align_of::<__pthread_rwlock_arch_t>() - 8usize];
    ["Offset of field: __pthread_rwlock_arch_t::__readers"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __readers) - 0usize];
    ["Offset of field: __pthread_rwlock_arch_t::__writers"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __writers) - 4usize];
    ["Offset of field: __pthread_rwlock_arch_t::__wrphase_futex"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __wrphase_futex) - 8usize];
    ["Offset of field: __pthread_rwlock_arch_t::__writers_futex"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __writers_futex) - 12usize];
    ["Offset of field: __pthread_rwlock_arch_t::__pad3"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __pad3) - 16usize];
    ["Offset of field: __pthread_rwlock_arch_t::__pad4"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __pad4) - 20usize];
    ["Offset of field: __pthread_rwlock_arch_t::__cur_writer"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __cur_writer) - 24usize];
    ["Offset of field: __pthread_rwlock_arch_t::__shared"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __shared) - 28usize];
    ["Offset of field: __pthread_rwlock_arch_t::__rwelision"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __rwelision) - 32usize];
    ["Offset of field: __pthread_rwlock_arch_t::__pad1"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __pad1) - 33usize];
    ["Offset of field: __pthread_rwlock_arch_t::__pad2"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __pad2) - 40usize];
    ["Offset of field: __pthread_rwlock_arch_t::__flags"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __flags) - 48usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __wseq: __atomic_wide_counter,
    pub __g1_start: __atomic_wide_counter,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_cond_s"][::std::mem::size_of::<__pthread_cond_s>() - 48usize];
    ["Alignment of __pthread_cond_s"][::std::mem::align_of::<__pthread_cond_s>() - 8usize];
    ["Offset of field: __pthread_cond_s::__wseq"]
        [::std::mem::offset_of!(__pthread_cond_s, __wseq) - 0usize];
    ["Offset of field: __pthread_cond_s::__g1_start"]
        [::std::mem::offset_of!(__pthread_cond_s, __g1_start) - 8usize];
    ["Offset of field: __pthread_cond_s::__g_refs"]
        [::std::mem::offset_of!(__pthread_cond_s, __g_refs) - 16usize];
    ["Offset of field: __pthread_cond_s::__g_size"]
        [::std::mem::offset_of!(__pthread_cond_s, __g_size) - 24usize];
    ["Offset of field: __pthread_cond_s::__g1_orig_size"]
        [::std::mem::offset_of!(__pthread_cond_s, __g1_orig_size) - 32usize];
    ["Offset of field: __pthread_cond_s::__wrefs"]
        [::std::mem::offset_of!(__pthread_cond_s, __wrefs) - 36usize];
    ["Offset of field: __pthread_cond_s::__g_signals"]
        [::std::mem::offset_of!(__pthread_cond_s, __g_signals) - 40usize];
};
pub type __tss_t = ::std::os::raw::c_uint;
pub type __thrd_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __once_flag {
    pub __data: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __once_flag"][::std::mem::size_of::<__once_flag>() - 4usize];
    ["Alignment of __once_flag"][::std::mem::align_of::<__once_flag>() - 4usize];
    ["Offset of field: __once_flag::__data"][::std::mem::offset_of!(__once_flag, __data) - 0usize];
};
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_mutexattr_t"][::std::mem::size_of::<pthread_mutexattr_t>() - 4usize];
    ["Alignment of pthread_mutexattr_t"][::std::mem::align_of::<pthread_mutexattr_t>() - 4usize];
    ["Offset of field: pthread_mutexattr_t::__size"]
        [::std::mem::offset_of!(pthread_mutexattr_t, __size) - 0usize];
    ["Offset of field: pthread_mutexattr_t::__align"]
        [::std::mem::offset_of!(pthread_mutexattr_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_condattr_t"][::std::mem::size_of::<pthread_condattr_t>() - 4usize];
    ["Alignment of pthread_condattr_t"][::std::mem::align_of::<pthread_condattr_t>() - 4usize];
    ["Offset of field: pthread_condattr_t::__size"]
        [::std::mem::offset_of!(pthread_condattr_t, __size) - 0usize];
    ["Offset of field: pthread_condattr_t::__align"]
        [::std::mem::offset_of!(pthread_condattr_t, __align) - 0usize];
};
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_attr_t"][::std::mem::size_of::<pthread_attr_t>() - 56usize];
    ["Alignment of pthread_attr_t"][::std::mem::align_of::<pthread_attr_t>() - 8usize];
    ["Offset of field: pthread_attr_t::__size"]
        [::std::mem::offset_of!(pthread_attr_t, __size) - 0usize];
    ["Offset of field: pthread_attr_t::__align"]
        [::std::mem::offset_of!(pthread_attr_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_mutex_t"][::std::mem::size_of::<pthread_mutex_t>() - 40usize];
    ["Alignment of pthread_mutex_t"][::std::mem::align_of::<pthread_mutex_t>() - 8usize];
    ["Offset of field: pthread_mutex_t::__data"]
        [::std::mem::offset_of!(pthread_mutex_t, __data) - 0usize];
    ["Offset of field: pthread_mutex_t::__size"]
        [::std::mem::offset_of!(pthread_mutex_t, __size) - 0usize];
    ["Offset of field: pthread_mutex_t::__align"]
        [::std::mem::offset_of!(pthread_mutex_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_cond_t"][::std::mem::size_of::<pthread_cond_t>() - 48usize];
    ["Alignment of pthread_cond_t"][::std::mem::align_of::<pthread_cond_t>() - 8usize];
    ["Offset of field: pthread_cond_t::__data"]
        [::std::mem::offset_of!(pthread_cond_t, __data) - 0usize];
    ["Offset of field: pthread_cond_t::__size"]
        [::std::mem::offset_of!(pthread_cond_t, __size) - 0usize];
    ["Offset of field: pthread_cond_t::__align"]
        [::std::mem::offset_of!(pthread_cond_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_rwlock_t"][::std::mem::size_of::<pthread_rwlock_t>() - 56usize];
    ["Alignment of pthread_rwlock_t"][::std::mem::align_of::<pthread_rwlock_t>() - 8usize];
    ["Offset of field: pthread_rwlock_t::__data"]
        [::std::mem::offset_of!(pthread_rwlock_t, __data) - 0usize];
    ["Offset of field: pthread_rwlock_t::__size"]
        [::std::mem::offset_of!(pthread_rwlock_t, __size) - 0usize];
    ["Offset of field: pthread_rwlock_t::__align"]
        [::std::mem::offset_of!(pthread_rwlock_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_rwlockattr_t"][::std::mem::size_of::<pthread_rwlockattr_t>() - 8usize];
    ["Alignment of pthread_rwlockattr_t"][::std::mem::align_of::<pthread_rwlockattr_t>() - 8usize];
    ["Offset of field: pthread_rwlockattr_t::__size"]
        [::std::mem::offset_of!(pthread_rwlockattr_t, __size) - 0usize];
    ["Offset of field: pthread_rwlockattr_t::__align"]
        [::std::mem::offset_of!(pthread_rwlockattr_t, __align) - 0usize];
};
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_barrier_t"][::std::mem::size_of::<pthread_barrier_t>() - 32usize];
    ["Alignment of pthread_barrier_t"][::std::mem::align_of::<pthread_barrier_t>() - 8usize];
    ["Offset of field: pthread_barrier_t::__size"]
        [::std::mem::offset_of!(pthread_barrier_t, __size) - 0usize];
    ["Offset of field: pthread_barrier_t::__align"]
        [::std::mem::offset_of!(pthread_barrier_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_barrierattr_t"][::std::mem::size_of::<pthread_barrierattr_t>() - 4usize];
    ["Alignment of pthread_barrierattr_t"]
        [::std::mem::align_of::<pthread_barrierattr_t>() - 4usize];
    ["Offset of field: pthread_barrierattr_t::__size"]
        [::std::mem::offset_of!(pthread_barrierattr_t, __size) - 0usize];
    ["Offset of field: pthread_barrierattr_t::__align"]
        [::std::mem::offset_of!(pthread_barrierattr_t, __align) - 0usize];
};
unsafe extern "C" {
    pub fn pthread_sigmask(
        __how: ::std::os::raw::c_int,
        __newmask: *const __sigset_t,
        __oldmask: *mut __sigset_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_kill(
        __threadid: pthread_t,
        __signo: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __libc_current_sigrtmin() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __libc_current_sigrtmax() -> ::std::os::raw::c_int;
}
pub type wchar_t = ::std::os::raw::c_int;
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of div_t"][::std::mem::size_of::<div_t>() - 8usize];
    ["Alignment of div_t"][::std::mem::align_of::<div_t>() - 4usize];
    ["Offset of field: div_t::quot"][::std::mem::offset_of!(div_t, quot) - 0usize];
    ["Offset of field: div_t::rem"][::std::mem::offset_of!(div_t, rem) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ldiv_t"][::std::mem::size_of::<ldiv_t>() - 16usize];
    ["Alignment of ldiv_t"][::std::mem::align_of::<ldiv_t>() - 8usize];
    ["Offset of field: ldiv_t::quot"][::std::mem::offset_of!(ldiv_t, quot) - 0usize];
    ["Offset of field: ldiv_t::rem"][::std::mem::offset_of!(ldiv_t, rem) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of lldiv_t"][::std::mem::size_of::<lldiv_t>() - 16usize];
    ["Alignment of lldiv_t"][::std::mem::align_of::<lldiv_t>() - 8usize];
    ["Offset of field: lldiv_t::quot"][::std::mem::offset_of!(lldiv_t, quot) - 0usize];
    ["Offset of field: lldiv_t::rem"][::std::mem::offset_of!(lldiv_t, rem) - 8usize];
};
unsafe extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
unsafe extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
unsafe extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn strtod(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
unsafe extern "C" {
    pub fn strtof(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
unsafe extern "C" {
    pub fn strtold(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> u128;
}
unsafe extern "C" {
    pub fn strtol(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn strtoul(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strtoq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn strtouq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
unsafe extern "C" {
    pub fn strtoll(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn strtoull(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
unsafe extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type off_t = __off_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of timeval"][::std::mem::size_of::<timeval>() - 16usize];
    ["Alignment of timeval"][::std::mem::align_of::<timeval>() - 8usize];
    ["Offset of field: timeval::tv_sec"][::std::mem::offset_of!(timeval, tv_sec) - 0usize];
    ["Offset of field: timeval::tv_usec"][::std::mem::offset_of!(timeval, tv_usec) - 8usize];
};
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of fd_set"][::std::mem::size_of::<fd_set>() - 128usize];
    ["Alignment of fd_set"][::std::mem::align_of::<fd_set>() - 8usize];
    ["Offset of field: fd_set::__fds_bits"][::std::mem::offset_of!(fd_set, __fds_bits) - 0usize];
};
pub type fd_mask = __fd_mask;
unsafe extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
unsafe extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    pub fn initstate(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of random_data"][::std::mem::size_of::<random_data>() - 48usize];
    ["Alignment of random_data"][::std::mem::align_of::<random_data>() - 8usize];
    ["Offset of field: random_data::fptr"][::std::mem::offset_of!(random_data, fptr) - 0usize];
    ["Offset of field: random_data::rptr"][::std::mem::offset_of!(random_data, rptr) - 8usize];
    ["Offset of field: random_data::state"][::std::mem::offset_of!(random_data, state) - 16usize];
    ["Offset of field: random_data::rand_type"]
        [::std::mem::offset_of!(random_data, rand_type) - 24usize];
    ["Offset of field: random_data::rand_deg"]
        [::std::mem::offset_of!(random_data, rand_deg) - 28usize];
    ["Offset of field: random_data::rand_sep"]
        [::std::mem::offset_of!(random_data, rand_sep) - 32usize];
    ["Offset of field: random_data::end_ptr"]
        [::std::mem::offset_of!(random_data, end_ptr) - 40usize];
};
unsafe extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn srandom_r(
        __seed: ::std::os::raw::c_uint,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn initstate_r(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setstate_r(
        __statebuf: *mut ::std::os::raw::c_char,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn drand48() -> f64;
}
unsafe extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
unsafe extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
unsafe extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
unsafe extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of drand48_data"][::std::mem::size_of::<drand48_data>() - 24usize];
    ["Alignment of drand48_data"][::std::mem::align_of::<drand48_data>() - 8usize];
    ["Offset of field: drand48_data::__x"][::std::mem::offset_of!(drand48_data, __x) - 0usize];
    ["Offset of field: drand48_data::__old_x"]
        [::std::mem::offset_of!(drand48_data, __old_x) - 6usize];
    ["Offset of field: drand48_data::__c"][::std::mem::offset_of!(drand48_data, __c) - 12usize];
    ["Offset of field: drand48_data::__init"]
        [::std::mem::offset_of!(drand48_data, __init) - 14usize];
    ["Offset of field: drand48_data::__a"][::std::mem::offset_of!(drand48_data, __a) - 16usize];
};
unsafe extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn erand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn lrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn srand48_r(
        __seedval: ::std::os::raw::c_long,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn seed48_r(
        __seed16v: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn lcong48_r(
        __param: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn arc4random() -> __uint32_t;
}
unsafe extern "C" {
    pub fn arc4random_buf(__buf: *mut ::std::os::raw::c_void, __size: usize);
}
unsafe extern "C" {
    pub fn arc4random_uniform(__upper_bound: __uint32_t) -> __uint32_t;
}
unsafe extern "C" {
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn calloc(
        __nmemb: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn reallocarray(
        __ptr: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn alloca(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn valloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: usize,
        __size: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aligned_alloc(
        __alignment: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn abort() -> !;
}
unsafe extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn at_quick_exit(
        __func: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn on_exit(
        __func: ::std::option::Option<
            unsafe extern "C" fn(
                __status: ::std::os::raw::c_int,
                __arg: *mut ::std::os::raw::c_void,
            ),
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int) -> !;
}
unsafe extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int) -> !;
}
unsafe extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int) -> !;
}
unsafe extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __replace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mkstemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn realpath(
        __name: *const ::std::os::raw::c_char,
        __resolved: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
unsafe extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    );
}
unsafe extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
}
unsafe extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
}
unsafe extern "C" {
    pub fn lldiv(
        __numer: ::std::os::raw::c_longlong,
        __denom: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
unsafe extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn gcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn qecvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn qfcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn qgcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn qecvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn qfcvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mbtowc(
        __pwc: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const ::std::os::raw::c_char, __n: usize) -> usize;
}
unsafe extern "C" {
    pub fn wcstombs(__s: *mut ::std::os::raw::c_char, __pwcs: *const wchar_t, __n: usize) -> usize;
}
unsafe extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut ::std::os::raw::c_char,
        __tokens: *const *mut ::std::os::raw::c_char,
        __valuep: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn memcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn memmove(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn memccpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn memset(
        __s: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __memcmpeq(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn memchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn strcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strcat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strncat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strxfrm(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __locale_struct"][::std::mem::size_of::<__locale_struct>() - 232usize];
    ["Alignment of __locale_struct"][::std::mem::align_of::<__locale_struct>() - 8usize];
    ["Offset of field: __locale_struct::__locales"]
        [::std::mem::offset_of!(__locale_struct, __locales) - 0usize];
    ["Offset of field: __locale_struct::__ctype_b"]
        [::std::mem::offset_of!(__locale_struct, __ctype_b) - 104usize];
    ["Offset of field: __locale_struct::__ctype_tolower"]
        [::std::mem::offset_of!(__locale_struct, __ctype_tolower) - 112usize];
    ["Offset of field: __locale_struct::__ctype_toupper"]
        [::std::mem::offset_of!(__locale_struct, __ctype_toupper) - 120usize];
    ["Offset of field: __locale_struct::__names"]
        [::std::mem::offset_of!(__locale_struct, __names) - 128usize];
};
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
unsafe extern "C" {
    pub fn strcoll_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __l: locale_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strxfrm_l(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
        __l: locale_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn strdup(__s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strndup(
        __string: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strrchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strchrnul(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __reject: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strpbrk(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strstr(
        __haystack: *const ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strtok(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn __strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strcasestr(
        __haystack: *const ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn memmem(
        __haystack: *const ::std::os::raw::c_void,
        __haystacklen: usize,
        __needle: *const ::std::os::raw::c_void,
        __needlelen: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn __mempcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn mempcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strnlen(__string: *const ::std::os::raw::c_char, __maxlen: usize) -> usize;
}
unsafe extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strerror_l(
        __errnum: ::std::os::raw::c_int,
        __l: locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn bcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn bcopy(
        __src: *const ::std::os::raw::c_void,
        __dest: *mut ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    );
}
unsafe extern "C" {
    pub fn bzero(__s: *mut ::std::os::raw::c_void, __n: ::std::os::raw::c_ulong);
}
unsafe extern "C" {
    pub fn index(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn rindex(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ffs(__i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ffsl(__l: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ffsll(__ll: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strcasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strncasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strcasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strncasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: usize,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn explicit_bzero(__s: *mut ::std::os::raw::c_void, __n: usize);
}
unsafe extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn __stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn __stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strlcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strlcat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of max_align_t"][::std::mem::size_of::<max_align_t>() - 32usize];
    ["Alignment of max_align_t"][::std::mem::align_of::<max_align_t>() - 16usize];
    ["Offset of field: max_align_t::__clang_max_align_nonce1"]
        [::std::mem::offset_of!(max_align_t, __clang_max_align_nonce1) - 0usize];
    ["Offset of field: max_align_t::__clang_max_align_nonce2"]
        [::std::mem::offset_of!(max_align_t, __clang_max_align_nonce2) - 16usize];
};
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __mbstate_t__bindgen_ty_1"]
        [::std::mem::size_of::<__mbstate_t__bindgen_ty_1>() - 4usize];
    ["Alignment of __mbstate_t__bindgen_ty_1"]
        [::std::mem::align_of::<__mbstate_t__bindgen_ty_1>() - 4usize];
    ["Offset of field: __mbstate_t__bindgen_ty_1::__wch"]
        [::std::mem::offset_of!(__mbstate_t__bindgen_ty_1, __wch) - 0usize];
    ["Offset of field: __mbstate_t__bindgen_ty_1::__wchb"]
        [::std::mem::offset_of!(__mbstate_t__bindgen_ty_1, __wchb) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __mbstate_t"][::std::mem::size_of::<__mbstate_t>() - 8usize];
    ["Alignment of __mbstate_t"][::std::mem::align_of::<__mbstate_t>() - 4usize];
    ["Offset of field: __mbstate_t::__count"]
        [::std::mem::offset_of!(__mbstate_t, __count) - 0usize];
    ["Offset of field: __mbstate_t::__value"]
        [::std::mem::offset_of!(__mbstate_t, __value) - 4usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _G_fpos_t"][::std::mem::size_of::<_G_fpos_t>() - 16usize];
    ["Alignment of _G_fpos_t"][::std::mem::align_of::<_G_fpos_t>() - 8usize];
    ["Offset of field: _G_fpos_t::__pos"][::std::mem::offset_of!(_G_fpos_t, __pos) - 0usize];
    ["Offset of field: _G_fpos_t::__state"][::std::mem::offset_of!(_G_fpos_t, __state) - 8usize];
};
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _G_fpos64_t"][::std::mem::size_of::<_G_fpos64_t>() - 16usize];
    ["Alignment of _G_fpos64_t"][::std::mem::align_of::<_G_fpos64_t>() - 8usize];
    ["Offset of field: _G_fpos64_t::__pos"][::std::mem::offset_of!(_G_fpos64_t, __pos) - 0usize];
    ["Offset of field: _G_fpos64_t::__state"]
        [::std::mem::offset_of!(_G_fpos64_t, __state) - 8usize];
};
pub type __fpos64_t = _G_fpos64_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub _prevchain: *mut *mut _IO_FILE,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _IO_FILE"][::std::mem::size_of::<_IO_FILE>() - 216usize];
    ["Alignment of _IO_FILE"][::std::mem::align_of::<_IO_FILE>() - 8usize];
    ["Offset of field: _IO_FILE::_flags"][::std::mem::offset_of!(_IO_FILE, _flags) - 0usize];
    ["Offset of field: _IO_FILE::_IO_read_ptr"]
        [::std::mem::offset_of!(_IO_FILE, _IO_read_ptr) - 8usize];
    ["Offset of field: _IO_FILE::_IO_read_end"]
        [::std::mem::offset_of!(_IO_FILE, _IO_read_end) - 16usize];
    ["Offset of field: _IO_FILE::_IO_read_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_read_base) - 24usize];
    ["Offset of field: _IO_FILE::_IO_write_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_write_base) - 32usize];
    ["Offset of field: _IO_FILE::_IO_write_ptr"]
        [::std::mem::offset_of!(_IO_FILE, _IO_write_ptr) - 40usize];
    ["Offset of field: _IO_FILE::_IO_write_end"]
        [::std::mem::offset_of!(_IO_FILE, _IO_write_end) - 48usize];
    ["Offset of field: _IO_FILE::_IO_buf_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_buf_base) - 56usize];
    ["Offset of field: _IO_FILE::_IO_buf_end"]
        [::std::mem::offset_of!(_IO_FILE, _IO_buf_end) - 64usize];
    ["Offset of field: _IO_FILE::_IO_save_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_save_base) - 72usize];
    ["Offset of field: _IO_FILE::_IO_backup_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_backup_base) - 80usize];
    ["Offset of field: _IO_FILE::_IO_save_end"]
        [::std::mem::offset_of!(_IO_FILE, _IO_save_end) - 88usize];
    ["Offset of field: _IO_FILE::_markers"][::std::mem::offset_of!(_IO_FILE, _markers) - 96usize];
    ["Offset of field: _IO_FILE::_chain"][::std::mem::offset_of!(_IO_FILE, _chain) - 104usize];
    ["Offset of field: _IO_FILE::_fileno"][::std::mem::offset_of!(_IO_FILE, _fileno) - 112usize];
    ["Offset of field: _IO_FILE::_flags2"][::std::mem::offset_of!(_IO_FILE, _flags2) - 116usize];
    ["Offset of field: _IO_FILE::_old_offset"]
        [::std::mem::offset_of!(_IO_FILE, _old_offset) - 120usize];
    ["Offset of field: _IO_FILE::_cur_column"]
        [::std::mem::offset_of!(_IO_FILE, _cur_column) - 128usize];
    ["Offset of field: _IO_FILE::_vtable_offset"]
        [::std::mem::offset_of!(_IO_FILE, _vtable_offset) - 130usize];
    ["Offset of field: _IO_FILE::_shortbuf"]
        [::std::mem::offset_of!(_IO_FILE, _shortbuf) - 131usize];
    ["Offset of field: _IO_FILE::_lock"][::std::mem::offset_of!(_IO_FILE, _lock) - 136usize];
    ["Offset of field: _IO_FILE::_offset"][::std::mem::offset_of!(_IO_FILE, _offset) - 144usize];
    ["Offset of field: _IO_FILE::_codecvt"][::std::mem::offset_of!(_IO_FILE, _codecvt) - 152usize];
    ["Offset of field: _IO_FILE::_wide_data"]
        [::std::mem::offset_of!(_IO_FILE, _wide_data) - 160usize];
    ["Offset of field: _IO_FILE::_freeres_list"]
        [::std::mem::offset_of!(_IO_FILE, _freeres_list) - 168usize];
    ["Offset of field: _IO_FILE::_freeres_buf"]
        [::std::mem::offset_of!(_IO_FILE, _freeres_buf) - 176usize];
    ["Offset of field: _IO_FILE::_prevchain"]
        [::std::mem::offset_of!(_IO_FILE, _prevchain) - 184usize];
    ["Offset of field: _IO_FILE::_mode"][::std::mem::offset_of!(_IO_FILE, _mode) - 192usize];
    ["Offset of field: _IO_FILE::_unused2"][::std::mem::offset_of!(_IO_FILE, _unused2) - 196usize];
};
pub type cookie_read_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *mut ::std::os::raw::c_char,
        __nbytes: usize,
    ) -> __ssize_t,
>;
pub type cookie_write_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *const ::std::os::raw::c_char,
        __nbytes: usize,
    ) -> __ssize_t,
>;
pub type cookie_seek_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __pos: *mut __off64_t,
        __w: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type cookie_close_function_t = ::std::option::Option<
    unsafe extern "C" fn(__cookie: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_cookie_io_functions_t {
    pub read: cookie_read_function_t,
    pub write: cookie_write_function_t,
    pub seek: cookie_seek_function_t,
    pub close: cookie_close_function_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _IO_cookie_io_functions_t"]
        [::std::mem::size_of::<_IO_cookie_io_functions_t>() - 32usize];
    ["Alignment of _IO_cookie_io_functions_t"]
        [::std::mem::align_of::<_IO_cookie_io_functions_t>() - 8usize];
    ["Offset of field: _IO_cookie_io_functions_t::read"]
        [::std::mem::offset_of!(_IO_cookie_io_functions_t, read) - 0usize];
    ["Offset of field: _IO_cookie_io_functions_t::write"]
        [::std::mem::offset_of!(_IO_cookie_io_functions_t, write) - 8usize];
    ["Offset of field: _IO_cookie_io_functions_t::seek"]
        [::std::mem::offset_of!(_IO_cookie_io_functions_t, seek) - 16usize];
    ["Offset of field: _IO_cookie_io_functions_t::close"]
        [::std::mem::offset_of!(_IO_cookie_io_functions_t, close) - 24usize];
};
pub type cookie_io_functions_t = _IO_cookie_io_functions_t;
pub type va_list = __gnuc_va_list;
pub type fpos_t = __fpos_t;
unsafe extern "C" {
    pub static mut stdin: *mut FILE;
}
unsafe extern "C" {
    pub static mut stdout: *mut FILE;
}
unsafe extern "C" {
    pub static mut stderr: *mut FILE;
}
unsafe extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
unsafe extern "C" {
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
        -> *mut FILE;
}
unsafe extern "C" {
    pub fn fopencookie(
        __magic_cookie: *mut ::std::os::raw::c_void,
        __modes: *const ::std::os::raw::c_char,
        __io_funcs: cookie_io_functions_t,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn fmemopen(
        __s: *mut ::std::os::raw::c_void,
        __len: usize,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut usize,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: usize);
}
unsafe extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
unsafe extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vasprintf(
        __ptr: *mut *mut ::std::os::raw::c_char,
        __f: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __asprintf(
        __ptr: *mut *mut ::std::os::raw::c_char,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn asprintf(
        __ptr: *mut *mut ::std::os::raw::c_char,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
        -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
unsafe extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
unsafe extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
unsafe extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __s: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
unsafe extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
unsafe extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
unsafe extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
unsafe extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
unsafe extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
unsafe extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
unsafe extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
unsafe extern "C" {
    pub fn __uflow(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __overflow(arg1: *mut FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
pub const spa_direction_SPA_DIRECTION_INPUT: spa_direction = 0;
pub const spa_direction_SPA_DIRECTION_OUTPUT: spa_direction = 1;
pub type spa_direction = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_rectangle {
    pub width: u32,
    pub height: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_rectangle"][::std::mem::size_of::<spa_rectangle>() - 8usize];
    ["Alignment of spa_rectangle"][::std::mem::align_of::<spa_rectangle>() - 4usize];
    ["Offset of field: spa_rectangle::width"]
        [::std::mem::offset_of!(spa_rectangle, width) - 0usize];
    ["Offset of field: spa_rectangle::height"]
        [::std::mem::offset_of!(spa_rectangle, height) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_point {
    pub x: i32,
    pub y: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_point"][::std::mem::size_of::<spa_point>() - 8usize];
    ["Alignment of spa_point"][::std::mem::align_of::<spa_point>() - 4usize];
    ["Offset of field: spa_point::x"][::std::mem::offset_of!(spa_point, x) - 0usize];
    ["Offset of field: spa_point::y"][::std::mem::offset_of!(spa_point, y) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_region {
    pub position: spa_point,
    pub size: spa_rectangle,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_region"][::std::mem::size_of::<spa_region>() - 16usize];
    ["Alignment of spa_region"][::std::mem::align_of::<spa_region>() - 4usize];
    ["Offset of field: spa_region::position"]
        [::std::mem::offset_of!(spa_region, position) - 0usize];
    ["Offset of field: spa_region::size"][::std::mem::offset_of!(spa_region, size) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_fraction {
    pub num: u32,
    pub denom: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_fraction"][::std::mem::size_of::<spa_fraction>() - 8usize];
    ["Alignment of spa_fraction"][::std::mem::align_of::<spa_fraction>() - 4usize];
    ["Offset of field: spa_fraction::num"][::std::mem::offset_of!(spa_fraction, num) - 0usize];
    ["Offset of field: spa_fraction::denom"][::std::mem::offset_of!(spa_fraction, denom) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_error_location {
    pub line: ::std::os::raw::c_int,
    pub col: ::std::os::raw::c_int,
    pub len: usize,
    pub location: *const ::std::os::raw::c_char,
    pub reason: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_error_location"][::std::mem::size_of::<spa_error_location>() - 32usize];
    ["Alignment of spa_error_location"][::std::mem::align_of::<spa_error_location>() - 8usize];
    ["Offset of field: spa_error_location::line"]
        [::std::mem::offset_of!(spa_error_location, line) - 0usize];
    ["Offset of field: spa_error_location::col"]
        [::std::mem::offset_of!(spa_error_location, col) - 4usize];
    ["Offset of field: spa_error_location::len"]
        [::std::mem::offset_of!(spa_error_location, len) - 8usize];
    ["Offset of field: spa_error_location::location"]
        [::std::mem::offset_of!(spa_error_location, location) - 16usize];
    ["Offset of field: spa_error_location::reason"]
        [::std::mem::offset_of!(spa_error_location, reason) - 24usize];
};
#[doc = " \\addtogroup spa_list List\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_list {
    pub next: *mut spa_list,
    pub prev: *mut spa_list,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_list"][::std::mem::size_of::<spa_list>() - 16usize];
    ["Alignment of spa_list"][::std::mem::align_of::<spa_list>() - 8usize];
    ["Offset of field: spa_list::next"][::std::mem::offset_of!(spa_list, next) - 0usize];
    ["Offset of field: spa_list::prev"][::std::mem::offset_of!(spa_list, prev) - 8usize];
};
#[doc = " \\struct spa_callbacks\n Callbacks, contains the structure with functions and the data passed\n to the functions.  The structure should also contain a version field that\n is checked."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_callbacks {
    pub funcs: *const ::std::os::raw::c_void,
    pub data: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_callbacks"][::std::mem::size_of::<spa_callbacks>() - 16usize];
    ["Alignment of spa_callbacks"][::std::mem::align_of::<spa_callbacks>() - 8usize];
    ["Offset of field: spa_callbacks::funcs"]
        [::std::mem::offset_of!(spa_callbacks, funcs) - 0usize];
    ["Offset of field: spa_callbacks::data"][::std::mem::offset_of!(spa_callbacks, data) - 8usize];
};
#[doc = " \\struct spa_interface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_interface {
    pub type_: *const ::std::os::raw::c_char,
    pub version: u32,
    pub cb: spa_callbacks,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_interface"][::std::mem::size_of::<spa_interface>() - 32usize];
    ["Alignment of spa_interface"][::std::mem::align_of::<spa_interface>() - 8usize];
    ["Offset of field: spa_interface::type_"]
        [::std::mem::offset_of!(spa_interface, type_) - 0usize];
    ["Offset of field: spa_interface::version"]
        [::std::mem::offset_of!(spa_interface, version) - 8usize];
    ["Offset of field: spa_interface::cb"][::std::mem::offset_of!(spa_interface, cb) - 16usize];
};
#[doc = " \\struct spa_hook_list\n A list of hooks. This struct is primarily used by\n implementation that use multiple caller-provided \\ref spa_hook."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_hook_list {
    pub list: spa_list,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_hook_list"][::std::mem::size_of::<spa_hook_list>() - 16usize];
    ["Alignment of spa_hook_list"][::std::mem::align_of::<spa_hook_list>() - 8usize];
    ["Offset of field: spa_hook_list::list"][::std::mem::offset_of!(spa_hook_list, list) - 0usize];
};
#[doc = " \\struct spa_hook\n A hook, contains the structure with functions and the data passed\n to the functions.\n\n A hook should be treated as opaque by the caller."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_hook {
    pub link: spa_list,
    pub cb: spa_callbacks,
    #[doc = " callback and data for the hook list, private to the\n hook_list implementor"]
    pub removed: ::std::option::Option<unsafe extern "C" fn(hook: *mut spa_hook)>,
    pub priv_: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_hook"][::std::mem::size_of::<spa_hook>() - 48usize];
    ["Alignment of spa_hook"][::std::mem::align_of::<spa_hook>() - 8usize];
    ["Offset of field: spa_hook::link"][::std::mem::offset_of!(spa_hook, link) - 0usize];
    ["Offset of field: spa_hook::cb"][::std::mem::offset_of!(spa_hook, cb) - 16usize];
    ["Offset of field: spa_hook::removed"][::std::mem::offset_of!(spa_hook, removed) - 32usize];
    ["Offset of field: spa_hook::priv_"][::std::mem::offset_of!(spa_hook, priv_) - 40usize];
};
#[doc = " \\addtogroup spa_dict\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_dict_item {
    pub key: *const ::std::os::raw::c_char,
    pub value: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_dict_item"][::std::mem::size_of::<spa_dict_item>() - 16usize];
    ["Alignment of spa_dict_item"][::std::mem::align_of::<spa_dict_item>() - 8usize];
    ["Offset of field: spa_dict_item::key"][::std::mem::offset_of!(spa_dict_item, key) - 0usize];
    ["Offset of field: spa_dict_item::value"]
        [::std::mem::offset_of!(spa_dict_item, value) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_dict {
    pub flags: u32,
    pub n_items: u32,
    pub items: *const spa_dict_item,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_dict"][::std::mem::size_of::<spa_dict>() - 16usize];
    ["Alignment of spa_dict"][::std::mem::align_of::<spa_dict>() - 8usize];
    ["Offset of field: spa_dict::flags"][::std::mem::offset_of!(spa_dict, flags) - 0usize];
    ["Offset of field: spa_dict::n_items"][::std::mem::offset_of!(spa_dict, n_items) - 4usize];
    ["Offset of field: spa_dict::items"][::std::mem::offset_of!(spa_dict, items) - 8usize];
};
#[doc = " \\addtogroup spa_handle\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_handle {
    pub version: u32,
    #[doc = " Get the interface provided by \\a handle with \\a type.\n\n \\a interface is always a struct spa_interface but depending on\n \\a type, the struct might contain other information.\n\n \\param handle a spa_handle\n \\param type the interface type\n \\param iface result to hold the interface.\n \\return 0 on success\n         -ENOTSUP when there are no interfaces\n         -EINVAL when handle or info is NULL"]
    pub get_interface: ::std::option::Option<
        unsafe extern "C" fn(
            handle: *mut spa_handle,
            type_: *const ::std::os::raw::c_char,
            iface: *mut *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Clean up the memory of \\a handle. After this, \\a handle should not be used\n anymore.\n\n \\param handle a pointer to memory\n \\return 0 on success"]
    pub clear: ::std::option::Option<
        unsafe extern "C" fn(handle: *mut spa_handle) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_handle"][::std::mem::size_of::<spa_handle>() - 24usize];
    ["Alignment of spa_handle"][::std::mem::align_of::<spa_handle>() - 8usize];
    ["Offset of field: spa_handle::version"][::std::mem::offset_of!(spa_handle, version) - 0usize];
    ["Offset of field: spa_handle::get_interface"]
        [::std::mem::offset_of!(spa_handle, get_interface) - 8usize];
    ["Offset of field: spa_handle::clear"][::std::mem::offset_of!(spa_handle, clear) - 16usize];
};
#[doc = " This structure lists the information about available interfaces on\n handles."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_interface_info {
    pub type_: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_interface_info"][::std::mem::size_of::<spa_interface_info>() - 8usize];
    ["Alignment of spa_interface_info"][::std::mem::align_of::<spa_interface_info>() - 8usize];
    ["Offset of field: spa_interface_info::type_"]
        [::std::mem::offset_of!(spa_interface_info, type_) - 0usize];
};
#[doc = " Extra supporting infrastructure passed to the init() function of\n a factory. It can be extra information or interfaces such as logging."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_support {
    pub type_: *const ::std::os::raw::c_char,
    pub data: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_support"][::std::mem::size_of::<spa_support>() - 16usize];
    ["Alignment of spa_support"][::std::mem::align_of::<spa_support>() - 8usize];
    ["Offset of field: spa_support::type_"][::std::mem::offset_of!(spa_support, type_) - 0usize];
    ["Offset of field: spa_support::data"][::std::mem::offset_of!(spa_support, data) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_handle_factory {
    pub version: u32,
    #[doc = " The name of the factory contains a logical name that describes\n the function of the handle. Other plugins might contain an alternative\n implementation with the same name.\n\n See utils/names.h for the list of standard names.\n\n Examples include:\n\n  api.alsa.pcm.sink: an object to write PCM samples to an alsa PLAYBACK\n\t\t\tdevice\n  api.v4l2.source: an object to read from a v4l2 source."]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " Extra information about the handles of this factory."]
    pub info: *const spa_dict,
    #[doc = " Get the size of handles from this factory.\n\n \\param factory a spa_handle_factory\n \\param params extra parameters that determine the size of the\n handle."]
    pub get_size: ::std::option::Option<
        unsafe extern "C" fn(factory: *const spa_handle_factory, params: *const spa_dict) -> usize,
    >,
    #[doc = " Initialize an instance of this factory. The caller should allocate\n memory at least size bytes and pass this as \\a handle.\n\n \\a support can optionally contain extra interfaces or data items that the\n plugin can use such as a logger.\n\n \\param factory a spa_handle_factory\n \\param handle a pointer to memory\n \\param info extra handle specific information, usually obtained\n        from a spa_device. This can be used to configure the handle.\n \\param support support items\n \\param n_support number of elements in \\a support\n \\return 0 on success\n\t   < 0 errno type error"]
    pub init: ::std::option::Option<
        unsafe extern "C" fn(
            factory: *const spa_handle_factory,
            handle: *mut spa_handle,
            info: *const spa_dict,
            support: *const spa_support,
            n_support: u32,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " spa_handle_factory::enum_interface_info:\n \\param factory: a #spa_handle_factory\n \\param info: result to hold spa_interface_info.\n \\param index: index to keep track of the enumeration, 0 for first item\n\n Enumerate the interface information for \\a factory.\n\n \\return 1 when an item is available\n\t   0 when no more items are available\n\t   < 0 errno type error"]
    pub enum_interface_info: ::std::option::Option<
        unsafe extern "C" fn(
            factory: *const spa_handle_factory,
            info: *mut *const spa_interface_info,
            index: *mut u32,
        ) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_handle_factory"][::std::mem::size_of::<spa_handle_factory>() - 48usize];
    ["Alignment of spa_handle_factory"][::std::mem::align_of::<spa_handle_factory>() - 8usize];
    ["Offset of field: spa_handle_factory::version"]
        [::std::mem::offset_of!(spa_handle_factory, version) - 0usize];
    ["Offset of field: spa_handle_factory::name"]
        [::std::mem::offset_of!(spa_handle_factory, name) - 8usize];
    ["Offset of field: spa_handle_factory::info"]
        [::std::mem::offset_of!(spa_handle_factory, info) - 16usize];
    ["Offset of field: spa_handle_factory::get_size"]
        [::std::mem::offset_of!(spa_handle_factory, get_size) - 24usize];
    ["Offset of field: spa_handle_factory::init"]
        [::std::mem::offset_of!(spa_handle_factory, init) - 32usize];
    ["Offset of field: spa_handle_factory::enum_interface_info"]
        [::std::mem::offset_of!(spa_handle_factory, enum_interface_info) - 40usize];
};
#[doc = " The function signature of the entry point in a plugin.\n\n \\param factory a location to hold the factory result\n \\param index index to keep track of the enumeration\n \\return 1 on success\n         0 when there are no more factories\n         -EINVAL when factory is NULL"]
pub type spa_handle_factory_enum_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        factory: *mut *const spa_handle_factory,
        index: *mut u32,
    ) -> ::std::os::raw::c_int,
>;
unsafe extern "C" {
    #[doc = " The entry point in a plugin.\n\n \\param factory a location to hold the factory result\n \\param index index to keep track of the enumeration\n \\return 1 on success\n\t   0 when no more items are available\n\t   < 0 errno type error"]
    pub fn spa_handle_factory_enum(
        factory: *mut *const spa_handle_factory,
        index: *mut u32,
    ) -> ::std::os::raw::c_int;
}
#[doc = " \\addtogroup pw_array\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_array {
    #[doc = "< pointer to array data"]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = "< length of array in bytes"]
    pub size: usize,
    #[doc = "< number of allocated memory in \\a data"]
    pub alloc: usize,
    #[doc = "< number of bytes to extend with, 0 when the\n  data should not expand"]
    pub extend: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_array"][::std::mem::size_of::<pw_array>() - 32usize];
    ["Alignment of pw_array"][::std::mem::align_of::<pw_array>() - 8usize];
    ["Offset of field: pw_array::data"][::std::mem::offset_of!(pw_array, data) - 0usize];
    ["Offset of field: pw_array::size"][::std::mem::offset_of!(pw_array, size) - 8usize];
    ["Offset of field: pw_array::alloc"][::std::mem::offset_of!(pw_array, alloc) - 16usize];
    ["Offset of field: pw_array::extend"][::std::mem::offset_of!(pw_array, extend) - 24usize];
};
#[doc = "< invalid"]
pub const spa_param_type_SPA_PARAM_Invalid: spa_param_type = 0;
#[doc = "< property information as SPA_TYPE_OBJECT_PropInfo"]
pub const spa_param_type_SPA_PARAM_PropInfo: spa_param_type = 1;
#[doc = "< properties as SPA_TYPE_OBJECT_Props"]
pub const spa_param_type_SPA_PARAM_Props: spa_param_type = 2;
#[doc = "< available formats as SPA_TYPE_OBJECT_Format"]
pub const spa_param_type_SPA_PARAM_EnumFormat: spa_param_type = 3;
#[doc = "< configured format as SPA_TYPE_OBJECT_Format"]
pub const spa_param_type_SPA_PARAM_Format: spa_param_type = 4;
#[doc = "< buffer configurations as SPA_TYPE_OBJECT_ParamBuffers"]
pub const spa_param_type_SPA_PARAM_Buffers: spa_param_type = 5;
#[doc = "< allowed metadata for buffers as SPA_TYPE_OBJECT_ParamMeta"]
pub const spa_param_type_SPA_PARAM_Meta: spa_param_type = 6;
#[doc = "< configurable IO areas as SPA_TYPE_OBJECT_ParamIO"]
pub const spa_param_type_SPA_PARAM_IO: spa_param_type = 7;
#[doc = "< profile enumeration as SPA_TYPE_OBJECT_ParamProfile"]
pub const spa_param_type_SPA_PARAM_EnumProfile: spa_param_type = 8;
#[doc = "< profile configuration as SPA_TYPE_OBJECT_ParamProfile"]
pub const spa_param_type_SPA_PARAM_Profile: spa_param_type = 9;
#[doc = "< port configuration enumeration as SPA_TYPE_OBJECT_ParamPortConfig"]
pub const spa_param_type_SPA_PARAM_EnumPortConfig: spa_param_type = 10;
#[doc = "< port configuration as SPA_TYPE_OBJECT_ParamPortConfig"]
pub const spa_param_type_SPA_PARAM_PortConfig: spa_param_type = 11;
#[doc = "< routing enumeration as SPA_TYPE_OBJECT_ParamRoute"]
pub const spa_param_type_SPA_PARAM_EnumRoute: spa_param_type = 12;
#[doc = "< routing configuration as SPA_TYPE_OBJECT_ParamRoute"]
pub const spa_param_type_SPA_PARAM_Route: spa_param_type = 13;
#[doc = "< Control parameter, a SPA_TYPE_Sequence"]
pub const spa_param_type_SPA_PARAM_Control: spa_param_type = 14;
#[doc = "< latency reporting, a SPA_TYPE_OBJECT_ParamLatency"]
pub const spa_param_type_SPA_PARAM_Latency: spa_param_type = 15;
#[doc = "< processing latency, a SPA_TYPE_OBJECT_ParamProcessLatency"]
pub const spa_param_type_SPA_PARAM_ProcessLatency: spa_param_type = 16;
#[doc = "< tag reporting, a SPA_TYPE_OBJECT_ParamTag. Since 0.3.79"]
pub const spa_param_type_SPA_PARAM_Tag: spa_param_type = 17;
#[doc = " different parameter types that can be queried"]
pub type spa_param_type = ::std::os::raw::c_uint;
#[doc = " information about a parameter"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_param_info {
    #[doc = "< enum spa_param_type"]
    pub id: u32,
    pub flags: u32,
    #[doc = "< private user field. You can use this to keep\n  state."]
    pub user: u32,
    #[doc = "< private seq field. You can use this to keep\n  state of a pending update."]
    pub seq: i32,
    pub padding: [u32; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_param_info"][::std::mem::size_of::<spa_param_info>() - 32usize];
    ["Alignment of spa_param_info"][::std::mem::align_of::<spa_param_info>() - 4usize];
    ["Offset of field: spa_param_info::id"][::std::mem::offset_of!(spa_param_info, id) - 0usize];
    ["Offset of field: spa_param_info::flags"]
        [::std::mem::offset_of!(spa_param_info, flags) - 4usize];
    ["Offset of field: spa_param_info::user"]
        [::std::mem::offset_of!(spa_param_info, user) - 8usize];
    ["Offset of field: spa_param_info::seq"][::std::mem::offset_of!(spa_param_info, seq) - 12usize];
    ["Offset of field: spa_param_info::padding"]
        [::std::mem::offset_of!(spa_param_info, padding) - 16usize];
};
#[doc = "< unknown bitorder"]
pub const spa_param_bitorder_SPA_PARAM_BITORDER_unknown: spa_param_bitorder = 0;
#[doc = "< most significant bit"]
pub const spa_param_bitorder_SPA_PARAM_BITORDER_msb: spa_param_bitorder = 1;
#[doc = "< least significant bit"]
pub const spa_param_bitorder_SPA_PARAM_BITORDER_lsb: spa_param_bitorder = 2;
pub type spa_param_bitorder = ::std::os::raw::c_uint;
#[doc = "< unknown availability"]
pub const spa_param_availability_SPA_PARAM_AVAILABILITY_unknown: spa_param_availability = 0;
#[doc = "< not available"]
pub const spa_param_availability_SPA_PARAM_AVAILABILITY_no: spa_param_availability = 1;
#[doc = "< available"]
pub const spa_param_availability_SPA_PARAM_AVAILABILITY_yes: spa_param_availability = 2;
pub type spa_param_availability = ::std::os::raw::c_uint;
pub const spa_param_buffers_SPA_PARAM_BUFFERS_START: spa_param_buffers = 0;
#[doc = "< number of buffers (Int)"]
pub const spa_param_buffers_SPA_PARAM_BUFFERS_buffers: spa_param_buffers = 1;
#[doc = "< number of data blocks per buffer (Int)"]
pub const spa_param_buffers_SPA_PARAM_BUFFERS_blocks: spa_param_buffers = 2;
#[doc = "< size of a data block memory (Int)"]
pub const spa_param_buffers_SPA_PARAM_BUFFERS_size: spa_param_buffers = 3;
#[doc = "< stride of data block memory (Int)"]
pub const spa_param_buffers_SPA_PARAM_BUFFERS_stride: spa_param_buffers = 4;
#[doc = "< alignment of data block memory (Int)"]
pub const spa_param_buffers_SPA_PARAM_BUFFERS_align: spa_param_buffers = 5;
#[doc = "< possible memory types (flags choice Int, mask of enum spa_data_type)"]
pub const spa_param_buffers_SPA_PARAM_BUFFERS_dataType: spa_param_buffers = 6;
#[doc = "< required meta data types (Int, mask of enum spa_meta_type)"]
pub const spa_param_buffers_SPA_PARAM_BUFFERS_metaType: spa_param_buffers = 7;
#[doc = " properties for SPA_TYPE_OBJECT_ParamBuffers"]
pub type spa_param_buffers = ::std::os::raw::c_uint;
pub const spa_param_meta_SPA_PARAM_META_START: spa_param_meta = 0;
#[doc = "< the metadata, one of enum spa_meta_type (Id enum spa_meta_type)"]
pub const spa_param_meta_SPA_PARAM_META_type: spa_param_meta = 1;
#[doc = "< the expected maximum size the meta (Int)"]
pub const spa_param_meta_SPA_PARAM_META_size: spa_param_meta = 2;
#[doc = " properties for SPA_TYPE_OBJECT_ParamMeta"]
pub type spa_param_meta = ::std::os::raw::c_uint;
pub const spa_param_io_SPA_PARAM_IO_START: spa_param_io = 0;
#[doc = "< type ID, uniquely identifies the io area (Id enum spa_io_type)"]
pub const spa_param_io_SPA_PARAM_IO_id: spa_param_io = 1;
#[doc = "< size of the io area (Int)"]
pub const spa_param_io_SPA_PARAM_IO_size: spa_param_io = 2;
#[doc = " properties for SPA_TYPE_OBJECT_ParamIO"]
pub type spa_param_io = ::std::os::raw::c_uint;
pub const spa_param_profile_SPA_PARAM_PROFILE_START: spa_param_profile = 0;
#[doc = "< profile index (Int)"]
pub const spa_param_profile_SPA_PARAM_PROFILE_index: spa_param_profile = 1;
#[doc = "< profile name (String)"]
pub const spa_param_profile_SPA_PARAM_PROFILE_name: spa_param_profile = 2;
#[doc = "< profile description (String)"]
pub const spa_param_profile_SPA_PARAM_PROFILE_description: spa_param_profile = 3;
#[doc = "< profile priority (Int)"]
pub const spa_param_profile_SPA_PARAM_PROFILE_priority: spa_param_profile = 4;
#[doc = "< availability of the profile\n  (Id enum spa_param_availability)"]
pub const spa_param_profile_SPA_PARAM_PROFILE_available: spa_param_profile = 5;
#[doc = "< info (Struct(\n\t\t  Int : n_items,\n\t\t  (String : key,\n\t\t   String : value)*))"]
pub const spa_param_profile_SPA_PARAM_PROFILE_info: spa_param_profile = 6;
#[doc = "< node classes provided by this profile\n  (Struct(\n\t   Int : number of items following\n        Struct(\n           String : class name (eg. \"Audio/Source\"),\n           Int : number of nodes\n           String : property (eg. \"card.profile.devices\"),\n           Array of Int: device indexes\n         )*))"]
pub const spa_param_profile_SPA_PARAM_PROFILE_classes: spa_param_profile = 7;
#[doc = "< If profile should be saved (Bool)"]
pub const spa_param_profile_SPA_PARAM_PROFILE_save: spa_param_profile = 8;
#[doc = " properties for SPA_TYPE_OBJECT_ParamProfile"]
pub type spa_param_profile = ::std::os::raw::c_uint;
#[doc = "< no configuration"]
pub const spa_param_port_config_mode_SPA_PARAM_PORT_CONFIG_MODE_none: spa_param_port_config_mode =
    0;
#[doc = "< passthrough configuration"]
pub const spa_param_port_config_mode_SPA_PARAM_PORT_CONFIG_MODE_passthrough:
    spa_param_port_config_mode = 1;
#[doc = "< convert configuration"]
pub const spa_param_port_config_mode_SPA_PARAM_PORT_CONFIG_MODE_convert:
    spa_param_port_config_mode = 2;
#[doc = "< dsp configuration, depending on the external\n  format. For audio, ports will be configured for\n  the given number of channels with F32 format."]
pub const spa_param_port_config_mode_SPA_PARAM_PORT_CONFIG_MODE_dsp: spa_param_port_config_mode = 3;
pub type spa_param_port_config_mode = ::std::os::raw::c_uint;
pub const spa_param_port_config_SPA_PARAM_PORT_CONFIG_START: spa_param_port_config = 0;
#[doc = "< (Id enum spa_direction) direction"]
pub const spa_param_port_config_SPA_PARAM_PORT_CONFIG_direction: spa_param_port_config = 1;
#[doc = "< (Id enum spa_param_port_config_mode) mode"]
pub const spa_param_port_config_SPA_PARAM_PORT_CONFIG_mode: spa_param_port_config = 2;
#[doc = "< (Bool) enable monitor output ports on input ports"]
pub const spa_param_port_config_SPA_PARAM_PORT_CONFIG_monitor: spa_param_port_config = 3;
#[doc = "< (Bool) enable control ports"]
pub const spa_param_port_config_SPA_PARAM_PORT_CONFIG_control: spa_param_port_config = 4;
#[doc = "< (Object) format filter"]
pub const spa_param_port_config_SPA_PARAM_PORT_CONFIG_format: spa_param_port_config = 5;
#[doc = " properties for SPA_TYPE_OBJECT_ParamPortConfig"]
pub type spa_param_port_config = ::std::os::raw::c_uint;
pub const spa_param_route_SPA_PARAM_ROUTE_START: spa_param_route = 0;
#[doc = "< index of the routing destination (Int)"]
pub const spa_param_route_SPA_PARAM_ROUTE_index: spa_param_route = 1;
#[doc = "< direction, input/output (Id enum spa_direction)"]
pub const spa_param_route_SPA_PARAM_ROUTE_direction: spa_param_route = 2;
#[doc = "< device id (Int)"]
pub const spa_param_route_SPA_PARAM_ROUTE_device: spa_param_route = 3;
#[doc = "< name of the routing destination (String)"]
pub const spa_param_route_SPA_PARAM_ROUTE_name: spa_param_route = 4;
#[doc = "< description of the destination (String)"]
pub const spa_param_route_SPA_PARAM_ROUTE_description: spa_param_route = 5;
#[doc = "< priority of the destination (Int)"]
pub const spa_param_route_SPA_PARAM_ROUTE_priority: spa_param_route = 6;
#[doc = "< availability of the destination\n  (Id enum spa_param_availability)"]
pub const spa_param_route_SPA_PARAM_ROUTE_available: spa_param_route = 7;
#[doc = "< info (Struct(\n\t\t  Int : n_items,\n\t\t  (String : key,\n\t\t   String : value)*))"]
pub const spa_param_route_SPA_PARAM_ROUTE_info: spa_param_route = 8;
#[doc = "< associated profile indexes (Array of Int)"]
pub const spa_param_route_SPA_PARAM_ROUTE_profiles: spa_param_route = 9;
#[doc = "< properties SPA_TYPE_OBJECT_Props"]
pub const spa_param_route_SPA_PARAM_ROUTE_props: spa_param_route = 10;
#[doc = "< associated device indexes (Array of Int)"]
pub const spa_param_route_SPA_PARAM_ROUTE_devices: spa_param_route = 11;
#[doc = "< profile id (Int)"]
pub const spa_param_route_SPA_PARAM_ROUTE_profile: spa_param_route = 12;
#[doc = "< If route should be saved (Bool)"]
pub const spa_param_route_SPA_PARAM_ROUTE_save: spa_param_route = 13;
#[doc = " properties for SPA_TYPE_OBJECT_ParamRoute"]
pub type spa_param_route = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lconv {
    pub decimal_point: *mut ::std::os::raw::c_char,
    pub thousands_sep: *mut ::std::os::raw::c_char,
    pub grouping: *mut ::std::os::raw::c_char,
    pub int_curr_symbol: *mut ::std::os::raw::c_char,
    pub currency_symbol: *mut ::std::os::raw::c_char,
    pub mon_decimal_point: *mut ::std::os::raw::c_char,
    pub mon_thousands_sep: *mut ::std::os::raw::c_char,
    pub mon_grouping: *mut ::std::os::raw::c_char,
    pub positive_sign: *mut ::std::os::raw::c_char,
    pub negative_sign: *mut ::std::os::raw::c_char,
    pub int_frac_digits: ::std::os::raw::c_char,
    pub frac_digits: ::std::os::raw::c_char,
    pub p_cs_precedes: ::std::os::raw::c_char,
    pub p_sep_by_space: ::std::os::raw::c_char,
    pub n_cs_precedes: ::std::os::raw::c_char,
    pub n_sep_by_space: ::std::os::raw::c_char,
    pub p_sign_posn: ::std::os::raw::c_char,
    pub n_sign_posn: ::std::os::raw::c_char,
    pub int_p_cs_precedes: ::std::os::raw::c_char,
    pub int_p_sep_by_space: ::std::os::raw::c_char,
    pub int_n_cs_precedes: ::std::os::raw::c_char,
    pub int_n_sep_by_space: ::std::os::raw::c_char,
    pub int_p_sign_posn: ::std::os::raw::c_char,
    pub int_n_sign_posn: ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of lconv"][::std::mem::size_of::<lconv>() - 96usize];
    ["Alignment of lconv"][::std::mem::align_of::<lconv>() - 8usize];
    ["Offset of field: lconv::decimal_point"]
        [::std::mem::offset_of!(lconv, decimal_point) - 0usize];
    ["Offset of field: lconv::thousands_sep"]
        [::std::mem::offset_of!(lconv, thousands_sep) - 8usize];
    ["Offset of field: lconv::grouping"][::std::mem::offset_of!(lconv, grouping) - 16usize];
    ["Offset of field: lconv::int_curr_symbol"]
        [::std::mem::offset_of!(lconv, int_curr_symbol) - 24usize];
    ["Offset of field: lconv::currency_symbol"]
        [::std::mem::offset_of!(lconv, currency_symbol) - 32usize];
    ["Offset of field: lconv::mon_decimal_point"]
        [::std::mem::offset_of!(lconv, mon_decimal_point) - 40usize];
    ["Offset of field: lconv::mon_thousands_sep"]
        [::std::mem::offset_of!(lconv, mon_thousands_sep) - 48usize];
    ["Offset of field: lconv::mon_grouping"][::std::mem::offset_of!(lconv, mon_grouping) - 56usize];
    ["Offset of field: lconv::positive_sign"]
        [::std::mem::offset_of!(lconv, positive_sign) - 64usize];
    ["Offset of field: lconv::negative_sign"]
        [::std::mem::offset_of!(lconv, negative_sign) - 72usize];
    ["Offset of field: lconv::int_frac_digits"]
        [::std::mem::offset_of!(lconv, int_frac_digits) - 80usize];
    ["Offset of field: lconv::frac_digits"][::std::mem::offset_of!(lconv, frac_digits) - 81usize];
    ["Offset of field: lconv::p_cs_precedes"]
        [::std::mem::offset_of!(lconv, p_cs_precedes) - 82usize];
    ["Offset of field: lconv::p_sep_by_space"]
        [::std::mem::offset_of!(lconv, p_sep_by_space) - 83usize];
    ["Offset of field: lconv::n_cs_precedes"]
        [::std::mem::offset_of!(lconv, n_cs_precedes) - 84usize];
    ["Offset of field: lconv::n_sep_by_space"]
        [::std::mem::offset_of!(lconv, n_sep_by_space) - 85usize];
    ["Offset of field: lconv::p_sign_posn"][::std::mem::offset_of!(lconv, p_sign_posn) - 86usize];
    ["Offset of field: lconv::n_sign_posn"][::std::mem::offset_of!(lconv, n_sign_posn) - 87usize];
    ["Offset of field: lconv::int_p_cs_precedes"]
        [::std::mem::offset_of!(lconv, int_p_cs_precedes) - 88usize];
    ["Offset of field: lconv::int_p_sep_by_space"]
        [::std::mem::offset_of!(lconv, int_p_sep_by_space) - 89usize];
    ["Offset of field: lconv::int_n_cs_precedes"]
        [::std::mem::offset_of!(lconv, int_n_cs_precedes) - 90usize];
    ["Offset of field: lconv::int_n_sep_by_space"]
        [::std::mem::offset_of!(lconv, int_n_sep_by_space) - 91usize];
    ["Offset of field: lconv::int_p_sign_posn"]
        [::std::mem::offset_of!(lconv, int_p_sign_posn) - 92usize];
    ["Offset of field: lconv::int_n_sign_posn"]
        [::std::mem::offset_of!(lconv, int_n_sign_posn) - 93usize];
};
unsafe extern "C" {
    pub fn setlocale(
        __category: ::std::os::raw::c_int,
        __locale: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn localeconv() -> *mut lconv;
}
unsafe extern "C" {
    pub fn newlocale(
        __category_mask: ::std::os::raw::c_int,
        __locale: *const ::std::os::raw::c_char,
        __base: locale_t,
    ) -> locale_t;
}
unsafe extern "C" {
    pub fn duplocale(__dataset: locale_t) -> locale_t;
}
unsafe extern "C" {
    pub fn freelocale(__dataset: locale_t);
}
unsafe extern "C" {
    pub fn uselocale(__dataset: locale_t) -> locale_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_strbuf {
    pub buffer: *mut ::std::os::raw::c_char,
    pub maxsize: usize,
    pub pos: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_strbuf"][::std::mem::size_of::<spa_strbuf>() - 24usize];
    ["Alignment of spa_strbuf"][::std::mem::align_of::<spa_strbuf>() - 8usize];
    ["Offset of field: spa_strbuf::buffer"][::std::mem::offset_of!(spa_strbuf, buffer) - 0usize];
    ["Offset of field: spa_strbuf::maxsize"][::std::mem::offset_of!(spa_strbuf, maxsize) - 8usize];
    ["Offset of field: spa_strbuf::pos"][::std::mem::offset_of!(spa_strbuf, pos) - 16usize];
};
pub const SPA_TYPE_START: _bindgen_ty_10 = 0;
pub const SPA_TYPE_None: _bindgen_ty_10 = 1;
pub const SPA_TYPE_Bool: _bindgen_ty_10 = 2;
pub const SPA_TYPE_Id: _bindgen_ty_10 = 3;
pub const SPA_TYPE_Int: _bindgen_ty_10 = 4;
pub const SPA_TYPE_Long: _bindgen_ty_10 = 5;
pub const SPA_TYPE_Float: _bindgen_ty_10 = 6;
pub const SPA_TYPE_Double: _bindgen_ty_10 = 7;
pub const SPA_TYPE_String: _bindgen_ty_10 = 8;
pub const SPA_TYPE_Bytes: _bindgen_ty_10 = 9;
pub const SPA_TYPE_Rectangle: _bindgen_ty_10 = 10;
pub const SPA_TYPE_Fraction: _bindgen_ty_10 = 11;
pub const SPA_TYPE_Bitmap: _bindgen_ty_10 = 12;
pub const SPA_TYPE_Array: _bindgen_ty_10 = 13;
pub const SPA_TYPE_Struct: _bindgen_ty_10 = 14;
pub const SPA_TYPE_Object: _bindgen_ty_10 = 15;
pub const SPA_TYPE_Sequence: _bindgen_ty_10 = 16;
pub const SPA_TYPE_Pointer: _bindgen_ty_10 = 17;
pub const SPA_TYPE_Fd: _bindgen_ty_10 = 18;
pub const SPA_TYPE_Choice: _bindgen_ty_10 = 19;
pub const SPA_TYPE_Pod: _bindgen_ty_10 = 20;
#[doc = "< not part of ABI"]
pub const _SPA_TYPE_LAST: _bindgen_ty_10 = 21;
pub const SPA_TYPE_POINTER_START: _bindgen_ty_10 = 65536;
pub const SPA_TYPE_POINTER_Buffer: _bindgen_ty_10 = 65537;
pub const SPA_TYPE_POINTER_Meta: _bindgen_ty_10 = 65538;
pub const SPA_TYPE_POINTER_Dict: _bindgen_ty_10 = 65539;
#[doc = "< not part of ABI"]
pub const _SPA_TYPE_POINTER_LAST: _bindgen_ty_10 = 65540;
pub const SPA_TYPE_EVENT_START: _bindgen_ty_10 = 131072;
pub const SPA_TYPE_EVENT_Device: _bindgen_ty_10 = 131073;
pub const SPA_TYPE_EVENT_Node: _bindgen_ty_10 = 131074;
#[doc = "< not part of ABI"]
pub const _SPA_TYPE_EVENT_LAST: _bindgen_ty_10 = 131075;
pub const SPA_TYPE_COMMAND_START: _bindgen_ty_10 = 196608;
pub const SPA_TYPE_COMMAND_Device: _bindgen_ty_10 = 196609;
pub const SPA_TYPE_COMMAND_Node: _bindgen_ty_10 = 196610;
#[doc = "< not part of ABI"]
pub const _SPA_TYPE_COMMAND_LAST: _bindgen_ty_10 = 196611;
pub const SPA_TYPE_OBJECT_START: _bindgen_ty_10 = 262144;
pub const SPA_TYPE_OBJECT_PropInfo: _bindgen_ty_10 = 262145;
pub const SPA_TYPE_OBJECT_Props: _bindgen_ty_10 = 262146;
pub const SPA_TYPE_OBJECT_Format: _bindgen_ty_10 = 262147;
pub const SPA_TYPE_OBJECT_ParamBuffers: _bindgen_ty_10 = 262148;
pub const SPA_TYPE_OBJECT_ParamMeta: _bindgen_ty_10 = 262149;
pub const SPA_TYPE_OBJECT_ParamIO: _bindgen_ty_10 = 262150;
pub const SPA_TYPE_OBJECT_ParamProfile: _bindgen_ty_10 = 262151;
pub const SPA_TYPE_OBJECT_ParamPortConfig: _bindgen_ty_10 = 262152;
pub const SPA_TYPE_OBJECT_ParamRoute: _bindgen_ty_10 = 262153;
pub const SPA_TYPE_OBJECT_Profiler: _bindgen_ty_10 = 262154;
pub const SPA_TYPE_OBJECT_ParamLatency: _bindgen_ty_10 = 262155;
pub const SPA_TYPE_OBJECT_ParamProcessLatency: _bindgen_ty_10 = 262156;
pub const SPA_TYPE_OBJECT_ParamTag: _bindgen_ty_10 = 262157;
#[doc = "< not part of ABI"]
pub const _SPA_TYPE_OBJECT_LAST: _bindgen_ty_10 = 262158;
pub const SPA_TYPE_VENDOR_PipeWire: _bindgen_ty_10 = 33554432;
pub const SPA_TYPE_VENDOR_Other: _bindgen_ty_10 = 2130706432;
#[doc = " \\addtogroup spa_types\n \\{"]
pub type _bindgen_ty_10 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_type_info {
    pub type_: u32,
    pub parent: u32,
    pub name: *const ::std::os::raw::c_char,
    pub values: *const spa_type_info,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_type_info"][::std::mem::size_of::<spa_type_info>() - 24usize];
    ["Alignment of spa_type_info"][::std::mem::align_of::<spa_type_info>() - 8usize];
    ["Offset of field: spa_type_info::type_"]
        [::std::mem::offset_of!(spa_type_info, type_) - 0usize];
    ["Offset of field: spa_type_info::parent"]
        [::std::mem::offset_of!(spa_type_info, parent) - 4usize];
    ["Offset of field: spa_type_info::name"][::std::mem::offset_of!(spa_type_info, name) - 8usize];
    ["Offset of field: spa_type_info::values"]
        [::std::mem::offset_of!(spa_type_info, values) - 16usize];
};
pub const PW_TYPE_FIRST: _bindgen_ty_11 = 33554432;
#[doc = " \\addtogroup pw_type\n \\{"]
pub type _bindgen_ty_11 = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn pw_type_info() -> *const spa_type_info;
}
#[doc = " \\addtogroup pw_proxy\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_proxy {
    _unused: [u8; 0],
}
#[doc = " \\addtogroup pw_protocol\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_protocol {
    _unused: [u8; 0],
}
#[doc = " \\addtogroup pw_context\n @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_context {
    _unused: [u8; 0],
}
#[doc = " \\addtogroup pw_global\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_global {
    _unused: [u8; 0],
}
#[doc = " \\addtogroup api_pw_impl"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_impl_client {
    _unused: [u8; 0],
}
#[doc = " \\defgroup pw_impl_node Node Impl\n\n The node object processes data. The node has a list of\n input and output ports (\\ref pw_impl_port) on which it\n will receive and send out buffers respectively.\n/\n/**\n \\addtogroup pw_impl_node\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_impl_node {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_core {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_registry {
    _unused: [u8; 0],
}
#[doc = "  The core information. Extra information may be added in later versions,\n clients must not assume a constant struct size"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_core_info {
    #[doc = "< id of the global"]
    pub id: u32,
    #[doc = "< a random cookie for identifying this instance of PipeWire"]
    pub cookie: u32,
    #[doc = "< name of the user that started the core"]
    pub user_name: *const ::std::os::raw::c_char,
    #[doc = "< name of the machine the core is running on"]
    pub host_name: *const ::std::os::raw::c_char,
    #[doc = "< version of the core"]
    pub version: *const ::std::os::raw::c_char,
    #[doc = "< name of the core"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "< bitfield of changed fields since last call"]
    pub change_mask: u64,
    #[doc = "< extra properties"]
    pub props: *mut spa_dict,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_core_info"][::std::mem::size_of::<pw_core_info>() - 56usize];
    ["Alignment of pw_core_info"][::std::mem::align_of::<pw_core_info>() - 8usize];
    ["Offset of field: pw_core_info::id"][::std::mem::offset_of!(pw_core_info, id) - 0usize];
    ["Offset of field: pw_core_info::cookie"]
        [::std::mem::offset_of!(pw_core_info, cookie) - 4usize];
    ["Offset of field: pw_core_info::user_name"]
        [::std::mem::offset_of!(pw_core_info, user_name) - 8usize];
    ["Offset of field: pw_core_info::host_name"]
        [::std::mem::offset_of!(pw_core_info, host_name) - 16usize];
    ["Offset of field: pw_core_info::version"]
        [::std::mem::offset_of!(pw_core_info, version) - 24usize];
    ["Offset of field: pw_core_info::name"][::std::mem::offset_of!(pw_core_info, name) - 32usize];
    ["Offset of field: pw_core_info::change_mask"]
        [::std::mem::offset_of!(pw_core_info, change_mask) - 40usize];
    ["Offset of field: pw_core_info::props"][::std::mem::offset_of!(pw_core_info, props) - 48usize];
};
pub type useconds_t = __useconds_t;
pub type socklen_t = __socklen_t;
unsafe extern "C" {
    pub fn access(
        __name: *const ::std::os::raw::c_char,
        __type: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faccessat(
        __fd: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __type: ::std::os::raw::c_int,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn lseek(
        __fd: ::std::os::raw::c_int,
        __offset: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> __off_t;
}
unsafe extern "C" {
    pub fn close(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn closefrom(__lowfd: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn read(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __nbytes: usize,
    ) -> isize;
}
unsafe extern "C" {
    pub fn write(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> isize;
}
unsafe extern "C" {
    pub fn pread(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __nbytes: usize,
        __offset: __off_t,
    ) -> isize;
}
unsafe extern "C" {
    pub fn pwrite(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __n: usize,
        __offset: __off_t,
    ) -> isize;
}
unsafe extern "C" {
    pub fn pipe(__pipedes: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn alarm(__seconds: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub fn sleep(__seconds: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub fn ualarm(__value: __useconds_t, __interval: __useconds_t) -> __useconds_t;
}
unsafe extern "C" {
    pub fn usleep(__useconds: __useconds_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pause() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn chown(
        __file: *const ::std::os::raw::c_char,
        __owner: __uid_t,
        __group: __gid_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fchown(
        __fd: ::std::os::raw::c_int,
        __owner: __uid_t,
        __group: __gid_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn lchown(
        __file: *const ::std::os::raw::c_char,
        __owner: __uid_t,
        __group: __gid_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fchownat(
        __fd: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __owner: __uid_t,
        __group: __gid_t,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn chdir(__path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fchdir(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getcwd(__buf: *mut ::std::os::raw::c_char, __size: usize)
        -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn getwd(__buf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn dup(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn dup2(__fd: ::std::os::raw::c_int, __fd2: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub static mut __environ: *mut *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn execve(
        __path: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
        __envp: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fexecve(
        __fd: ::std::os::raw::c_int,
        __argv: *const *mut ::std::os::raw::c_char,
        __envp: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn execv(
        __path: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn execle(
        __path: *const ::std::os::raw::c_char,
        __arg: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn execl(
        __path: *const ::std::os::raw::c_char,
        __arg: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn execvp(
        __file: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn execlp(
        __file: *const ::std::os::raw::c_char,
        __arg: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn nice(__inc: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _exit(__status: ::std::os::raw::c_int) -> !;
}
pub const _PC_LINK_MAX: _bindgen_ty_12 = 0;
pub const _PC_MAX_CANON: _bindgen_ty_12 = 1;
pub const _PC_MAX_INPUT: _bindgen_ty_12 = 2;
pub const _PC_NAME_MAX: _bindgen_ty_12 = 3;
pub const _PC_PATH_MAX: _bindgen_ty_12 = 4;
pub const _PC_PIPE_BUF: _bindgen_ty_12 = 5;
pub const _PC_CHOWN_RESTRICTED: _bindgen_ty_12 = 6;
pub const _PC_NO_TRUNC: _bindgen_ty_12 = 7;
pub const _PC_VDISABLE: _bindgen_ty_12 = 8;
pub const _PC_SYNC_IO: _bindgen_ty_12 = 9;
pub const _PC_ASYNC_IO: _bindgen_ty_12 = 10;
pub const _PC_PRIO_IO: _bindgen_ty_12 = 11;
pub const _PC_SOCK_MAXBUF: _bindgen_ty_12 = 12;
pub const _PC_FILESIZEBITS: _bindgen_ty_12 = 13;
pub const _PC_REC_INCR_XFER_SIZE: _bindgen_ty_12 = 14;
pub const _PC_REC_MAX_XFER_SIZE: _bindgen_ty_12 = 15;
pub const _PC_REC_MIN_XFER_SIZE: _bindgen_ty_12 = 16;
pub const _PC_REC_XFER_ALIGN: _bindgen_ty_12 = 17;
pub const _PC_ALLOC_SIZE_MIN: _bindgen_ty_12 = 18;
pub const _PC_SYMLINK_MAX: _bindgen_ty_12 = 19;
pub const _PC_2_SYMLINKS: _bindgen_ty_12 = 20;
pub type _bindgen_ty_12 = ::std::os::raw::c_uint;
pub const _SC_ARG_MAX: _bindgen_ty_13 = 0;
pub const _SC_CHILD_MAX: _bindgen_ty_13 = 1;
pub const _SC_CLK_TCK: _bindgen_ty_13 = 2;
pub const _SC_NGROUPS_MAX: _bindgen_ty_13 = 3;
pub const _SC_OPEN_MAX: _bindgen_ty_13 = 4;
pub const _SC_STREAM_MAX: _bindgen_ty_13 = 5;
pub const _SC_TZNAME_MAX: _bindgen_ty_13 = 6;
pub const _SC_JOB_CONTROL: _bindgen_ty_13 = 7;
pub const _SC_SAVED_IDS: _bindgen_ty_13 = 8;
pub const _SC_REALTIME_SIGNALS: _bindgen_ty_13 = 9;
pub const _SC_PRIORITY_SCHEDULING: _bindgen_ty_13 = 10;
pub const _SC_TIMERS: _bindgen_ty_13 = 11;
pub const _SC_ASYNCHRONOUS_IO: _bindgen_ty_13 = 12;
pub const _SC_PRIORITIZED_IO: _bindgen_ty_13 = 13;
pub const _SC_SYNCHRONIZED_IO: _bindgen_ty_13 = 14;
pub const _SC_FSYNC: _bindgen_ty_13 = 15;
pub const _SC_MAPPED_FILES: _bindgen_ty_13 = 16;
pub const _SC_MEMLOCK: _bindgen_ty_13 = 17;
pub const _SC_MEMLOCK_RANGE: _bindgen_ty_13 = 18;
pub const _SC_MEMORY_PROTECTION: _bindgen_ty_13 = 19;
pub const _SC_MESSAGE_PASSING: _bindgen_ty_13 = 20;
pub const _SC_SEMAPHORES: _bindgen_ty_13 = 21;
pub const _SC_SHARED_MEMORY_OBJECTS: _bindgen_ty_13 = 22;
pub const _SC_AIO_LISTIO_MAX: _bindgen_ty_13 = 23;
pub const _SC_AIO_MAX: _bindgen_ty_13 = 24;
pub const _SC_AIO_PRIO_DELTA_MAX: _bindgen_ty_13 = 25;
pub const _SC_DELAYTIMER_MAX: _bindgen_ty_13 = 26;
pub const _SC_MQ_OPEN_MAX: _bindgen_ty_13 = 27;
pub const _SC_MQ_PRIO_MAX: _bindgen_ty_13 = 28;
pub const _SC_VERSION: _bindgen_ty_13 = 29;
pub const _SC_PAGESIZE: _bindgen_ty_13 = 30;
pub const _SC_RTSIG_MAX: _bindgen_ty_13 = 31;
pub const _SC_SEM_NSEMS_MAX: _bindgen_ty_13 = 32;
pub const _SC_SEM_VALUE_MAX: _bindgen_ty_13 = 33;
pub const _SC_SIGQUEUE_MAX: _bindgen_ty_13 = 34;
pub const _SC_TIMER_MAX: _bindgen_ty_13 = 35;
pub const _SC_BC_BASE_MAX: _bindgen_ty_13 = 36;
pub const _SC_BC_DIM_MAX: _bindgen_ty_13 = 37;
pub const _SC_BC_SCALE_MAX: _bindgen_ty_13 = 38;
pub const _SC_BC_STRING_MAX: _bindgen_ty_13 = 39;
pub const _SC_COLL_WEIGHTS_MAX: _bindgen_ty_13 = 40;
pub const _SC_EQUIV_CLASS_MAX: _bindgen_ty_13 = 41;
pub const _SC_EXPR_NEST_MAX: _bindgen_ty_13 = 42;
pub const _SC_LINE_MAX: _bindgen_ty_13 = 43;
pub const _SC_RE_DUP_MAX: _bindgen_ty_13 = 44;
pub const _SC_CHARCLASS_NAME_MAX: _bindgen_ty_13 = 45;
pub const _SC_2_VERSION: _bindgen_ty_13 = 46;
pub const _SC_2_C_BIND: _bindgen_ty_13 = 47;
pub const _SC_2_C_DEV: _bindgen_ty_13 = 48;
pub const _SC_2_FORT_DEV: _bindgen_ty_13 = 49;
pub const _SC_2_FORT_RUN: _bindgen_ty_13 = 50;
pub const _SC_2_SW_DEV: _bindgen_ty_13 = 51;
pub const _SC_2_LOCALEDEF: _bindgen_ty_13 = 52;
pub const _SC_PII: _bindgen_ty_13 = 53;
pub const _SC_PII_XTI: _bindgen_ty_13 = 54;
pub const _SC_PII_SOCKET: _bindgen_ty_13 = 55;
pub const _SC_PII_INTERNET: _bindgen_ty_13 = 56;
pub const _SC_PII_OSI: _bindgen_ty_13 = 57;
pub const _SC_POLL: _bindgen_ty_13 = 58;
pub const _SC_SELECT: _bindgen_ty_13 = 59;
pub const _SC_UIO_MAXIOV: _bindgen_ty_13 = 60;
pub const _SC_IOV_MAX: _bindgen_ty_13 = 60;
pub const _SC_PII_INTERNET_STREAM: _bindgen_ty_13 = 61;
pub const _SC_PII_INTERNET_DGRAM: _bindgen_ty_13 = 62;
pub const _SC_PII_OSI_COTS: _bindgen_ty_13 = 63;
pub const _SC_PII_OSI_CLTS: _bindgen_ty_13 = 64;
pub const _SC_PII_OSI_M: _bindgen_ty_13 = 65;
pub const _SC_T_IOV_MAX: _bindgen_ty_13 = 66;
pub const _SC_THREADS: _bindgen_ty_13 = 67;
pub const _SC_THREAD_SAFE_FUNCTIONS: _bindgen_ty_13 = 68;
pub const _SC_GETGR_R_SIZE_MAX: _bindgen_ty_13 = 69;
pub const _SC_GETPW_R_SIZE_MAX: _bindgen_ty_13 = 70;
pub const _SC_LOGIN_NAME_MAX: _bindgen_ty_13 = 71;
pub const _SC_TTY_NAME_MAX: _bindgen_ty_13 = 72;
pub const _SC_THREAD_DESTRUCTOR_ITERATIONS: _bindgen_ty_13 = 73;
pub const _SC_THREAD_KEYS_MAX: _bindgen_ty_13 = 74;
pub const _SC_THREAD_STACK_MIN: _bindgen_ty_13 = 75;
pub const _SC_THREAD_THREADS_MAX: _bindgen_ty_13 = 76;
pub const _SC_THREAD_ATTR_STACKADDR: _bindgen_ty_13 = 77;
pub const _SC_THREAD_ATTR_STACKSIZE: _bindgen_ty_13 = 78;
pub const _SC_THREAD_PRIORITY_SCHEDULING: _bindgen_ty_13 = 79;
pub const _SC_THREAD_PRIO_INHERIT: _bindgen_ty_13 = 80;
pub const _SC_THREAD_PRIO_PROTECT: _bindgen_ty_13 = 81;
pub const _SC_THREAD_PROCESS_SHARED: _bindgen_ty_13 = 82;
pub const _SC_NPROCESSORS_CONF: _bindgen_ty_13 = 83;
pub const _SC_NPROCESSORS_ONLN: _bindgen_ty_13 = 84;
pub const _SC_PHYS_PAGES: _bindgen_ty_13 = 85;
pub const _SC_AVPHYS_PAGES: _bindgen_ty_13 = 86;
pub const _SC_ATEXIT_MAX: _bindgen_ty_13 = 87;
pub const _SC_PASS_MAX: _bindgen_ty_13 = 88;
pub const _SC_XOPEN_VERSION: _bindgen_ty_13 = 89;
pub const _SC_XOPEN_XCU_VERSION: _bindgen_ty_13 = 90;
pub const _SC_XOPEN_UNIX: _bindgen_ty_13 = 91;
pub const _SC_XOPEN_CRYPT: _bindgen_ty_13 = 92;
pub const _SC_XOPEN_ENH_I18N: _bindgen_ty_13 = 93;
pub const _SC_XOPEN_SHM: _bindgen_ty_13 = 94;
pub const _SC_2_CHAR_TERM: _bindgen_ty_13 = 95;
pub const _SC_2_C_VERSION: _bindgen_ty_13 = 96;
pub const _SC_2_UPE: _bindgen_ty_13 = 97;
pub const _SC_XOPEN_XPG2: _bindgen_ty_13 = 98;
pub const _SC_XOPEN_XPG3: _bindgen_ty_13 = 99;
pub const _SC_XOPEN_XPG4: _bindgen_ty_13 = 100;
pub const _SC_CHAR_BIT: _bindgen_ty_13 = 101;
pub const _SC_CHAR_MAX: _bindgen_ty_13 = 102;
pub const _SC_CHAR_MIN: _bindgen_ty_13 = 103;
pub const _SC_INT_MAX: _bindgen_ty_13 = 104;
pub const _SC_INT_MIN: _bindgen_ty_13 = 105;
pub const _SC_LONG_BIT: _bindgen_ty_13 = 106;
pub const _SC_WORD_BIT: _bindgen_ty_13 = 107;
pub const _SC_MB_LEN_MAX: _bindgen_ty_13 = 108;
pub const _SC_NZERO: _bindgen_ty_13 = 109;
pub const _SC_SSIZE_MAX: _bindgen_ty_13 = 110;
pub const _SC_SCHAR_MAX: _bindgen_ty_13 = 111;
pub const _SC_SCHAR_MIN: _bindgen_ty_13 = 112;
pub const _SC_SHRT_MAX: _bindgen_ty_13 = 113;
pub const _SC_SHRT_MIN: _bindgen_ty_13 = 114;
pub const _SC_UCHAR_MAX: _bindgen_ty_13 = 115;
pub const _SC_UINT_MAX: _bindgen_ty_13 = 116;
pub const _SC_ULONG_MAX: _bindgen_ty_13 = 117;
pub const _SC_USHRT_MAX: _bindgen_ty_13 = 118;
pub const _SC_NL_ARGMAX: _bindgen_ty_13 = 119;
pub const _SC_NL_LANGMAX: _bindgen_ty_13 = 120;
pub const _SC_NL_MSGMAX: _bindgen_ty_13 = 121;
pub const _SC_NL_NMAX: _bindgen_ty_13 = 122;
pub const _SC_NL_SETMAX: _bindgen_ty_13 = 123;
pub const _SC_NL_TEXTMAX: _bindgen_ty_13 = 124;
pub const _SC_XBS5_ILP32_OFF32: _bindgen_ty_13 = 125;
pub const _SC_XBS5_ILP32_OFFBIG: _bindgen_ty_13 = 126;
pub const _SC_XBS5_LP64_OFF64: _bindgen_ty_13 = 127;
pub const _SC_XBS5_LPBIG_OFFBIG: _bindgen_ty_13 = 128;
pub const _SC_XOPEN_LEGACY: _bindgen_ty_13 = 129;
pub const _SC_XOPEN_REALTIME: _bindgen_ty_13 = 130;
pub const _SC_XOPEN_REALTIME_THREADS: _bindgen_ty_13 = 131;
pub const _SC_ADVISORY_INFO: _bindgen_ty_13 = 132;
pub const _SC_BARRIERS: _bindgen_ty_13 = 133;
pub const _SC_BASE: _bindgen_ty_13 = 134;
pub const _SC_C_LANG_SUPPORT: _bindgen_ty_13 = 135;
pub const _SC_C_LANG_SUPPORT_R: _bindgen_ty_13 = 136;
pub const _SC_CLOCK_SELECTION: _bindgen_ty_13 = 137;
pub const _SC_CPUTIME: _bindgen_ty_13 = 138;
pub const _SC_THREAD_CPUTIME: _bindgen_ty_13 = 139;
pub const _SC_DEVICE_IO: _bindgen_ty_13 = 140;
pub const _SC_DEVICE_SPECIFIC: _bindgen_ty_13 = 141;
pub const _SC_DEVICE_SPECIFIC_R: _bindgen_ty_13 = 142;
pub const _SC_FD_MGMT: _bindgen_ty_13 = 143;
pub const _SC_FIFO: _bindgen_ty_13 = 144;
pub const _SC_PIPE: _bindgen_ty_13 = 145;
pub const _SC_FILE_ATTRIBUTES: _bindgen_ty_13 = 146;
pub const _SC_FILE_LOCKING: _bindgen_ty_13 = 147;
pub const _SC_FILE_SYSTEM: _bindgen_ty_13 = 148;
pub const _SC_MONOTONIC_CLOCK: _bindgen_ty_13 = 149;
pub const _SC_MULTI_PROCESS: _bindgen_ty_13 = 150;
pub const _SC_SINGLE_PROCESS: _bindgen_ty_13 = 151;
pub const _SC_NETWORKING: _bindgen_ty_13 = 152;
pub const _SC_READER_WRITER_LOCKS: _bindgen_ty_13 = 153;
pub const _SC_SPIN_LOCKS: _bindgen_ty_13 = 154;
pub const _SC_REGEXP: _bindgen_ty_13 = 155;
pub const _SC_REGEX_VERSION: _bindgen_ty_13 = 156;
pub const _SC_SHELL: _bindgen_ty_13 = 157;
pub const _SC_SIGNALS: _bindgen_ty_13 = 158;
pub const _SC_SPAWN: _bindgen_ty_13 = 159;
pub const _SC_SPORADIC_SERVER: _bindgen_ty_13 = 160;
pub const _SC_THREAD_SPORADIC_SERVER: _bindgen_ty_13 = 161;
pub const _SC_SYSTEM_DATABASE: _bindgen_ty_13 = 162;
pub const _SC_SYSTEM_DATABASE_R: _bindgen_ty_13 = 163;
pub const _SC_TIMEOUTS: _bindgen_ty_13 = 164;
pub const _SC_TYPED_MEMORY_OBJECTS: _bindgen_ty_13 = 165;
pub const _SC_USER_GROUPS: _bindgen_ty_13 = 166;
pub const _SC_USER_GROUPS_R: _bindgen_ty_13 = 167;
pub const _SC_2_PBS: _bindgen_ty_13 = 168;
pub const _SC_2_PBS_ACCOUNTING: _bindgen_ty_13 = 169;
pub const _SC_2_PBS_LOCATE: _bindgen_ty_13 = 170;
pub const _SC_2_PBS_MESSAGE: _bindgen_ty_13 = 171;
pub const _SC_2_PBS_TRACK: _bindgen_ty_13 = 172;
pub const _SC_SYMLOOP_MAX: _bindgen_ty_13 = 173;
pub const _SC_STREAMS: _bindgen_ty_13 = 174;
pub const _SC_2_PBS_CHECKPOINT: _bindgen_ty_13 = 175;
pub const _SC_V6_ILP32_OFF32: _bindgen_ty_13 = 176;
pub const _SC_V6_ILP32_OFFBIG: _bindgen_ty_13 = 177;
pub const _SC_V6_LP64_OFF64: _bindgen_ty_13 = 178;
pub const _SC_V6_LPBIG_OFFBIG: _bindgen_ty_13 = 179;
pub const _SC_HOST_NAME_MAX: _bindgen_ty_13 = 180;
pub const _SC_TRACE: _bindgen_ty_13 = 181;
pub const _SC_TRACE_EVENT_FILTER: _bindgen_ty_13 = 182;
pub const _SC_TRACE_INHERIT: _bindgen_ty_13 = 183;
pub const _SC_TRACE_LOG: _bindgen_ty_13 = 184;
pub const _SC_LEVEL1_ICACHE_SIZE: _bindgen_ty_13 = 185;
pub const _SC_LEVEL1_ICACHE_ASSOC: _bindgen_ty_13 = 186;
pub const _SC_LEVEL1_ICACHE_LINESIZE: _bindgen_ty_13 = 187;
pub const _SC_LEVEL1_DCACHE_SIZE: _bindgen_ty_13 = 188;
pub const _SC_LEVEL1_DCACHE_ASSOC: _bindgen_ty_13 = 189;
pub const _SC_LEVEL1_DCACHE_LINESIZE: _bindgen_ty_13 = 190;
pub const _SC_LEVEL2_CACHE_SIZE: _bindgen_ty_13 = 191;
pub const _SC_LEVEL2_CACHE_ASSOC: _bindgen_ty_13 = 192;
pub const _SC_LEVEL2_CACHE_LINESIZE: _bindgen_ty_13 = 193;
pub const _SC_LEVEL3_CACHE_SIZE: _bindgen_ty_13 = 194;
pub const _SC_LEVEL3_CACHE_ASSOC: _bindgen_ty_13 = 195;
pub const _SC_LEVEL3_CACHE_LINESIZE: _bindgen_ty_13 = 196;
pub const _SC_LEVEL4_CACHE_SIZE: _bindgen_ty_13 = 197;
pub const _SC_LEVEL4_CACHE_ASSOC: _bindgen_ty_13 = 198;
pub const _SC_LEVEL4_CACHE_LINESIZE: _bindgen_ty_13 = 199;
pub const _SC_IPV6: _bindgen_ty_13 = 235;
pub const _SC_RAW_SOCKETS: _bindgen_ty_13 = 236;
pub const _SC_V7_ILP32_OFF32: _bindgen_ty_13 = 237;
pub const _SC_V7_ILP32_OFFBIG: _bindgen_ty_13 = 238;
pub const _SC_V7_LP64_OFF64: _bindgen_ty_13 = 239;
pub const _SC_V7_LPBIG_OFFBIG: _bindgen_ty_13 = 240;
pub const _SC_SS_REPL_MAX: _bindgen_ty_13 = 241;
pub const _SC_TRACE_EVENT_NAME_MAX: _bindgen_ty_13 = 242;
pub const _SC_TRACE_NAME_MAX: _bindgen_ty_13 = 243;
pub const _SC_TRACE_SYS_MAX: _bindgen_ty_13 = 244;
pub const _SC_TRACE_USER_EVENT_MAX: _bindgen_ty_13 = 245;
pub const _SC_XOPEN_STREAMS: _bindgen_ty_13 = 246;
pub const _SC_THREAD_ROBUST_PRIO_INHERIT: _bindgen_ty_13 = 247;
pub const _SC_THREAD_ROBUST_PRIO_PROTECT: _bindgen_ty_13 = 248;
pub const _SC_MINSIGSTKSZ: _bindgen_ty_13 = 249;
pub const _SC_SIGSTKSZ: _bindgen_ty_13 = 250;
pub type _bindgen_ty_13 = ::std::os::raw::c_uint;
pub const _CS_PATH: _bindgen_ty_14 = 0;
pub const _CS_V6_WIDTH_RESTRICTED_ENVS: _bindgen_ty_14 = 1;
pub const _CS_GNU_LIBC_VERSION: _bindgen_ty_14 = 2;
pub const _CS_GNU_LIBPTHREAD_VERSION: _bindgen_ty_14 = 3;
pub const _CS_V5_WIDTH_RESTRICTED_ENVS: _bindgen_ty_14 = 4;
pub const _CS_V7_WIDTH_RESTRICTED_ENVS: _bindgen_ty_14 = 5;
pub const _CS_LFS_CFLAGS: _bindgen_ty_14 = 1000;
pub const _CS_LFS_LDFLAGS: _bindgen_ty_14 = 1001;
pub const _CS_LFS_LIBS: _bindgen_ty_14 = 1002;
pub const _CS_LFS_LINTFLAGS: _bindgen_ty_14 = 1003;
pub const _CS_LFS64_CFLAGS: _bindgen_ty_14 = 1004;
pub const _CS_LFS64_LDFLAGS: _bindgen_ty_14 = 1005;
pub const _CS_LFS64_LIBS: _bindgen_ty_14 = 1006;
pub const _CS_LFS64_LINTFLAGS: _bindgen_ty_14 = 1007;
pub const _CS_XBS5_ILP32_OFF32_CFLAGS: _bindgen_ty_14 = 1100;
pub const _CS_XBS5_ILP32_OFF32_LDFLAGS: _bindgen_ty_14 = 1101;
pub const _CS_XBS5_ILP32_OFF32_LIBS: _bindgen_ty_14 = 1102;
pub const _CS_XBS5_ILP32_OFF32_LINTFLAGS: _bindgen_ty_14 = 1103;
pub const _CS_XBS5_ILP32_OFFBIG_CFLAGS: _bindgen_ty_14 = 1104;
pub const _CS_XBS5_ILP32_OFFBIG_LDFLAGS: _bindgen_ty_14 = 1105;
pub const _CS_XBS5_ILP32_OFFBIG_LIBS: _bindgen_ty_14 = 1106;
pub const _CS_XBS5_ILP32_OFFBIG_LINTFLAGS: _bindgen_ty_14 = 1107;
pub const _CS_XBS5_LP64_OFF64_CFLAGS: _bindgen_ty_14 = 1108;
pub const _CS_XBS5_LP64_OFF64_LDFLAGS: _bindgen_ty_14 = 1109;
pub const _CS_XBS5_LP64_OFF64_LIBS: _bindgen_ty_14 = 1110;
pub const _CS_XBS5_LP64_OFF64_LINTFLAGS: _bindgen_ty_14 = 1111;
pub const _CS_XBS5_LPBIG_OFFBIG_CFLAGS: _bindgen_ty_14 = 1112;
pub const _CS_XBS5_LPBIG_OFFBIG_LDFLAGS: _bindgen_ty_14 = 1113;
pub const _CS_XBS5_LPBIG_OFFBIG_LIBS: _bindgen_ty_14 = 1114;
pub const _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS: _bindgen_ty_14 = 1115;
pub const _CS_POSIX_V6_ILP32_OFF32_CFLAGS: _bindgen_ty_14 = 1116;
pub const _CS_POSIX_V6_ILP32_OFF32_LDFLAGS: _bindgen_ty_14 = 1117;
pub const _CS_POSIX_V6_ILP32_OFF32_LIBS: _bindgen_ty_14 = 1118;
pub const _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS: _bindgen_ty_14 = 1119;
pub const _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS: _bindgen_ty_14 = 1120;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS: _bindgen_ty_14 = 1121;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LIBS: _bindgen_ty_14 = 1122;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS: _bindgen_ty_14 = 1123;
pub const _CS_POSIX_V6_LP64_OFF64_CFLAGS: _bindgen_ty_14 = 1124;
pub const _CS_POSIX_V6_LP64_OFF64_LDFLAGS: _bindgen_ty_14 = 1125;
pub const _CS_POSIX_V6_LP64_OFF64_LIBS: _bindgen_ty_14 = 1126;
pub const _CS_POSIX_V6_LP64_OFF64_LINTFLAGS: _bindgen_ty_14 = 1127;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS: _bindgen_ty_14 = 1128;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS: _bindgen_ty_14 = 1129;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LIBS: _bindgen_ty_14 = 1130;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS: _bindgen_ty_14 = 1131;
pub const _CS_POSIX_V7_ILP32_OFF32_CFLAGS: _bindgen_ty_14 = 1132;
pub const _CS_POSIX_V7_ILP32_OFF32_LDFLAGS: _bindgen_ty_14 = 1133;
pub const _CS_POSIX_V7_ILP32_OFF32_LIBS: _bindgen_ty_14 = 1134;
pub const _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS: _bindgen_ty_14 = 1135;
pub const _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS: _bindgen_ty_14 = 1136;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS: _bindgen_ty_14 = 1137;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LIBS: _bindgen_ty_14 = 1138;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS: _bindgen_ty_14 = 1139;
pub const _CS_POSIX_V7_LP64_OFF64_CFLAGS: _bindgen_ty_14 = 1140;
pub const _CS_POSIX_V7_LP64_OFF64_LDFLAGS: _bindgen_ty_14 = 1141;
pub const _CS_POSIX_V7_LP64_OFF64_LIBS: _bindgen_ty_14 = 1142;
pub const _CS_POSIX_V7_LP64_OFF64_LINTFLAGS: _bindgen_ty_14 = 1143;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS: _bindgen_ty_14 = 1144;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS: _bindgen_ty_14 = 1145;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LIBS: _bindgen_ty_14 = 1146;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS: _bindgen_ty_14 = 1147;
pub const _CS_V6_ENV: _bindgen_ty_14 = 1148;
pub const _CS_V7_ENV: _bindgen_ty_14 = 1149;
pub type _bindgen_ty_14 = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn pathconf(
        __path: *const ::std::os::raw::c_char,
        __name: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn fpathconf(
        __fd: ::std::os::raw::c_int,
        __name: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn sysconf(__name: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn confstr(
        __name: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> usize;
}
unsafe extern "C" {
    pub fn getpid() -> __pid_t;
}
unsafe extern "C" {
    pub fn getppid() -> __pid_t;
}
unsafe extern "C" {
    pub fn getpgrp() -> __pid_t;
}
unsafe extern "C" {
    pub fn __getpgid(__pid: __pid_t) -> __pid_t;
}
unsafe extern "C" {
    pub fn getpgid(__pid: __pid_t) -> __pid_t;
}
unsafe extern "C" {
    pub fn setpgid(__pid: __pid_t, __pgid: __pid_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setpgrp() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setsid() -> __pid_t;
}
unsafe extern "C" {
    pub fn getsid(__pid: __pid_t) -> __pid_t;
}
unsafe extern "C" {
    pub fn getuid() -> __uid_t;
}
unsafe extern "C" {
    pub fn geteuid() -> __uid_t;
}
unsafe extern "C" {
    pub fn getgid() -> __gid_t;
}
unsafe extern "C" {
    pub fn getegid() -> __gid_t;
}
unsafe extern "C" {
    pub fn getgroups(__size: ::std::os::raw::c_int, __list: *mut __gid_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setuid(__uid: __uid_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setreuid(__ruid: __uid_t, __euid: __uid_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn seteuid(__uid: __uid_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setgid(__gid: __gid_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setregid(__rgid: __gid_t, __egid: __gid_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setegid(__gid: __gid_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fork() -> __pid_t;
}
unsafe extern "C" {
    pub fn vfork() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ttyname(__fd: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ttyname_r(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isatty(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ttyslot() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn link(
        __from: *const ::std::os::raw::c_char,
        __to: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn linkat(
        __fromfd: ::std::os::raw::c_int,
        __from: *const ::std::os::raw::c_char,
        __tofd: ::std::os::raw::c_int,
        __to: *const ::std::os::raw::c_char,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn symlink(
        __from: *const ::std::os::raw::c_char,
        __to: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn readlink(
        __path: *const ::std::os::raw::c_char,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> isize;
}
unsafe extern "C" {
    pub fn symlinkat(
        __from: *const ::std::os::raw::c_char,
        __tofd: ::std::os::raw::c_int,
        __to: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn readlinkat(
        __fd: ::std::os::raw::c_int,
        __path: *const ::std::os::raw::c_char,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> isize;
}
unsafe extern "C" {
    pub fn unlink(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn unlinkat(
        __fd: ::std::os::raw::c_int,
        __name: *const ::std::os::raw::c_char,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rmdir(__path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn tcgetpgrp(__fd: ::std::os::raw::c_int) -> __pid_t;
}
unsafe extern "C" {
    pub fn tcsetpgrp(__fd: ::std::os::raw::c_int, __pgrp_id: __pid_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getlogin() -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn getlogin_r(
        __name: *mut ::std::os::raw::c_char,
        __name_len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setlogin(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub static mut optarg: *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub static mut optind: ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub static mut opterr: ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub static mut optopt: ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getopt(
        ___argc: ::std::os::raw::c_int,
        ___argv: *const *mut ::std::os::raw::c_char,
        __shortopts: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn gethostname(__name: *mut ::std::os::raw::c_char, __len: usize) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sethostname(
        __name: *const ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sethostid(__id: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getdomainname(
        __name: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setdomainname(
        __name: *const ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vhangup() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn revoke(__file: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn profil(
        __sample_buffer: *mut ::std::os::raw::c_ushort,
        __size: usize,
        __offset: usize,
        __scale: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn acct(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getusershell() -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn endusershell();
}
unsafe extern "C" {
    pub fn setusershell();
}
unsafe extern "C" {
    pub fn daemon(
        __nochdir: ::std::os::raw::c_int,
        __noclose: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn chroot(__path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getpass(__prompt: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn fsync(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn gethostid() -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn sync();
}
unsafe extern "C" {
    pub fn getpagesize() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getdtablesize() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn truncate(
        __file: *const ::std::os::raw::c_char,
        __length: __off_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ftruncate(__fd: ::std::os::raw::c_int, __length: __off_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn brk(__addr: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sbrk(__delta: isize) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn syscall(__sysno: ::std::os::raw::c_long, ...) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn lockf(
        __fd: ::std::os::raw::c_int,
        __cmd: ::std::os::raw::c_int,
        __len: __off_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fdatasync(__fildes: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn crypt(
        __key: *const ::std::os::raw::c_char,
        __salt: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn getentropy(
        __buffer: *mut ::std::os::raw::c_void,
        __length: usize,
    ) -> ::std::os::raw::c_int;
}
pub type _spa_autoptr_cleanup_type_FILE = *mut _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dirent {
    pub d_ino: __ino_t,
    pub d_off: __off_t,
    pub d_reclen: ::std::os::raw::c_ushort,
    pub d_type: ::std::os::raw::c_uchar,
    pub d_name: [::std::os::raw::c_char; 256usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of dirent"][::std::mem::size_of::<dirent>() - 280usize];
    ["Alignment of dirent"][::std::mem::align_of::<dirent>() - 8usize];
    ["Offset of field: dirent::d_ino"][::std::mem::offset_of!(dirent, d_ino) - 0usize];
    ["Offset of field: dirent::d_off"][::std::mem::offset_of!(dirent, d_off) - 8usize];
    ["Offset of field: dirent::d_reclen"][::std::mem::offset_of!(dirent, d_reclen) - 16usize];
    ["Offset of field: dirent::d_type"][::std::mem::offset_of!(dirent, d_type) - 18usize];
    ["Offset of field: dirent::d_name"][::std::mem::offset_of!(dirent, d_name) - 19usize];
};
pub const DT_UNKNOWN: _bindgen_ty_15 = 0;
pub const DT_FIFO: _bindgen_ty_15 = 1;
pub const DT_CHR: _bindgen_ty_15 = 2;
pub const DT_DIR: _bindgen_ty_15 = 4;
pub const DT_BLK: _bindgen_ty_15 = 6;
pub const DT_REG: _bindgen_ty_15 = 8;
pub const DT_LNK: _bindgen_ty_15 = 10;
pub const DT_SOCK: _bindgen_ty_15 = 12;
pub const DT_WHT: _bindgen_ty_15 = 14;
pub type _bindgen_ty_15 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __dirstream {
    _unused: [u8; 0],
}
pub type DIR = __dirstream;
unsafe extern "C" {
    pub fn closedir(__dirp: *mut DIR) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn opendir(__name: *const ::std::os::raw::c_char) -> *mut DIR;
}
unsafe extern "C" {
    pub fn fdopendir(__fd: ::std::os::raw::c_int) -> *mut DIR;
}
unsafe extern "C" {
    pub fn readdir(__dirp: *mut DIR) -> *mut dirent;
}
unsafe extern "C" {
    pub fn readdir_r(
        __dirp: *mut DIR,
        __entry: *mut dirent,
        __result: *mut *mut dirent,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rewinddir(__dirp: *mut DIR);
}
unsafe extern "C" {
    pub fn seekdir(__dirp: *mut DIR, __pos: ::std::os::raw::c_long);
}
unsafe extern "C" {
    pub fn telldir(__dirp: *mut DIR) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn dirfd(__dirp: *mut DIR) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn scandir(
        __dir: *const ::std::os::raw::c_char,
        __namelist: *mut *mut *mut dirent,
        __selector: ::std::option::Option<
            unsafe extern "C" fn(arg1: *const dirent) -> ::std::os::raw::c_int,
        >,
        __cmp: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut *const dirent,
                arg2: *mut *const dirent,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn alphasort(__e1: *mut *const dirent, __e2: *mut *const dirent) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getdirentries(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __nbytes: usize,
        __basep: *mut __off_t,
    ) -> __ssize_t;
}
pub type _spa_autoptr_cleanup_type_DIR = *mut __dirstream;
#[doc = " \\addtogroup pw_properties\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_properties {
    #[doc = "< dictionary of key/values"]
    pub dict: spa_dict,
    #[doc = "< extra flags"]
    pub flags: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_properties"][::std::mem::size_of::<pw_properties>() - 24usize];
    ["Alignment of pw_properties"][::std::mem::align_of::<pw_properties>() - 8usize];
    ["Offset of field: pw_properties::dict"][::std::mem::offset_of!(pw_properties, dict) - 0usize];
    ["Offset of field: pw_properties::flags"]
        [::std::mem::offset_of!(pw_properties, flags) - 16usize];
};
unsafe extern "C" {
    pub fn pw_properties_new(key: *const ::std::os::raw::c_char, ...) -> *mut pw_properties;
}
unsafe extern "C" {
    pub fn pw_properties_new_dict(dict: *const spa_dict) -> *mut pw_properties;
}
unsafe extern "C" {
    pub fn pw_properties_new_string(args: *const ::std::os::raw::c_char) -> *mut pw_properties;
}
unsafe extern "C" {
    pub fn pw_properties_new_string_checked(
        args: *const ::std::os::raw::c_char,
        size: usize,
        loc: *mut spa_error_location,
    ) -> *mut pw_properties;
}
unsafe extern "C" {
    pub fn pw_properties_copy(properties: *const pw_properties) -> *mut pw_properties;
}
unsafe extern "C" {
    pub fn pw_properties_update_keys(
        props: *mut pw_properties,
        dict: *const spa_dict,
        keys: *const *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pw_properties_update_ignore(
        props: *mut pw_properties,
        dict: *const spa_dict,
        ignore: *const *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pw_properties_update(
        props: *mut pw_properties,
        dict: *const spa_dict,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pw_properties_update_string(
        props: *mut pw_properties,
        str_: *const ::std::os::raw::c_char,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pw_properties_update_string_checked(
        props: *mut pw_properties,
        str_: *const ::std::os::raw::c_char,
        size: usize,
        loc: *mut spa_error_location,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pw_properties_add(
        oldprops: *mut pw_properties,
        dict: *const spa_dict,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pw_properties_add_keys(
        oldprops: *mut pw_properties,
        dict: *const spa_dict,
        keys: *const *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pw_properties_clear(properties: *mut pw_properties);
}
unsafe extern "C" {
    pub fn pw_properties_free(properties: *mut pw_properties);
}
unsafe extern "C" {
    pub fn pw_properties_set(
        properties: *mut pw_properties,
        key: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pw_properties_setf(
        properties: *mut pw_properties,
        key: *const ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pw_properties_setva(
        properties: *mut pw_properties,
        key: *const ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pw_properties_get(
        properties: *const pw_properties,
        key: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn pw_properties_fetch_uint32(
        properties: *const pw_properties,
        key: *const ::std::os::raw::c_char,
        value: *mut u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pw_properties_fetch_int32(
        properties: *const pw_properties,
        key: *const ::std::os::raw::c_char,
        value: *mut i32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pw_properties_fetch_uint64(
        properties: *const pw_properties,
        key: *const ::std::os::raw::c_char,
        value: *mut u64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pw_properties_fetch_int64(
        properties: *const pw_properties,
        key: *const ::std::os::raw::c_char,
        value: *mut i64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pw_properties_fetch_bool(
        properties: *const pw_properties,
        key: *const ::std::os::raw::c_char,
        value: *mut bool,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pw_properties_iterate(
        properties: *const pw_properties,
        state: *mut *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn pw_properties_serialize_dict(
        f: *mut FILE,
        dict: *const spa_dict,
        flags: u32,
    ) -> ::std::os::raw::c_int;
}
#[doc = " \\}"]
pub type _spa_autoptr_cleanup_type_pw_properties = *mut pw_properties;
unsafe extern "C" {
    #[doc = " Update an existing \\ref pw_core_info with \\a update with reset. When info is NULL,\n a new one will be allocated. Returns NULL on failure."]
    pub fn pw_core_info_update(
        info: *mut pw_core_info,
        update: *const pw_core_info,
    ) -> *mut pw_core_info;
}
unsafe extern "C" {
    #[doc = " Update an existing \\ref pw_core_info with \\a update. When info is NULL, a new one\n will be allocated. Returns NULL on failure"]
    pub fn pw_core_info_merge(
        info: *mut pw_core_info,
        update: *const pw_core_info,
        reset: bool,
    ) -> *mut pw_core_info;
}
unsafe extern "C" {
    #[doc = " Free a \\ref pw_core_info"]
    pub fn pw_core_info_free(info: *mut pw_core_info);
}
#[doc = " \\struct pw_core_events\n  \\brief Core events"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_core_events {
    pub version: u32,
    #[doc = " Notify new core info\n\n This event is emitted when first bound to the core or when the\n hello method is called.\n\n \\param info new core info"]
    pub info: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, info: *const pw_core_info),
    >,
    #[doc = " Emit a done event\n\n The done event is emitted as a result of a sync method with the\n same seq number.\n\n \\param seq the seq number passed to the sync method call"]
    pub done: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            id: u32,
            seq: ::std::os::raw::c_int,
        ),
    >,
    #[doc = " Emit a ping event\n\n The client should reply with a pong reply with the same seq\n number."]
    pub ping: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            id: u32,
            seq: ::std::os::raw::c_int,
        ),
    >,
    #[doc = " Fatal error event\n\n The error event is sent out when a fatal (non-recoverable)\n error has occurred. The id argument is the proxy object where\n the error occurred, most often in response to a request to that\n object. The message is a brief description of the error,\n for (debugging) convenience.\n\n This event is usually also emitted on the proxy object with\n \\a id.\n\n \\param id object where the error occurred\n \\param seq the sequence number that generated the error\n \\param res error code\n \\param message error description"]
    pub error: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            id: u32,
            seq: ::std::os::raw::c_int,
            res: ::std::os::raw::c_int,
            message: *const ::std::os::raw::c_char,
        ),
    >,
    #[doc = " Remove an object ID\n\n This event is used internally by the object ID management\n logic. When a client deletes an object, the server will send\n this event to acknowledge that it has seen the delete request.\n When the client receives this event, it will know that it can\n safely reuse the object ID.\n\n \\param id deleted object ID"]
    pub remove_id:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, id: u32)>,
    #[doc = " Notify an object binding\n\n This event is emitted when a local object ID is bound to a\n global ID. It is emitted before the global becomes visible in the\n registry.\n\n The bound_props event is an enhanced version of this event that\n also contains the extra global properties.\n\n \\param id bound object ID\n \\param global_id the global id bound to"]
    pub bound_id: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, id: u32, global_id: u32),
    >,
    #[doc = " Add memory for a client\n\n Memory is given to a client as \\a fd of a certain\n memory \\a type.\n\n Further references to this fd will be made with the per memory\n unique identifier \\a id.\n\n \\param id the unique id of the memory\n \\param type the memory type, one of enum spa_data_type\n \\param fd the file descriptor\n \\param flags extra flags"]
    pub add_mem: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            id: u32,
            type_: u32,
            fd: ::std::os::raw::c_int,
            flags: u32,
        ),
    >,
    #[doc = " Remove memory for a client\n\n \\param id the memory id to remove"]
    pub remove_mem:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, id: u32)>,
    #[doc = " Notify an object binding\n\n This event is emitted when a local object ID is bound to a\n global ID. It is emitted before the global becomes visible in the\n registry.\n\n This is an enhanced version of the bound_id event.\n\n \\param id bound object ID\n \\param global_id the global id bound to\n \\param props The properties of the new global object.\n\n Since version 4:1"]
    pub bound_props: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            id: u32,
            global_id: u32,
            props: *const spa_dict,
        ),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_core_events"][::std::mem::size_of::<pw_core_events>() - 80usize];
    ["Alignment of pw_core_events"][::std::mem::align_of::<pw_core_events>() - 8usize];
    ["Offset of field: pw_core_events::version"]
        [::std::mem::offset_of!(pw_core_events, version) - 0usize];
    ["Offset of field: pw_core_events::info"]
        [::std::mem::offset_of!(pw_core_events, info) - 8usize];
    ["Offset of field: pw_core_events::done"]
        [::std::mem::offset_of!(pw_core_events, done) - 16usize];
    ["Offset of field: pw_core_events::ping"]
        [::std::mem::offset_of!(pw_core_events, ping) - 24usize];
    ["Offset of field: pw_core_events::error"]
        [::std::mem::offset_of!(pw_core_events, error) - 32usize];
    ["Offset of field: pw_core_events::remove_id"]
        [::std::mem::offset_of!(pw_core_events, remove_id) - 40usize];
    ["Offset of field: pw_core_events::bound_id"]
        [::std::mem::offset_of!(pw_core_events, bound_id) - 48usize];
    ["Offset of field: pw_core_events::add_mem"]
        [::std::mem::offset_of!(pw_core_events, add_mem) - 56usize];
    ["Offset of field: pw_core_events::remove_mem"]
        [::std::mem::offset_of!(pw_core_events, remove_mem) - 64usize];
    ["Offset of field: pw_core_events::bound_props"]
        [::std::mem::offset_of!(pw_core_events, bound_props) - 72usize];
};
#[doc = " \\struct pw_core_methods\n \\brief Core methods\n\n The core global object. This is a singleton object used for\n creating new objects in the remote PipeWire instance. It is\n also used for internal features."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_core_methods {
    pub version: u32,
    pub add_listener: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            listener: *mut spa_hook,
            events: *const pw_core_events,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Start a conversation with the server. This will send\n the core info and will destroy all resources for the client\n (except the core and client resource).\n\n This requires X permissions on the core."]
    pub hello: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            version: u32,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Do server roundtrip\n\n Ask the server to emit the 'done' event with \\a seq.\n\n Since methods are handled in-order and events are delivered\n in-order, this can be used as a barrier to ensure all previous\n methods and the resulting events have been handled.\n\n \\param seq the seq number passed to the done event\n\n This requires X permissions on the core."]
    pub sync: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            id: u32,
            seq: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Reply to a server ping event.\n\n Reply to the server ping event with the same seq.\n\n \\param seq the seq number received in the ping event\n\n This requires X permissions on the core."]
    pub pong: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            id: u32,
            seq: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Fatal error event\n\n The error method is sent out when a fatal (non-recoverable)\n error has occurred. The id argument is the proxy object where\n the error occurred, most often in response to an event on that\n object. The message is a brief description of the error,\n for (debugging) convenience.\n\n This method is usually also emitted on the resource object with\n \\a id.\n\n \\param id resource id where the error occurred\n \\param res error code\n \\param message error description\n\n This requires X permissions on the core."]
    pub error: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            id: u32,
            seq: ::std::os::raw::c_int,
            res: ::std::os::raw::c_int,
            message: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Get the registry object\n\n Create a registry object that allows the client to list and bind\n the global objects available from the PipeWire server\n \\param version the client version\n \\param user_data_size extra size\n\n This requires X permissions on the core."]
    pub get_registry: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            version: u32,
            user_data_size: usize,
        ) -> *mut pw_registry,
    >,
    #[doc = " Create a new object on the PipeWire server from a factory.\n\n \\param factory_name the factory name to use\n \\param type the interface to bind to\n \\param version the version of the interface\n \\param props extra properties\n \\param user_data_size extra size\n\n This requires X permissions on the core."]
    pub create_object: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            factory_name: *const ::std::os::raw::c_char,
            type_: *const ::std::os::raw::c_char,
            version: u32,
            props: *const spa_dict,
            user_data_size: usize,
        ) -> *mut ::std::os::raw::c_void,
    >,
    #[doc = " Destroy an resource\n\n Destroy the server resource for the given proxy.\n\n \\param obj the proxy to destroy\n\n This requires X permissions on the core."]
    pub destroy: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            proxy: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_core_methods"][::std::mem::size_of::<pw_core_methods>() - 72usize];
    ["Alignment of pw_core_methods"][::std::mem::align_of::<pw_core_methods>() - 8usize];
    ["Offset of field: pw_core_methods::version"]
        [::std::mem::offset_of!(pw_core_methods, version) - 0usize];
    ["Offset of field: pw_core_methods::add_listener"]
        [::std::mem::offset_of!(pw_core_methods, add_listener) - 8usize];
    ["Offset of field: pw_core_methods::hello"]
        [::std::mem::offset_of!(pw_core_methods, hello) - 16usize];
    ["Offset of field: pw_core_methods::sync"]
        [::std::mem::offset_of!(pw_core_methods, sync) - 24usize];
    ["Offset of field: pw_core_methods::pong"]
        [::std::mem::offset_of!(pw_core_methods, pong) - 32usize];
    ["Offset of field: pw_core_methods::error"]
        [::std::mem::offset_of!(pw_core_methods, error) - 40usize];
    ["Offset of field: pw_core_methods::get_registry"]
        [::std::mem::offset_of!(pw_core_methods, get_registry) - 48usize];
    ["Offset of field: pw_core_methods::create_object"]
        [::std::mem::offset_of!(pw_core_methods, create_object) - 56usize];
    ["Offset of field: pw_core_methods::destroy"]
        [::std::mem::offset_of!(pw_core_methods, destroy) - 64usize];
};
#[doc = " Registry events"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_registry_events {
    pub version: u32,
    #[doc = " Notify of a new global object\n\n The registry emits this event when a new global object is\n available.\n\n \\param id the global object id\n \\param permissions the permissions of the object\n \\param type the type of the interface\n \\param version the version of the interface\n \\param props extra properties of the global"]
    pub global: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            id: u32,
            permissions: u32,
            type_: *const ::std::os::raw::c_char,
            version: u32,
            props: *const spa_dict,
        ),
    >,
    #[doc = " Notify of a global object removal\n\n Emitted when a global object was removed from the registry.\n If the client has any bindings to the global, it should destroy\n those.\n\n \\param id the id of the global that was removed"]
    pub global_remove:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, id: u32)>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_registry_events"][::std::mem::size_of::<pw_registry_events>() - 24usize];
    ["Alignment of pw_registry_events"][::std::mem::align_of::<pw_registry_events>() - 8usize];
    ["Offset of field: pw_registry_events::version"]
        [::std::mem::offset_of!(pw_registry_events, version) - 0usize];
    ["Offset of field: pw_registry_events::global"]
        [::std::mem::offset_of!(pw_registry_events, global) - 8usize];
    ["Offset of field: pw_registry_events::global_remove"]
        [::std::mem::offset_of!(pw_registry_events, global_remove) - 16usize];
};
#[doc = " Registry methods"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_registry_methods {
    pub version: u32,
    pub add_listener: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            listener: *mut spa_hook,
            events: *const pw_registry_events,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Bind to a global object\n\n Bind to the global object with \\a id and use the client proxy\n with new_id as the proxy. After this call, methods can be\n send to the remote global object and events can be received\n\n \\param id the global id to bind to\n \\param type the interface type to bind to\n \\param version the interface version to use\n \\returns the new object"]
    pub bind: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            id: u32,
            type_: *const ::std::os::raw::c_char,
            version: u32,
            use_data_size: usize,
        ) -> *mut ::std::os::raw::c_void,
    >,
    #[doc = " Attempt to destroy a global object\n\n Try to destroy the global object.\n\n \\param id the global id to destroy. The client needs X permissions\n on the global."]
    pub destroy: ::std::option::Option<
        unsafe extern "C" fn(object: *mut ::std::os::raw::c_void, id: u32) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_registry_methods"][::std::mem::size_of::<pw_registry_methods>() - 32usize];
    ["Alignment of pw_registry_methods"][::std::mem::align_of::<pw_registry_methods>() - 8usize];
    ["Offset of field: pw_registry_methods::version"]
        [::std::mem::offset_of!(pw_registry_methods, version) - 0usize];
    ["Offset of field: pw_registry_methods::add_listener"]
        [::std::mem::offset_of!(pw_registry_methods, add_listener) - 8usize];
    ["Offset of field: pw_registry_methods::bind"]
        [::std::mem::offset_of!(pw_registry_methods, bind) - 16usize];
    ["Offset of field: pw_registry_methods::destroy"]
        [::std::mem::offset_of!(pw_registry_methods, destroy) - 24usize];
};
unsafe extern "C" {
    #[doc = " Connect to a PipeWire instance\n\n \\param context a \\ref pw_context\n \\param properties optional properties, ownership of the properties is\n\ttaken.\n \\param user_data_size extra user data size\n\n \\return a \\ref pw_core on success or NULL with errno set on error. The core\n will have an id of \\ref PW_ID_CORE (0)"]
    pub fn pw_context_connect(
        context: *mut pw_context,
        properties: *mut pw_properties,
        user_data_size: usize,
    ) -> *mut pw_core;
}
unsafe extern "C" {
    #[doc = " Connect to a PipeWire instance on the given socket\n\n \\param context a \\ref pw_context\n \\param fd the connected socket to use, the socket will be closed\n\tautomatically on disconnect or error.\n \\param properties optional properties, ownership of the properties is\n\ttaken.\n \\param user_data_size extra user data size\n\n \\return a \\ref pw_core on success or NULL with errno set on error"]
    pub fn pw_context_connect_fd(
        context: *mut pw_context,
        fd: ::std::os::raw::c_int,
        properties: *mut pw_properties,
        user_data_size: usize,
    ) -> *mut pw_core;
}
unsafe extern "C" {
    #[doc = " Connect to a given PipeWire instance\n\n \\param context a \\ref pw_context to connect to\n \\param properties optional properties, ownership of the properties is\n\ttaken.\n \\param user_data_size extra user data size\n\n \\return a \\ref pw_core on success or NULL with errno set on error"]
    pub fn pw_context_connect_self(
        context: *mut pw_context,
        properties: *mut pw_properties,
        user_data_size: usize,
    ) -> *mut pw_core;
}
unsafe extern "C" {
    #[doc = " Steal the fd of the core connection or < 0 on error. The core\n will be disconnected after this call."]
    pub fn pw_core_steal_fd(core: *mut pw_core) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Pause or resume the core. When the core is paused, no new events\n  will be dispatched until the core is resumed again."]
    pub fn pw_core_set_paused(core: *mut pw_core, paused: bool) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " disconnect and destroy a core"]
    pub fn pw_core_disconnect(core: *mut pw_core) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the user_data. It is of the size specified when this object was\n constructed"]
    pub fn pw_core_get_user_data(core: *mut pw_core) -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_client {
    _unused: [u8; 0],
}
unsafe extern "C" {
    #[doc = " Get the client proxy of the connected core. This will have the id\n of PW_ID_CLIENT (1)"]
    pub fn pw_core_get_client(core: *mut pw_core) -> *mut pw_client;
}
unsafe extern "C" {
    #[doc = " Get the context object used to created this core"]
    pub fn pw_core_get_context(core: *mut pw_core) -> *mut pw_context;
}
unsafe extern "C" {
    #[doc = " Get properties from the core"]
    pub fn pw_core_get_properties(core: *mut pw_core) -> *const pw_properties;
}
unsafe extern "C" {
    #[doc = " Update the core properties. This updates the properties\n of the associated client.\n \\return the number of properties that were updated"]
    pub fn pw_core_update_properties(
        core: *mut pw_core,
        dict: *const spa_dict,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the core mempool object"]
    pub fn pw_core_get_mempool(core: *mut pw_core) -> *mut pw_mempool;
}
unsafe extern "C" {
    #[doc = " Get the proxy with the given id"]
    pub fn pw_core_find_proxy(core: *mut pw_core, id: u32) -> *mut pw_proxy;
}
unsafe extern "C" {
    #[doc = " Export an object into the PipeWire instance associated with core"]
    pub fn pw_core_export(
        core: *mut pw_core,
        type_: *const ::std::os::raw::c_char,
        props: *const spa_dict,
        object: *mut ::std::os::raw::c_void,
        user_data_size: usize,
    ) -> *mut pw_proxy;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of tm"][::std::mem::size_of::<tm>() - 56usize];
    ["Alignment of tm"][::std::mem::align_of::<tm>() - 8usize];
    ["Offset of field: tm::tm_sec"][::std::mem::offset_of!(tm, tm_sec) - 0usize];
    ["Offset of field: tm::tm_min"][::std::mem::offset_of!(tm, tm_min) - 4usize];
    ["Offset of field: tm::tm_hour"][::std::mem::offset_of!(tm, tm_hour) - 8usize];
    ["Offset of field: tm::tm_mday"][::std::mem::offset_of!(tm, tm_mday) - 12usize];
    ["Offset of field: tm::tm_mon"][::std::mem::offset_of!(tm, tm_mon) - 16usize];
    ["Offset of field: tm::tm_year"][::std::mem::offset_of!(tm, tm_year) - 20usize];
    ["Offset of field: tm::tm_wday"][::std::mem::offset_of!(tm, tm_wday) - 24usize];
    ["Offset of field: tm::tm_yday"][::std::mem::offset_of!(tm, tm_yday) - 28usize];
    ["Offset of field: tm::tm_isdst"][::std::mem::offset_of!(tm, tm_isdst) - 32usize];
    ["Offset of field: tm::tm_gmtoff"][::std::mem::offset_of!(tm, tm_gmtoff) - 40usize];
    ["Offset of field: tm::tm_zone"][::std::mem::offset_of!(tm, tm_zone) - 48usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of itimerspec"][::std::mem::size_of::<itimerspec>() - 32usize];
    ["Alignment of itimerspec"][::std::mem::align_of::<itimerspec>() - 8usize];
    ["Offset of field: itimerspec::it_interval"]
        [::std::mem::offset_of!(itimerspec, it_interval) - 0usize];
    ["Offset of field: itimerspec::it_value"]
        [::std::mem::offset_of!(itimerspec, it_value) - 16usize];
};
unsafe extern "C" {
    pub fn clock() -> clock_t;
}
unsafe extern "C" {
    pub fn time(__timer: *mut time_t) -> time_t;
}
unsafe extern "C" {
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
}
unsafe extern "C" {
    pub fn mktime(__tp: *mut tm) -> time_t;
}
unsafe extern "C" {
    pub fn strftime(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: usize,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
    ) -> usize;
}
unsafe extern "C" {
    pub fn strftime_l(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: usize,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
        __loc: locale_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
}
unsafe extern "C" {
    pub fn localtime(__timer: *const time_t) -> *mut tm;
}
unsafe extern "C" {
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
unsafe extern "C" {
    pub fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
unsafe extern "C" {
    pub fn asctime(__tp: *const tm) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ctime(__timer: *const time_t) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn asctime_r(
        __tp: *const tm,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ctime_r(
        __timer: *const time_t,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub static mut __tzname: [*mut ::std::os::raw::c_char; 2usize];
}
unsafe extern "C" {
    pub static mut __daylight: ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub static mut __timezone: ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub static mut tzname: [*mut ::std::os::raw::c_char; 2usize];
}
unsafe extern "C" {
    pub fn tzset();
}
unsafe extern "C" {
    pub static mut daylight: ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub static mut timezone: ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn timegm(__tp: *mut tm) -> time_t;
}
unsafe extern "C" {
    pub fn timelocal(__tp: *mut tm) -> time_t;
}
unsafe extern "C" {
    pub fn dysize(__year: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn nanosleep(
        __requested_time: *const timespec,
        __remaining: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clock_nanosleep(
        __clock_id: clockid_t,
        __flags: ::std::os::raw::c_int,
        __req: *const timespec,
        __rem: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn timer_create(
        __clock_id: clockid_t,
        __evp: *mut sigevent,
        __timerid: *mut timer_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn timer_delete(__timerid: timer_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn timer_settime(
        __timerid: timer_t,
        __flags: ::std::os::raw::c_int,
        __value: *const itimerspec,
        __ovalue: *mut itimerspec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn timer_gettime(__timerid: timer_t, __value: *mut itimerspec) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn timer_getoverrun(__timerid: timer_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn timespec_get(
        __ts: *mut timespec,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_system {
    pub iface: spa_interface,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_system"][::std::mem::size_of::<spa_system>() - 32usize];
    ["Alignment of spa_system"][::std::mem::align_of::<spa_system>() - 8usize];
    ["Offset of field: spa_system::iface"][::std::mem::offset_of!(spa_system, iface) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_poll_event {
    pub events: u32,
    pub data: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_poll_event"][::std::mem::size_of::<spa_poll_event>() - 16usize];
    ["Alignment of spa_poll_event"][::std::mem::align_of::<spa_poll_event>() - 8usize];
    ["Offset of field: spa_poll_event::events"]
        [::std::mem::offset_of!(spa_poll_event, events) - 0usize];
    ["Offset of field: spa_poll_event::data"]
        [::std::mem::offset_of!(spa_poll_event, data) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_system_methods {
    pub version: u32,
    pub read: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            fd: ::std::os::raw::c_int,
            buf: *mut ::std::os::raw::c_void,
            count: usize,
        ) -> isize,
    >,
    pub write: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            fd: ::std::os::raw::c_int,
            buf: *const ::std::os::raw::c_void,
            count: usize,
        ) -> isize,
    >,
    pub ioctl: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            fd: ::std::os::raw::c_int,
            request: ::std::os::raw::c_ulong,
            ...
        ) -> ::std::os::raw::c_int,
    >,
    pub close: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            fd: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub clock_gettime: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            clockid: ::std::os::raw::c_int,
            value: *mut timespec,
        ) -> ::std::os::raw::c_int,
    >,
    pub clock_getres: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            clockid: ::std::os::raw::c_int,
            res: *mut timespec,
        ) -> ::std::os::raw::c_int,
    >,
    pub pollfd_create: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            flags: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub pollfd_add: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            pfd: ::std::os::raw::c_int,
            fd: ::std::os::raw::c_int,
            events: u32,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub pollfd_mod: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            pfd: ::std::os::raw::c_int,
            fd: ::std::os::raw::c_int,
            events: u32,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub pollfd_del: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            pfd: ::std::os::raw::c_int,
            fd: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub pollfd_wait: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            pfd: ::std::os::raw::c_int,
            ev: *mut spa_poll_event,
            n_ev: ::std::os::raw::c_int,
            timeout: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub timerfd_create: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            clockid: ::std::os::raw::c_int,
            flags: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub timerfd_settime: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            fd: ::std::os::raw::c_int,
            flags: ::std::os::raw::c_int,
            new_value: *const itimerspec,
            old_value: *mut itimerspec,
        ) -> ::std::os::raw::c_int,
    >,
    pub timerfd_gettime: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            fd: ::std::os::raw::c_int,
            curr_value: *mut itimerspec,
        ) -> ::std::os::raw::c_int,
    >,
    pub timerfd_read: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            fd: ::std::os::raw::c_int,
            expirations: *mut u64,
        ) -> ::std::os::raw::c_int,
    >,
    pub eventfd_create: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            flags: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub eventfd_write: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            fd: ::std::os::raw::c_int,
            count: u64,
        ) -> ::std::os::raw::c_int,
    >,
    pub eventfd_read: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            fd: ::std::os::raw::c_int,
            count: *mut u64,
        ) -> ::std::os::raw::c_int,
    >,
    pub signalfd_create: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            signal: ::std::os::raw::c_int,
            flags: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub signalfd_read: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            fd: ::std::os::raw::c_int,
            signal: *mut ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_system_methods"][::std::mem::size_of::<spa_system_methods>() - 168usize];
    ["Alignment of spa_system_methods"][::std::mem::align_of::<spa_system_methods>() - 8usize];
    ["Offset of field: spa_system_methods::version"]
        [::std::mem::offset_of!(spa_system_methods, version) - 0usize];
    ["Offset of field: spa_system_methods::read"]
        [::std::mem::offset_of!(spa_system_methods, read) - 8usize];
    ["Offset of field: spa_system_methods::write"]
        [::std::mem::offset_of!(spa_system_methods, write) - 16usize];
    ["Offset of field: spa_system_methods::ioctl"]
        [::std::mem::offset_of!(spa_system_methods, ioctl) - 24usize];
    ["Offset of field: spa_system_methods::close"]
        [::std::mem::offset_of!(spa_system_methods, close) - 32usize];
    ["Offset of field: spa_system_methods::clock_gettime"]
        [::std::mem::offset_of!(spa_system_methods, clock_gettime) - 40usize];
    ["Offset of field: spa_system_methods::clock_getres"]
        [::std::mem::offset_of!(spa_system_methods, clock_getres) - 48usize];
    ["Offset of field: spa_system_methods::pollfd_create"]
        [::std::mem::offset_of!(spa_system_methods, pollfd_create) - 56usize];
    ["Offset of field: spa_system_methods::pollfd_add"]
        [::std::mem::offset_of!(spa_system_methods, pollfd_add) - 64usize];
    ["Offset of field: spa_system_methods::pollfd_mod"]
        [::std::mem::offset_of!(spa_system_methods, pollfd_mod) - 72usize];
    ["Offset of field: spa_system_methods::pollfd_del"]
        [::std::mem::offset_of!(spa_system_methods, pollfd_del) - 80usize];
    ["Offset of field: spa_system_methods::pollfd_wait"]
        [::std::mem::offset_of!(spa_system_methods, pollfd_wait) - 88usize];
    ["Offset of field: spa_system_methods::timerfd_create"]
        [::std::mem::offset_of!(spa_system_methods, timerfd_create) - 96usize];
    ["Offset of field: spa_system_methods::timerfd_settime"]
        [::std::mem::offset_of!(spa_system_methods, timerfd_settime) - 104usize];
    ["Offset of field: spa_system_methods::timerfd_gettime"]
        [::std::mem::offset_of!(spa_system_methods, timerfd_gettime) - 112usize];
    ["Offset of field: spa_system_methods::timerfd_read"]
        [::std::mem::offset_of!(spa_system_methods, timerfd_read) - 120usize];
    ["Offset of field: spa_system_methods::eventfd_create"]
        [::std::mem::offset_of!(spa_system_methods, eventfd_create) - 128usize];
    ["Offset of field: spa_system_methods::eventfd_write"]
        [::std::mem::offset_of!(spa_system_methods, eventfd_write) - 136usize];
    ["Offset of field: spa_system_methods::eventfd_read"]
        [::std::mem::offset_of!(spa_system_methods, eventfd_read) - 144usize];
    ["Offset of field: spa_system_methods::signalfd_create"]
        [::std::mem::offset_of!(spa_system_methods, signalfd_create) - 152usize];
    ["Offset of field: spa_system_methods::signalfd_read"]
        [::std::mem::offset_of!(spa_system_methods, signalfd_read) - 160usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_loop {
    pub iface: spa_interface,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_loop"][::std::mem::size_of::<spa_loop>() - 32usize];
    ["Alignment of spa_loop"][::std::mem::align_of::<spa_loop>() - 8usize];
    ["Offset of field: spa_loop::iface"][::std::mem::offset_of!(spa_loop, iface) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_loop_control {
    pub iface: spa_interface,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_loop_control"][::std::mem::size_of::<spa_loop_control>() - 32usize];
    ["Alignment of spa_loop_control"][::std::mem::align_of::<spa_loop_control>() - 8usize];
    ["Offset of field: spa_loop_control::iface"]
        [::std::mem::offset_of!(spa_loop_control, iface) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_loop_utils {
    pub iface: spa_interface,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_loop_utils"][::std::mem::size_of::<spa_loop_utils>() - 32usize];
    ["Alignment of spa_loop_utils"][::std::mem::align_of::<spa_loop_utils>() - 8usize];
    ["Offset of field: spa_loop_utils::iface"]
        [::std::mem::offset_of!(spa_loop_utils, iface) - 0usize];
};
pub type spa_source_func_t = ::std::option::Option<unsafe extern "C" fn(source: *mut spa_source)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_source {
    pub loop_: *mut spa_loop,
    pub func: spa_source_func_t,
    pub data: *mut ::std::os::raw::c_void,
    pub fd: ::std::os::raw::c_int,
    pub mask: u32,
    pub rmask: u32,
    pub priv_: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_source"][::std::mem::size_of::<spa_source>() - 48usize];
    ["Alignment of spa_source"][::std::mem::align_of::<spa_source>() - 8usize];
    ["Offset of field: spa_source::loop_"][::std::mem::offset_of!(spa_source, loop_) - 0usize];
    ["Offset of field: spa_source::func"][::std::mem::offset_of!(spa_source, func) - 8usize];
    ["Offset of field: spa_source::data"][::std::mem::offset_of!(spa_source, data) - 16usize];
    ["Offset of field: spa_source::fd"][::std::mem::offset_of!(spa_source, fd) - 24usize];
    ["Offset of field: spa_source::mask"][::std::mem::offset_of!(spa_source, mask) - 28usize];
    ["Offset of field: spa_source::rmask"][::std::mem::offset_of!(spa_source, rmask) - 32usize];
    ["Offset of field: spa_source::priv_"][::std::mem::offset_of!(spa_source, priv_) - 40usize];
};
pub type spa_invoke_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        loop_: *mut spa_loop,
        async_: bool,
        seq: u32,
        data: *const ::std::os::raw::c_void,
        size: usize,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Register sources and work items to an event loop"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_loop_methods {
    pub version: u32,
    #[doc = " Add a source to the loop. Must be called from the loop's own thread.\n\n \\param[in] object The callbacks data.\n \\param[in] source The source.\n \\return 0 on success, negative errno-style value on failure."]
    pub add_source: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            source: *mut spa_source,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Update the source io mask. Must be called from the loop's own thread.\n\n \\param[in] object The callbacks data.\n \\param[in] source The source.\n \\return 0 on success, negative errno-style value on failure."]
    pub update_source: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            source: *mut spa_source,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Remove a source from the loop. Must be called from the loop's own thread.\n\n \\param[in] object The callbacks data.\n \\param[in] source The source.\n \\return 0 on success, negative errno-style value on failure."]
    pub remove_source: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            source: *mut spa_source,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Invoke a function in the context of this loop.\n May be called from any thread and multiple threads at the same time.\n If called from the loop's thread, all callbacks previously queued with\n invoke() will be run synchronously, which might cause unexpected\n reentrancy problems.\n\n \\param[in] object The callbacks data.\n \\param func The function to be invoked.\n \\param seq An opaque sequence number. This will be made\n            available to func.\n \\param[in] data Data that will be copied into the internal ring buffer and made\n             available to func. Because this data is copied, it is okay to\n             pass a pointer to a local variable, but do not pass a pointer to\n             an object that has identity.\n \\param size The size of data to copy.\n \\param block If \\true, do not return until func has been called. Otherwise,\n              returns immediately. Passing \\true does not risk a deadlock because\n              the data thread is never allowed to wait on any other thread.\n \\param user_data An opaque pointer passed to func.\n \\return `-EPIPE` if the internal ring buffer filled up,\n         if block is \\false, 0 if seq was SPA_ID_INVALID or\n         seq with the ASYNC flag set\n         or the return value of func otherwise."]
    pub invoke: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            func: spa_invoke_func_t,
            seq: u32,
            data: *const ::std::os::raw::c_void,
            size: usize,
            block: bool,
            user_data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_loop_methods"][::std::mem::size_of::<spa_loop_methods>() - 40usize];
    ["Alignment of spa_loop_methods"][::std::mem::align_of::<spa_loop_methods>() - 8usize];
    ["Offset of field: spa_loop_methods::version"]
        [::std::mem::offset_of!(spa_loop_methods, version) - 0usize];
    ["Offset of field: spa_loop_methods::add_source"]
        [::std::mem::offset_of!(spa_loop_methods, add_source) - 8usize];
    ["Offset of field: spa_loop_methods::update_source"]
        [::std::mem::offset_of!(spa_loop_methods, update_source) - 16usize];
    ["Offset of field: spa_loop_methods::remove_source"]
        [::std::mem::offset_of!(spa_loop_methods, remove_source) - 24usize];
    ["Offset of field: spa_loop_methods::invoke"]
        [::std::mem::offset_of!(spa_loop_methods, invoke) - 32usize];
};
#[doc = " Control hooks. These hooks can't be removed from their\n  callbacks and must be removed from a safe place (when the loop\n  is not running or when it is locked)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_loop_control_hooks {
    pub version: u32,
    #[doc = " Executed right before waiting for events. It is typically used to\n release locks."]
    pub before: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " Executed right after waiting for events. It is typically used to\n reacquire locks."]
    pub after: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_loop_control_hooks"][::std::mem::size_of::<spa_loop_control_hooks>() - 24usize];
    ["Alignment of spa_loop_control_hooks"]
        [::std::mem::align_of::<spa_loop_control_hooks>() - 8usize];
    ["Offset of field: spa_loop_control_hooks::version"]
        [::std::mem::offset_of!(spa_loop_control_hooks, version) - 0usize];
    ["Offset of field: spa_loop_control_hooks::before"]
        [::std::mem::offset_of!(spa_loop_control_hooks, before) - 8usize];
    ["Offset of field: spa_loop_control_hooks::after"]
        [::std::mem::offset_of!(spa_loop_control_hooks, after) - 16usize];
};
#[doc = " Control an event loop\n\n The event loop control function provide API to run the event loop.\n\n The below (pseudo)code is a minimal example outlining the use of the loop\n control:\n \\code{.c}\n spa_loop_control_enter(loop);\n while (running) {\n   spa_loop_control_iterate(loop, -1);\n }\n spa_loop_control_leave(loop);\n \\endcode\n\n It is also possible to add the loop to an existing event loop by using the\n spa_loop_control_get_fd() call. This fd will become readable when activity\n has been detected on the sources in the loop. spa_loop_control_iterate() with\n a 0 timeout should be called to process the pending sources.\n\n spa_loop_control_enter() and spa_loop_control_leave() should be called once\n from the thread that will run the iterate() function."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_loop_control_methods {
    pub version: u32,
    #[doc = " get the loop fd\n \\param object the control to query\n\n Get the fd of this loop control. This fd will be readable when a\n source in the loop has activity. The user should call iterate()\n with a 0 timeout to schedule one iteration of the loop and dispatch\n the sources.\n \\return the fd of the loop"]
    pub get_fd: ::std::option::Option<
        unsafe extern "C" fn(object: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    #[doc = " Add a hook\n \\param object the control to change\n \\param hooks the hooks to add\n\n Adds hooks to the loop controlled by \\a ctrl."]
    pub add_hook: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            hook: *mut spa_hook,
            hooks: *const spa_loop_control_hooks,
            data: *mut ::std::os::raw::c_void,
        ),
    >,
    #[doc = " Enter a loop\n \\param object the control\n\n This function should be called before calling iterate and is\n typically used to capture the thread that this loop will run in.\n It should ideally be called once from the thread that will run\n the loop."]
    pub enter: ::std::option::Option<unsafe extern "C" fn(object: *mut ::std::os::raw::c_void)>,
    #[doc = " Leave a loop\n \\param object the control\n\n It should ideally be called once after calling iterate when the loop\n will no longer be iterated from the thread that called enter()."]
    pub leave: ::std::option::Option<unsafe extern "C" fn(object: *mut ::std::os::raw::c_void)>,
    #[doc = " Perform one iteration of the loop.\n \\param ctrl the control\n \\param timeout an optional timeout in milliseconds.\n\t0 for no timeout, -1 for infinite timeout.\n\n This function will block\n up to \\a timeout milliseconds and then dispatch the fds with activity.\n The number of dispatched fds is returned."]
    pub iterate: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            timeout: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Check context of the loop\n \\param ctrl the control\n\n This function will check if the current thread is currently the\n one that did the enter call. Since version 1:1.\n\n returns 1 on success, 0 or negative errno value on error."]
    pub check: ::std::option::Option<
        unsafe extern "C" fn(object: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_loop_control_methods"]
        [::std::mem::size_of::<spa_loop_control_methods>() - 56usize];
    ["Alignment of spa_loop_control_methods"]
        [::std::mem::align_of::<spa_loop_control_methods>() - 8usize];
    ["Offset of field: spa_loop_control_methods::version"]
        [::std::mem::offset_of!(spa_loop_control_methods, version) - 0usize];
    ["Offset of field: spa_loop_control_methods::get_fd"]
        [::std::mem::offset_of!(spa_loop_control_methods, get_fd) - 8usize];
    ["Offset of field: spa_loop_control_methods::add_hook"]
        [::std::mem::offset_of!(spa_loop_control_methods, add_hook) - 16usize];
    ["Offset of field: spa_loop_control_methods::enter"]
        [::std::mem::offset_of!(spa_loop_control_methods, enter) - 24usize];
    ["Offset of field: spa_loop_control_methods::leave"]
        [::std::mem::offset_of!(spa_loop_control_methods, leave) - 32usize];
    ["Offset of field: spa_loop_control_methods::iterate"]
        [::std::mem::offset_of!(spa_loop_control_methods, iterate) - 40usize];
    ["Offset of field: spa_loop_control_methods::check"]
        [::std::mem::offset_of!(spa_loop_control_methods, check) - 48usize];
};
pub type spa_source_io_func_t = ::std::option::Option<
    unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, fd: ::std::os::raw::c_int, mask: u32),
>;
pub type spa_source_idle_func_t =
    ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>;
pub type spa_source_event_func_t =
    ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, count: u64)>;
pub type spa_source_timer_func_t = ::std::option::Option<
    unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, expirations: u64),
>;
pub type spa_source_signal_func_t = ::std::option::Option<
    unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, signal_number: ::std::os::raw::c_int),
>;
#[doc = " Create sources for an event loop"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_loop_utils_methods {
    pub version: u32,
    pub add_io: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            fd: ::std::os::raw::c_int,
            mask: u32,
            close: bool,
            func: spa_source_io_func_t,
            data: *mut ::std::os::raw::c_void,
        ) -> *mut spa_source,
    >,
    pub update_io: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            source: *mut spa_source,
            mask: u32,
        ) -> ::std::os::raw::c_int,
    >,
    pub add_idle: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            enabled: bool,
            func: spa_source_idle_func_t,
            data: *mut ::std::os::raw::c_void,
        ) -> *mut spa_source,
    >,
    pub enable_idle: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            source: *mut spa_source,
            enabled: bool,
        ) -> ::std::os::raw::c_int,
    >,
    pub add_event: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            func: spa_source_event_func_t,
            data: *mut ::std::os::raw::c_void,
        ) -> *mut spa_source,
    >,
    pub signal_event: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            source: *mut spa_source,
        ) -> ::std::os::raw::c_int,
    >,
    pub add_timer: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            func: spa_source_timer_func_t,
            data: *mut ::std::os::raw::c_void,
        ) -> *mut spa_source,
    >,
    pub update_timer: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            source: *mut spa_source,
            value: *mut timespec,
            interval: *mut timespec,
            absolute: bool,
        ) -> ::std::os::raw::c_int,
    >,
    pub add_signal: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            signal_number: ::std::os::raw::c_int,
            func: spa_source_signal_func_t,
            data: *mut ::std::os::raw::c_void,
        ) -> *mut spa_source,
    >,
    #[doc = " destroy a source allocated with this interface. This function\n should only be called when the loop is not running or from the\n context of the running loop"]
    pub destroy_source: ::std::option::Option<
        unsafe extern "C" fn(object: *mut ::std::os::raw::c_void, source: *mut spa_source),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_loop_utils_methods"][::std::mem::size_of::<spa_loop_utils_methods>() - 88usize];
    ["Alignment of spa_loop_utils_methods"]
        [::std::mem::align_of::<spa_loop_utils_methods>() - 8usize];
    ["Offset of field: spa_loop_utils_methods::version"]
        [::std::mem::offset_of!(spa_loop_utils_methods, version) - 0usize];
    ["Offset of field: spa_loop_utils_methods::add_io"]
        [::std::mem::offset_of!(spa_loop_utils_methods, add_io) - 8usize];
    ["Offset of field: spa_loop_utils_methods::update_io"]
        [::std::mem::offset_of!(spa_loop_utils_methods, update_io) - 16usize];
    ["Offset of field: spa_loop_utils_methods::add_idle"]
        [::std::mem::offset_of!(spa_loop_utils_methods, add_idle) - 24usize];
    ["Offset of field: spa_loop_utils_methods::enable_idle"]
        [::std::mem::offset_of!(spa_loop_utils_methods, enable_idle) - 32usize];
    ["Offset of field: spa_loop_utils_methods::add_event"]
        [::std::mem::offset_of!(spa_loop_utils_methods, add_event) - 40usize];
    ["Offset of field: spa_loop_utils_methods::signal_event"]
        [::std::mem::offset_of!(spa_loop_utils_methods, signal_event) - 48usize];
    ["Offset of field: spa_loop_utils_methods::add_timer"]
        [::std::mem::offset_of!(spa_loop_utils_methods, add_timer) - 56usize];
    ["Offset of field: spa_loop_utils_methods::update_timer"]
        [::std::mem::offset_of!(spa_loop_utils_methods, update_timer) - 64usize];
    ["Offset of field: spa_loop_utils_methods::add_signal"]
        [::std::mem::offset_of!(spa_loop_utils_methods, add_signal) - 72usize];
    ["Offset of field: spa_loop_utils_methods::destroy_source"]
        [::std::mem::offset_of!(spa_loop_utils_methods, destroy_source) - 80usize];
};
#[doc = " \\addtogroup pw_loop\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_loop {
    #[doc = "< system utils"]
    pub system: *mut spa_system,
    #[doc = "< wrapped loop"]
    pub loop_: *mut spa_loop,
    #[doc = "< loop control"]
    pub control: *mut spa_loop_control,
    #[doc = "< loop utils"]
    pub utils: *mut spa_loop_utils,
    pub name: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_loop"][::std::mem::size_of::<pw_loop>() - 40usize];
    ["Alignment of pw_loop"][::std::mem::align_of::<pw_loop>() - 8usize];
    ["Offset of field: pw_loop::system"][::std::mem::offset_of!(pw_loop, system) - 0usize];
    ["Offset of field: pw_loop::loop_"][::std::mem::offset_of!(pw_loop, loop_) - 8usize];
    ["Offset of field: pw_loop::control"][::std::mem::offset_of!(pw_loop, control) - 16usize];
    ["Offset of field: pw_loop::utils"][::std::mem::offset_of!(pw_loop, utils) - 24usize];
    ["Offset of field: pw_loop::name"][::std::mem::offset_of!(pw_loop, name) - 32usize];
};
unsafe extern "C" {
    pub fn pw_loop_new(props: *const spa_dict) -> *mut pw_loop;
}
unsafe extern "C" {
    pub fn pw_loop_destroy(loop_: *mut pw_loop);
}
unsafe extern "C" {
    pub fn pw_loop_set_name(
        loop_: *mut pw_loop,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
#[doc = " context events emitted by the context object added with \\ref pw_context_add_listener"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_context_events {
    pub version: u32,
    #[doc = " The context is being destroyed"]
    pub destroy: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " The context is being freed"]
    pub free: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " a new client object is added"]
    pub check_access: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, client: *mut pw_impl_client),
    >,
    #[doc = " a new global object was added"]
    pub global_added: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, global: *mut pw_global),
    >,
    #[doc = " a global object was removed"]
    pub global_removed: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, global: *mut pw_global),
    >,
    #[doc = " a driver was added, since 0.3.75 version:1"]
    pub driver_added: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, node: *mut pw_impl_node),
    >,
    #[doc = " a driver was removed, since 0.3.75 version:1"]
    pub driver_removed: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, node: *mut pw_impl_node),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_context_events"][::std::mem::size_of::<pw_context_events>() - 64usize];
    ["Alignment of pw_context_events"][::std::mem::align_of::<pw_context_events>() - 8usize];
    ["Offset of field: pw_context_events::version"]
        [::std::mem::offset_of!(pw_context_events, version) - 0usize];
    ["Offset of field: pw_context_events::destroy"]
        [::std::mem::offset_of!(pw_context_events, destroy) - 8usize];
    ["Offset of field: pw_context_events::free"]
        [::std::mem::offset_of!(pw_context_events, free) - 16usize];
    ["Offset of field: pw_context_events::check_access"]
        [::std::mem::offset_of!(pw_context_events, check_access) - 24usize];
    ["Offset of field: pw_context_events::global_added"]
        [::std::mem::offset_of!(pw_context_events, global_added) - 32usize];
    ["Offset of field: pw_context_events::global_removed"]
        [::std::mem::offset_of!(pw_context_events, global_removed) - 40usize];
    ["Offset of field: pw_context_events::driver_added"]
        [::std::mem::offset_of!(pw_context_events, driver_added) - 48usize];
    ["Offset of field: pw_context_events::driver_removed"]
        [::std::mem::offset_of!(pw_context_events, driver_removed) - 56usize];
};
unsafe extern "C" {
    #[doc = " Make a new context object for a given main_loop. Ownership of the properties is taken, even\n if the function returns NULL.\n\n \\param main_loop A main loop to run in. This must stay alive unil pw_context_destroy() is called.\n \\param props extra properties\n \\param user_data_size extra user data size\n \\return The context object on success, or NULL on failure, in which case errno is set."]
    pub fn pw_context_new(
        main_loop: *mut pw_loop,
        props: *mut pw_properties,
        user_data_size: usize,
    ) -> *mut pw_context;
}
unsafe extern "C" {
    #[doc = " destroy a context object, all resources except the main_loop will be destroyed"]
    pub fn pw_context_destroy(context: *mut pw_context);
}
unsafe extern "C" {
    #[doc = " Get the context user data"]
    pub fn pw_context_get_user_data(context: *mut pw_context) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " Add a new event listener to a context"]
    pub fn pw_context_add_listener(
        context: *mut pw_context,
        listener: *mut spa_hook,
        events: *const pw_context_events,
        data: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = " Get the context properties"]
    pub fn pw_context_get_properties(context: *mut pw_context) -> *const pw_properties;
}
unsafe extern "C" {
    #[doc = " Update the context properties"]
    pub fn pw_context_update_properties(
        context: *mut pw_context,
        dict: *const spa_dict,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get a config section for this context. Since 0.3.22, deprecated,\n use pw_context_conf_section_for_each()."]
    pub fn pw_context_get_conf_section(
        context: *mut pw_context,
        section: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Parse a standard config section for this context. Since 0.3.22"]
    pub fn pw_context_parse_conf_section(
        context: *mut pw_context,
        conf: *mut pw_properties,
        section: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " update properties from a section into props. Since 0.3.45"]
    pub fn pw_context_conf_update_props(
        context: *mut pw_context,
        section: *const ::std::os::raw::c_char,
        props: *mut pw_properties,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " emit callback for all config sections. Since 0.3.45"]
    pub fn pw_context_conf_section_for_each(
        context: *mut pw_context,
        section: *const ::std::os::raw::c_char,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                data: *mut ::std::os::raw::c_void,
                location: *const ::std::os::raw::c_char,
                section: *const ::std::os::raw::c_char,
                str_: *const ::std::os::raw::c_char,
                len: usize,
            ) -> ::std::os::raw::c_int,
        >,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " emit callback for all matched properties. Since 0.3.46"]
    pub fn pw_context_conf_section_match_rules(
        context: *mut pw_context,
        section: *const ::std::os::raw::c_char,
        props: *const spa_dict,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                data: *mut ::std::os::raw::c_void,
                location: *const ::std::os::raw::c_char,
                action: *const ::std::os::raw::c_char,
                str_: *const ::std::os::raw::c_char,
                len: usize,
            ) -> ::std::os::raw::c_int,
        >,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the context support objects"]
    pub fn pw_context_get_support(
        context: *mut pw_context,
        n_support: *mut u32,
    ) -> *const spa_support;
}
unsafe extern "C" {
    #[doc = " Get the context main loop. Returns the value passed to pw_context_new()."]
    pub fn pw_context_get_main_loop(context: *mut pw_context) -> *mut pw_loop;
}
#[doc = " \\addtogroup pw_data_loop\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_data_loop {
    _unused: [u8; 0],
}
unsafe extern "C" {
    #[doc = " Get the context data loop. This loop runs on the realtime thread. This\n acquires a loop from the generic data.rt class. Use pw_context_acquire_loop() instead.\n Since 0.3.56"]
    pub fn pw_context_get_data_loop(context: *mut pw_context) -> *mut pw_data_loop;
}
unsafe extern "C" {
    #[doc = " Get a data-loop.\n Since 1.1.0"]
    pub fn pw_context_acquire_loop(
        context: *mut pw_context,
        props: *const spa_dict,
    ) -> *mut pw_loop;
}
unsafe extern "C" {
    #[doc = " Release a data-loop.\n Since 1.1.0"]
    pub fn pw_context_release_loop(context: *mut pw_context, loop_: *mut pw_loop);
}
#[doc = " \\addtogroup pw_work_queue\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_work_queue {
    _unused: [u8; 0],
}
unsafe extern "C" {
    #[doc = " Get the work queue from the context: Since 0.3.26"]
    pub fn pw_context_get_work_queue(context: *mut pw_context) -> *mut pw_work_queue;
}
unsafe extern "C" {
    #[doc = " Get the memory pool from the context: Since 0.3.74"]
    pub fn pw_context_get_mempool(context: *mut pw_context) -> *mut pw_mempool;
}
unsafe extern "C" {
    #[doc = " Iterate the globals of the context. The callback should return\n 0 to fetch the next item, any other value stops the iteration and returns\n the value. When all callbacks return 0, this function returns 0 when all\n globals are iterated."]
    pub fn pw_context_for_each_global(
        context: *mut pw_context,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                data: *mut ::std::os::raw::c_void,
                global: *mut pw_global,
            ) -> ::std::os::raw::c_int,
        >,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Find a context global by id.\n\n \\return The global on success, or NULL on failure. If id is \\ref PW_ID_CORE,\n         this function will always return a non-NULL value."]
    pub fn pw_context_find_global(context: *mut pw_context, id: u32) -> *mut pw_global;
}
unsafe extern "C" {
    #[doc = " add a spa library for the given factory_name regex"]
    pub fn pw_context_add_spa_lib(
        context: *mut pw_context,
        factory_regex: *const ::std::os::raw::c_char,
        lib: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " find the library name for a spa factory"]
    pub fn pw_context_find_spa_lib(
        context: *mut pw_context,
        factory_name: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Load a SPA handle from a context. On failure returns NULL and sets errno."]
    pub fn pw_context_load_spa_handle(
        context: *mut pw_context,
        factory_name: *const ::std::os::raw::c_char,
        info: *const spa_dict,
    ) -> *mut spa_handle;
}
#[doc = " data for registering export functions"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_export_type {
    pub link: spa_list,
    pub type_: *const ::std::os::raw::c_char,
    pub func: ::std::option::Option<
        unsafe extern "C" fn(
            core: *mut pw_core,
            type_: *const ::std::os::raw::c_char,
            props: *const spa_dict,
            object: *mut ::std::os::raw::c_void,
            user_data_size: usize,
        ) -> *mut pw_proxy,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_export_type"][::std::mem::size_of::<pw_export_type>() - 32usize];
    ["Alignment of pw_export_type"][::std::mem::align_of::<pw_export_type>() - 8usize];
    ["Offset of field: pw_export_type::link"]
        [::std::mem::offset_of!(pw_export_type, link) - 0usize];
    ["Offset of field: pw_export_type::type_"]
        [::std::mem::offset_of!(pw_export_type, type_) - 16usize];
    ["Offset of field: pw_export_type::func"]
        [::std::mem::offset_of!(pw_export_type, func) - 24usize];
};
unsafe extern "C" {
    #[doc = " register a type that can be exported on a context_proxy. This is usually used by\n extension modules"]
    pub fn pw_context_register_export_type(
        context: *mut pw_context,
        type_: *mut pw_export_type,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " find information about registered export type"]
    pub fn pw_context_find_export_type(
        context: *mut pw_context,
        type_: *const ::std::os::raw::c_char,
    ) -> *const pw_export_type;
}
unsafe extern "C" {
    #[doc = " add an object to the context\n\n \\param context The context.\n \\param type The type of the object, usually a `TYPE_INTERFACE_` value.\n \\param value The object value. Must last as long as the context and must\n              be of the type corresponding to the type.\n \\return A negative number on failure (out of memory)."]
    pub fn pw_context_set_object(
        context: *mut pw_context,
        type_: *const ::std::os::raw::c_char,
        value: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " get an object from the context\n\n \\param context The context.\n \\param type The string corresponding to the object's interface.\n \\return The object, or NULL if the object does not exist."]
    pub fn pw_context_get_object(
        context: *mut pw_context,
        type_: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
pub type sa_family_t = ::std::os::raw::c_ushort;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_un {
    pub sun_family: sa_family_t,
    pub sun_path: [::std::os::raw::c_char; 108usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sockaddr_un"][::std::mem::size_of::<sockaddr_un>() - 110usize];
    ["Alignment of sockaddr_un"][::std::mem::align_of::<sockaddr_un>() - 2usize];
    ["Offset of field: sockaddr_un::sun_family"]
        [::std::mem::offset_of!(sockaddr_un, sun_family) - 0usize];
    ["Offset of field: sockaddr_un::sun_path"]
        [::std::mem::offset_of!(sockaddr_un, sun_path) - 2usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_pod {
    pub size: u32,
    pub type_: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod"][::std::mem::size_of::<spa_pod>() - 8usize];
    ["Alignment of spa_pod"][::std::mem::align_of::<spa_pod>() - 4usize];
    ["Offset of field: spa_pod::size"][::std::mem::offset_of!(spa_pod, size) - 0usize];
    ["Offset of field: spa_pod::type_"][::std::mem::offset_of!(spa_pod, type_) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_pod_bool {
    pub pod: spa_pod,
    pub value: i32,
    pub _padding: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_bool"][::std::mem::size_of::<spa_pod_bool>() - 16usize];
    ["Alignment of spa_pod_bool"][::std::mem::align_of::<spa_pod_bool>() - 4usize];
    ["Offset of field: spa_pod_bool::pod"][::std::mem::offset_of!(spa_pod_bool, pod) - 0usize];
    ["Offset of field: spa_pod_bool::value"][::std::mem::offset_of!(spa_pod_bool, value) - 8usize];
    ["Offset of field: spa_pod_bool::_padding"]
        [::std::mem::offset_of!(spa_pod_bool, _padding) - 12usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_pod_id {
    pub pod: spa_pod,
    pub value: u32,
    pub _padding: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_id"][::std::mem::size_of::<spa_pod_id>() - 16usize];
    ["Alignment of spa_pod_id"][::std::mem::align_of::<spa_pod_id>() - 4usize];
    ["Offset of field: spa_pod_id::pod"][::std::mem::offset_of!(spa_pod_id, pod) - 0usize];
    ["Offset of field: spa_pod_id::value"][::std::mem::offset_of!(spa_pod_id, value) - 8usize];
    ["Offset of field: spa_pod_id::_padding"]
        [::std::mem::offset_of!(spa_pod_id, _padding) - 12usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_pod_int {
    pub pod: spa_pod,
    pub value: i32,
    pub _padding: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_int"][::std::mem::size_of::<spa_pod_int>() - 16usize];
    ["Alignment of spa_pod_int"][::std::mem::align_of::<spa_pod_int>() - 4usize];
    ["Offset of field: spa_pod_int::pod"][::std::mem::offset_of!(spa_pod_int, pod) - 0usize];
    ["Offset of field: spa_pod_int::value"][::std::mem::offset_of!(spa_pod_int, value) - 8usize];
    ["Offset of field: spa_pod_int::_padding"]
        [::std::mem::offset_of!(spa_pod_int, _padding) - 12usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_pod_long {
    pub pod: spa_pod,
    pub value: i64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_long"][::std::mem::size_of::<spa_pod_long>() - 16usize];
    ["Alignment of spa_pod_long"][::std::mem::align_of::<spa_pod_long>() - 8usize];
    ["Offset of field: spa_pod_long::pod"][::std::mem::offset_of!(spa_pod_long, pod) - 0usize];
    ["Offset of field: spa_pod_long::value"][::std::mem::offset_of!(spa_pod_long, value) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_pod_float {
    pub pod: spa_pod,
    pub value: f32,
    pub _padding: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_float"][::std::mem::size_of::<spa_pod_float>() - 16usize];
    ["Alignment of spa_pod_float"][::std::mem::align_of::<spa_pod_float>() - 4usize];
    ["Offset of field: spa_pod_float::pod"][::std::mem::offset_of!(spa_pod_float, pod) - 0usize];
    ["Offset of field: spa_pod_float::value"]
        [::std::mem::offset_of!(spa_pod_float, value) - 8usize];
    ["Offset of field: spa_pod_float::_padding"]
        [::std::mem::offset_of!(spa_pod_float, _padding) - 12usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_pod_double {
    pub pod: spa_pod,
    pub value: f64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_double"][::std::mem::size_of::<spa_pod_double>() - 16usize];
    ["Alignment of spa_pod_double"][::std::mem::align_of::<spa_pod_double>() - 8usize];
    ["Offset of field: spa_pod_double::pod"][::std::mem::offset_of!(spa_pod_double, pod) - 0usize];
    ["Offset of field: spa_pod_double::value"]
        [::std::mem::offset_of!(spa_pod_double, value) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_pod_string {
    pub pod: spa_pod,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_string"][::std::mem::size_of::<spa_pod_string>() - 8usize];
    ["Alignment of spa_pod_string"][::std::mem::align_of::<spa_pod_string>() - 4usize];
    ["Offset of field: spa_pod_string::pod"][::std::mem::offset_of!(spa_pod_string, pod) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_pod_bytes {
    pub pod: spa_pod,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_bytes"][::std::mem::size_of::<spa_pod_bytes>() - 8usize];
    ["Alignment of spa_pod_bytes"][::std::mem::align_of::<spa_pod_bytes>() - 4usize];
    ["Offset of field: spa_pod_bytes::pod"][::std::mem::offset_of!(spa_pod_bytes, pod) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_pod_rectangle {
    pub pod: spa_pod,
    pub value: spa_rectangle,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_rectangle"][::std::mem::size_of::<spa_pod_rectangle>() - 16usize];
    ["Alignment of spa_pod_rectangle"][::std::mem::align_of::<spa_pod_rectangle>() - 4usize];
    ["Offset of field: spa_pod_rectangle::pod"]
        [::std::mem::offset_of!(spa_pod_rectangle, pod) - 0usize];
    ["Offset of field: spa_pod_rectangle::value"]
        [::std::mem::offset_of!(spa_pod_rectangle, value) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_pod_fraction {
    pub pod: spa_pod,
    pub value: spa_fraction,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_fraction"][::std::mem::size_of::<spa_pod_fraction>() - 16usize];
    ["Alignment of spa_pod_fraction"][::std::mem::align_of::<spa_pod_fraction>() - 4usize];
    ["Offset of field: spa_pod_fraction::pod"]
        [::std::mem::offset_of!(spa_pod_fraction, pod) - 0usize];
    ["Offset of field: spa_pod_fraction::value"]
        [::std::mem::offset_of!(spa_pod_fraction, value) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_pod_bitmap {
    pub pod: spa_pod,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_bitmap"][::std::mem::size_of::<spa_pod_bitmap>() - 8usize];
    ["Alignment of spa_pod_bitmap"][::std::mem::align_of::<spa_pod_bitmap>() - 4usize];
    ["Offset of field: spa_pod_bitmap::pod"][::std::mem::offset_of!(spa_pod_bitmap, pod) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_pod_array_body {
    pub child: spa_pod,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_array_body"][::std::mem::size_of::<spa_pod_array_body>() - 8usize];
    ["Alignment of spa_pod_array_body"][::std::mem::align_of::<spa_pod_array_body>() - 4usize];
    ["Offset of field: spa_pod_array_body::child"]
        [::std::mem::offset_of!(spa_pod_array_body, child) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_pod_array {
    pub pod: spa_pod,
    pub body: spa_pod_array_body,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_array"][::std::mem::size_of::<spa_pod_array>() - 16usize];
    ["Alignment of spa_pod_array"][::std::mem::align_of::<spa_pod_array>() - 4usize];
    ["Offset of field: spa_pod_array::pod"][::std::mem::offset_of!(spa_pod_array, pod) - 0usize];
    ["Offset of field: spa_pod_array::body"][::std::mem::offset_of!(spa_pod_array, body) - 8usize];
};
#[doc = "< no choice, first value is current"]
pub const spa_choice_type_SPA_CHOICE_None: spa_choice_type = 0;
#[doc = "< range: default, min, max"]
pub const spa_choice_type_SPA_CHOICE_Range: spa_choice_type = 1;
#[doc = "< range with step: default, min, max, step"]
pub const spa_choice_type_SPA_CHOICE_Step: spa_choice_type = 2;
#[doc = "< list: default, alternative,..."]
pub const spa_choice_type_SPA_CHOICE_Enum: spa_choice_type = 3;
#[doc = "< flags: default, possible flags,..."]
pub const spa_choice_type_SPA_CHOICE_Flags: spa_choice_type = 4;
pub type spa_choice_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_pod_choice_body {
    #[doc = "< type of choice, one of enum spa_choice_type"]
    pub type_: u32,
    #[doc = "< extra flags"]
    pub flags: u32,
    pub child: spa_pod,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_choice_body"][::std::mem::size_of::<spa_pod_choice_body>() - 16usize];
    ["Alignment of spa_pod_choice_body"][::std::mem::align_of::<spa_pod_choice_body>() - 4usize];
    ["Offset of field: spa_pod_choice_body::type_"]
        [::std::mem::offset_of!(spa_pod_choice_body, type_) - 0usize];
    ["Offset of field: spa_pod_choice_body::flags"]
        [::std::mem::offset_of!(spa_pod_choice_body, flags) - 4usize];
    ["Offset of field: spa_pod_choice_body::child"]
        [::std::mem::offset_of!(spa_pod_choice_body, child) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_pod_choice {
    pub pod: spa_pod,
    pub body: spa_pod_choice_body,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_choice"][::std::mem::size_of::<spa_pod_choice>() - 24usize];
    ["Alignment of spa_pod_choice"][::std::mem::align_of::<spa_pod_choice>() - 4usize];
    ["Offset of field: spa_pod_choice::pod"][::std::mem::offset_of!(spa_pod_choice, pod) - 0usize];
    ["Offset of field: spa_pod_choice::body"]
        [::std::mem::offset_of!(spa_pod_choice, body) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_pod_struct {
    pub pod: spa_pod,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_struct"][::std::mem::size_of::<spa_pod_struct>() - 8usize];
    ["Alignment of spa_pod_struct"][::std::mem::align_of::<spa_pod_struct>() - 4usize];
    ["Offset of field: spa_pod_struct::pod"][::std::mem::offset_of!(spa_pod_struct, pod) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_pod_object_body {
    #[doc = "< one of enum spa_type"]
    pub type_: u32,
    #[doc = "< id of the object, depends on the object type"]
    pub id: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_object_body"][::std::mem::size_of::<spa_pod_object_body>() - 8usize];
    ["Alignment of spa_pod_object_body"][::std::mem::align_of::<spa_pod_object_body>() - 4usize];
    ["Offset of field: spa_pod_object_body::type_"]
        [::std::mem::offset_of!(spa_pod_object_body, type_) - 0usize];
    ["Offset of field: spa_pod_object_body::id"]
        [::std::mem::offset_of!(spa_pod_object_body, id) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_pod_object {
    pub pod: spa_pod,
    pub body: spa_pod_object_body,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_object"][::std::mem::size_of::<spa_pod_object>() - 16usize];
    ["Alignment of spa_pod_object"][::std::mem::align_of::<spa_pod_object>() - 4usize];
    ["Offset of field: spa_pod_object::pod"][::std::mem::offset_of!(spa_pod_object, pod) - 0usize];
    ["Offset of field: spa_pod_object::body"]
        [::std::mem::offset_of!(spa_pod_object, body) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_pod_pointer_body {
    #[doc = "< pointer id, one of enum spa_type"]
    pub type_: u32,
    pub _padding: u32,
    pub value: *const ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_pointer_body"][::std::mem::size_of::<spa_pod_pointer_body>() - 16usize];
    ["Alignment of spa_pod_pointer_body"][::std::mem::align_of::<spa_pod_pointer_body>() - 8usize];
    ["Offset of field: spa_pod_pointer_body::type_"]
        [::std::mem::offset_of!(spa_pod_pointer_body, type_) - 0usize];
    ["Offset of field: spa_pod_pointer_body::_padding"]
        [::std::mem::offset_of!(spa_pod_pointer_body, _padding) - 4usize];
    ["Offset of field: spa_pod_pointer_body::value"]
        [::std::mem::offset_of!(spa_pod_pointer_body, value) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_pod_pointer {
    pub pod: spa_pod,
    pub body: spa_pod_pointer_body,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_pointer"][::std::mem::size_of::<spa_pod_pointer>() - 24usize];
    ["Alignment of spa_pod_pointer"][::std::mem::align_of::<spa_pod_pointer>() - 8usize];
    ["Offset of field: spa_pod_pointer::pod"]
        [::std::mem::offset_of!(spa_pod_pointer, pod) - 0usize];
    ["Offset of field: spa_pod_pointer::body"]
        [::std::mem::offset_of!(spa_pod_pointer, body) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_pod_fd {
    pub pod: spa_pod,
    pub value: i64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_fd"][::std::mem::size_of::<spa_pod_fd>() - 16usize];
    ["Alignment of spa_pod_fd"][::std::mem::align_of::<spa_pod_fd>() - 8usize];
    ["Offset of field: spa_pod_fd::pod"][::std::mem::offset_of!(spa_pod_fd, pod) - 0usize];
    ["Offset of field: spa_pod_fd::value"][::std::mem::offset_of!(spa_pod_fd, value) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_pod_prop {
    #[doc = "< key of property, list of valid keys depends on the\n  object type"]
    pub key: u32,
    #[doc = "< flags for property"]
    pub flags: u32,
    pub value: spa_pod,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_prop"][::std::mem::size_of::<spa_pod_prop>() - 16usize];
    ["Alignment of spa_pod_prop"][::std::mem::align_of::<spa_pod_prop>() - 4usize];
    ["Offset of field: spa_pod_prop::key"][::std::mem::offset_of!(spa_pod_prop, key) - 0usize];
    ["Offset of field: spa_pod_prop::flags"][::std::mem::offset_of!(spa_pod_prop, flags) - 4usize];
    ["Offset of field: spa_pod_prop::value"][::std::mem::offset_of!(spa_pod_prop, value) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_pod_control {
    #[doc = "< media offset"]
    pub offset: u32,
    #[doc = "< type of control, enum spa_control_type"]
    pub type_: u32,
    #[doc = "< control value, depends on type"]
    pub value: spa_pod,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_control"][::std::mem::size_of::<spa_pod_control>() - 16usize];
    ["Alignment of spa_pod_control"][::std::mem::align_of::<spa_pod_control>() - 4usize];
    ["Offset of field: spa_pod_control::offset"]
        [::std::mem::offset_of!(spa_pod_control, offset) - 0usize];
    ["Offset of field: spa_pod_control::type_"]
        [::std::mem::offset_of!(spa_pod_control, type_) - 4usize];
    ["Offset of field: spa_pod_control::value"]
        [::std::mem::offset_of!(spa_pod_control, value) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_pod_sequence_body {
    pub unit: u32,
    pub pad: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_sequence_body"][::std::mem::size_of::<spa_pod_sequence_body>() - 8usize];
    ["Alignment of spa_pod_sequence_body"]
        [::std::mem::align_of::<spa_pod_sequence_body>() - 4usize];
    ["Offset of field: spa_pod_sequence_body::unit"]
        [::std::mem::offset_of!(spa_pod_sequence_body, unit) - 0usize];
    ["Offset of field: spa_pod_sequence_body::pad"]
        [::std::mem::offset_of!(spa_pod_sequence_body, pad) - 4usize];
};
#[doc = " a sequence of timed controls"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_pod_sequence {
    pub pod: spa_pod,
    pub body: spa_pod_sequence_body,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_sequence"][::std::mem::size_of::<spa_pod_sequence>() - 16usize];
    ["Alignment of spa_pod_sequence"][::std::mem::align_of::<spa_pod_sequence>() - 4usize];
    ["Offset of field: spa_pod_sequence::pod"]
        [::std::mem::offset_of!(spa_pod_sequence, pod) - 0usize];
    ["Offset of field: spa_pod_sequence::body"]
        [::std::mem::offset_of!(spa_pod_sequence, body) - 8usize];
};
#[doc = " a function to destroy an item"]
pub type pw_destroy_t =
    ::std::option::Option<unsafe extern "C" fn(object: *mut ::std::os::raw::c_void)>;
unsafe extern "C" {
    pub fn pw_split_walk(
        str_: *const ::std::os::raw::c_char,
        delimiter: *const ::std::os::raw::c_char,
        len: *mut usize,
        state: *mut *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn pw_split_strv(
        str_: *const ::std::os::raw::c_char,
        delimiter: *const ::std::os::raw::c_char,
        max_tokens: ::std::os::raw::c_int,
        n_tokens: *mut ::std::os::raw::c_int,
    ) -> *mut *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn pw_split_ip(
        str_: *mut ::std::os::raw::c_char,
        delimiter: *const ::std::os::raw::c_char,
        max_tokens: ::std::os::raw::c_int,
        tokens: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pw_strv_parse(
        val: *const ::std::os::raw::c_char,
        len: usize,
        max_tokens: ::std::os::raw::c_int,
        n_tokens: *mut ::std::os::raw::c_int,
    ) -> *mut *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn pw_strv_find(
        a: *mut *mut ::std::os::raw::c_char,
        b: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pw_strv_find_common(
        a: *mut *mut ::std::os::raw::c_char,
        b: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pw_free_strv(str_: *mut *mut ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn pw_strip(
        str_: *mut ::std::os::raw::c_char,
        whitespace: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn pw_getrandom(
        buf: *mut ::std::os::raw::c_void,
        buflen: usize,
        flags: ::std::os::raw::c_uint,
    ) -> isize;
}
unsafe extern "C" {
    pub fn pw_random(buf: *mut ::std::os::raw::c_void, buflen: usize);
}
unsafe extern "C" {
    pub fn pw_reallocarray(
        ptr: *mut ::std::os::raw::c_void,
        nmemb: usize,
        size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
#[doc = " \\}"]
pub type _spa_auto_cleanup_type_pw_strv = *mut *mut ::std::os::raw::c_char;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_protocol_client {
    #[doc = "< link in protocol client_list"]
    pub link: spa_list,
    #[doc = "< the owner protocol"]
    pub protocol: *mut pw_protocol,
    pub core: *mut pw_core,
    pub connect: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut pw_protocol_client,
            props: *const spa_dict,
            done_callback: ::std::option::Option<
                unsafe extern "C" fn(
                    data: *mut ::std::os::raw::c_void,
                    result: ::std::os::raw::c_int,
                ),
            >,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub connect_fd: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut pw_protocol_client,
            fd: ::std::os::raw::c_int,
            close: bool,
        ) -> ::std::os::raw::c_int,
    >,
    pub steal_fd: ::std::option::Option<
        unsafe extern "C" fn(client: *mut pw_protocol_client) -> ::std::os::raw::c_int,
    >,
    pub disconnect: ::std::option::Option<unsafe extern "C" fn(client: *mut pw_protocol_client)>,
    pub destroy: ::std::option::Option<unsafe extern "C" fn(client: *mut pw_protocol_client)>,
    pub set_paused: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut pw_protocol_client,
            paused: bool,
        ) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_protocol_client"][::std::mem::size_of::<pw_protocol_client>() - 80usize];
    ["Alignment of pw_protocol_client"][::std::mem::align_of::<pw_protocol_client>() - 8usize];
    ["Offset of field: pw_protocol_client::link"]
        [::std::mem::offset_of!(pw_protocol_client, link) - 0usize];
    ["Offset of field: pw_protocol_client::protocol"]
        [::std::mem::offset_of!(pw_protocol_client, protocol) - 16usize];
    ["Offset of field: pw_protocol_client::core"]
        [::std::mem::offset_of!(pw_protocol_client, core) - 24usize];
    ["Offset of field: pw_protocol_client::connect"]
        [::std::mem::offset_of!(pw_protocol_client, connect) - 32usize];
    ["Offset of field: pw_protocol_client::connect_fd"]
        [::std::mem::offset_of!(pw_protocol_client, connect_fd) - 40usize];
    ["Offset of field: pw_protocol_client::steal_fd"]
        [::std::mem::offset_of!(pw_protocol_client, steal_fd) - 48usize];
    ["Offset of field: pw_protocol_client::disconnect"]
        [::std::mem::offset_of!(pw_protocol_client, disconnect) - 56usize];
    ["Offset of field: pw_protocol_client::destroy"]
        [::std::mem::offset_of!(pw_protocol_client, destroy) - 64usize];
    ["Offset of field: pw_protocol_client::set_paused"]
        [::std::mem::offset_of!(pw_protocol_client, set_paused) - 72usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_protocol_server {
    #[doc = "< link in protocol server_list"]
    pub link: spa_list,
    #[doc = "< the owner protocol"]
    pub protocol: *mut pw_protocol,
    pub core: *mut pw_impl_core,
    #[doc = "< list of clients of this protocol"]
    pub client_list: spa_list,
    pub destroy: ::std::option::Option<unsafe extern "C" fn(listen: *mut pw_protocol_server)>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_protocol_server"][::std::mem::size_of::<pw_protocol_server>() - 56usize];
    ["Alignment of pw_protocol_server"][::std::mem::align_of::<pw_protocol_server>() - 8usize];
    ["Offset of field: pw_protocol_server::link"]
        [::std::mem::offset_of!(pw_protocol_server, link) - 0usize];
    ["Offset of field: pw_protocol_server::protocol"]
        [::std::mem::offset_of!(pw_protocol_server, protocol) - 16usize];
    ["Offset of field: pw_protocol_server::core"]
        [::std::mem::offset_of!(pw_protocol_server, core) - 24usize];
    ["Offset of field: pw_protocol_server::client_list"]
        [::std::mem::offset_of!(pw_protocol_server, client_list) - 32usize];
    ["Offset of field: pw_protocol_server::destroy"]
        [::std::mem::offset_of!(pw_protocol_server, destroy) - 48usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_protocol_marshal {
    #[doc = "< interface type"]
    pub type_: *const ::std::os::raw::c_char,
    #[doc = "< version"]
    pub version: u32,
    #[doc = "< version"]
    pub flags: u32,
    #[doc = "< number of client methods"]
    pub n_client_methods: u32,
    #[doc = "< number of server methods"]
    pub n_server_methods: u32,
    pub client_marshal: *const ::std::os::raw::c_void,
    pub server_demarshal: *const ::std::os::raw::c_void,
    pub server_marshal: *const ::std::os::raw::c_void,
    pub client_demarshal: *const ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_protocol_marshal"][::std::mem::size_of::<pw_protocol_marshal>() - 56usize];
    ["Alignment of pw_protocol_marshal"][::std::mem::align_of::<pw_protocol_marshal>() - 8usize];
    ["Offset of field: pw_protocol_marshal::type_"]
        [::std::mem::offset_of!(pw_protocol_marshal, type_) - 0usize];
    ["Offset of field: pw_protocol_marshal::version"]
        [::std::mem::offset_of!(pw_protocol_marshal, version) - 8usize];
    ["Offset of field: pw_protocol_marshal::flags"]
        [::std::mem::offset_of!(pw_protocol_marshal, flags) - 12usize];
    ["Offset of field: pw_protocol_marshal::n_client_methods"]
        [::std::mem::offset_of!(pw_protocol_marshal, n_client_methods) - 16usize];
    ["Offset of field: pw_protocol_marshal::n_server_methods"]
        [::std::mem::offset_of!(pw_protocol_marshal, n_server_methods) - 20usize];
    ["Offset of field: pw_protocol_marshal::client_marshal"]
        [::std::mem::offset_of!(pw_protocol_marshal, client_marshal) - 24usize];
    ["Offset of field: pw_protocol_marshal::server_demarshal"]
        [::std::mem::offset_of!(pw_protocol_marshal, server_demarshal) - 32usize];
    ["Offset of field: pw_protocol_marshal::server_marshal"]
        [::std::mem::offset_of!(pw_protocol_marshal, server_marshal) - 40usize];
    ["Offset of field: pw_protocol_marshal::client_demarshal"]
        [::std::mem::offset_of!(pw_protocol_marshal, client_demarshal) - 48usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_protocol_implementation {
    pub version: u32,
    pub new_client: ::std::option::Option<
        unsafe extern "C" fn(
            protocol: *mut pw_protocol,
            core: *mut pw_core,
            props: *const spa_dict,
        ) -> *mut pw_protocol_client,
    >,
    pub add_server: ::std::option::Option<
        unsafe extern "C" fn(
            protocol: *mut pw_protocol,
            core: *mut pw_impl_core,
            props: *const spa_dict,
        ) -> *mut pw_protocol_server,
    >,
    pub add_fd_server: ::std::option::Option<
        unsafe extern "C" fn(
            protocol: *mut pw_protocol,
            core: *mut pw_impl_core,
            listen_fd: ::std::os::raw::c_int,
            close_fd: ::std::os::raw::c_int,
            props: *const spa_dict,
        ) -> *mut pw_protocol_server,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_protocol_implementation"]
        [::std::mem::size_of::<pw_protocol_implementation>() - 32usize];
    ["Alignment of pw_protocol_implementation"]
        [::std::mem::align_of::<pw_protocol_implementation>() - 8usize];
    ["Offset of field: pw_protocol_implementation::version"]
        [::std::mem::offset_of!(pw_protocol_implementation, version) - 0usize];
    ["Offset of field: pw_protocol_implementation::new_client"]
        [::std::mem::offset_of!(pw_protocol_implementation, new_client) - 8usize];
    ["Offset of field: pw_protocol_implementation::add_server"]
        [::std::mem::offset_of!(pw_protocol_implementation, add_server) - 16usize];
    ["Offset of field: pw_protocol_implementation::add_fd_server"]
        [::std::mem::offset_of!(pw_protocol_implementation, add_fd_server) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_protocol_events {
    pub version: u32,
    pub destroy: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_protocol_events"][::std::mem::size_of::<pw_protocol_events>() - 16usize];
    ["Alignment of pw_protocol_events"][::std::mem::align_of::<pw_protocol_events>() - 8usize];
    ["Offset of field: pw_protocol_events::version"]
        [::std::mem::offset_of!(pw_protocol_events, version) - 0usize];
    ["Offset of field: pw_protocol_events::destroy"]
        [::std::mem::offset_of!(pw_protocol_events, destroy) - 8usize];
};
unsafe extern "C" {
    pub fn pw_protocol_new(
        context: *mut pw_context,
        name: *const ::std::os::raw::c_char,
        user_data_size: usize,
    ) -> *mut pw_protocol;
}
unsafe extern "C" {
    pub fn pw_protocol_destroy(protocol: *mut pw_protocol);
}
unsafe extern "C" {
    pub fn pw_protocol_get_context(protocol: *mut pw_protocol) -> *mut pw_context;
}
unsafe extern "C" {
    pub fn pw_protocol_get_user_data(protocol: *mut pw_protocol) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn pw_protocol_get_implementation(
        protocol: *mut pw_protocol,
    ) -> *const pw_protocol_implementation;
}
unsafe extern "C" {
    pub fn pw_protocol_get_extension(protocol: *mut pw_protocol) -> *const ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn pw_protocol_add_listener(
        protocol: *mut pw_protocol,
        listener: *mut spa_hook,
        events: *const pw_protocol_events,
        data: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn pw_protocol_add_marshal(
        protocol: *mut pw_protocol,
        marshal: *const pw_protocol_marshal,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pw_protocol_get_marshal(
        protocol: *mut pw_protocol,
        type_: *const ::std::os::raw::c_char,
        version: u32,
        flags: u32,
    ) -> *const pw_protocol_marshal;
}
unsafe extern "C" {
    pub fn pw_context_find_protocol(
        context: *mut pw_context,
        name: *const ::std::os::raw::c_char,
    ) -> *mut pw_protocol;
}
#[doc = " Proxy events, use \\ref pw_proxy_add_listener"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_proxy_events {
    pub version: u32,
    #[doc = " The proxy is destroyed"]
    pub destroy: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " a proxy is bound to a global id"]
    pub bound: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, global_id: u32),
    >,
    #[doc = " a proxy is removed from the server. Use pw_proxy_destroy to\n free the proxy."]
    pub removed: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " a reply to a sync method completed"]
    pub done: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, seq: ::std::os::raw::c_int),
    >,
    #[doc = " an error occurred on the proxy"]
    pub error: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            seq: ::std::os::raw::c_int,
            res: ::std::os::raw::c_int,
            message: *const ::std::os::raw::c_char,
        ),
    >,
    pub bound_props: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            global_id: u32,
            props: *const spa_dict,
        ),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_proxy_events"][::std::mem::size_of::<pw_proxy_events>() - 56usize];
    ["Alignment of pw_proxy_events"][::std::mem::align_of::<pw_proxy_events>() - 8usize];
    ["Offset of field: pw_proxy_events::version"]
        [::std::mem::offset_of!(pw_proxy_events, version) - 0usize];
    ["Offset of field: pw_proxy_events::destroy"]
        [::std::mem::offset_of!(pw_proxy_events, destroy) - 8usize];
    ["Offset of field: pw_proxy_events::bound"]
        [::std::mem::offset_of!(pw_proxy_events, bound) - 16usize];
    ["Offset of field: pw_proxy_events::removed"]
        [::std::mem::offset_of!(pw_proxy_events, removed) - 24usize];
    ["Offset of field: pw_proxy_events::done"]
        [::std::mem::offset_of!(pw_proxy_events, done) - 32usize];
    ["Offset of field: pw_proxy_events::error"]
        [::std::mem::offset_of!(pw_proxy_events, error) - 40usize];
    ["Offset of field: pw_proxy_events::bound_props"]
        [::std::mem::offset_of!(pw_proxy_events, bound_props) - 48usize];
};
unsafe extern "C" {
    pub fn pw_proxy_new(
        factory: *mut pw_proxy,
        type_: *const ::std::os::raw::c_char,
        version: u32,
        user_data_size: usize,
    ) -> *mut pw_proxy;
}
unsafe extern "C" {
    #[doc = " Add an event listener to proxy"]
    pub fn pw_proxy_add_listener(
        proxy: *mut pw_proxy,
        listener: *mut spa_hook,
        events: *const pw_proxy_events,
        data: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = " Add a listener for the events received from the remote object. The\n events depend on the type of the remote object type."]
    pub fn pw_proxy_add_object_listener(
        proxy: *mut pw_proxy,
        listener: *mut spa_hook,
        funcs: *const ::std::os::raw::c_void,
        data: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = " destroy a proxy"]
    pub fn pw_proxy_destroy(proxy: *mut pw_proxy);
}
unsafe extern "C" {
    pub fn pw_proxy_ref(proxy: *mut pw_proxy);
}
unsafe extern "C" {
    pub fn pw_proxy_unref(proxy: *mut pw_proxy);
}
unsafe extern "C" {
    #[doc = " Get the user_data. The size was given in \\ref pw_proxy_new"]
    pub fn pw_proxy_get_user_data(proxy: *mut pw_proxy) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " Get the local id of the proxy"]
    pub fn pw_proxy_get_id(proxy: *mut pw_proxy) -> u32;
}
unsafe extern "C" {
    #[doc = " Get the type and version of the proxy"]
    pub fn pw_proxy_get_type(
        proxy: *mut pw_proxy,
        version: *mut u32,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Get the protocol used for the proxy"]
    pub fn pw_proxy_get_protocol(proxy: *mut pw_proxy) -> *mut pw_protocol;
}
unsafe extern "C" {
    #[doc = " Generate an sync method for a proxy. This will generate a done event\n with the same seq number of the reply."]
    pub fn pw_proxy_sync(proxy: *mut pw_proxy, seq: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Set the global id this proxy is bound to. This is usually used internally\n and will also emit the bound event"]
    pub fn pw_proxy_set_bound_id(proxy: *mut pw_proxy, global_id: u32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the global id bound to this proxy of SPA_ID_INVALID when not bound\n to a global"]
    pub fn pw_proxy_get_bound_id(proxy: *mut pw_proxy) -> u32;
}
unsafe extern "C" {
    #[doc = " Generate an error for a proxy"]
    pub fn pw_proxy_error(
        proxy: *mut pw_proxy,
        res: ::std::os::raw::c_int,
        error: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pw_proxy_errorf(
        proxy: *mut pw_proxy,
        res: ::std::os::raw::c_int,
        error: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the listener of proxy"]
    pub fn pw_proxy_get_object_listeners(proxy: *mut pw_proxy) -> *mut spa_hook_list;
}
unsafe extern "C" {
    #[doc = " Get the marshal functions for the proxy"]
    pub fn pw_proxy_get_marshal(proxy: *mut pw_proxy) -> *const pw_protocol_marshal;
}
unsafe extern "C" {
    #[doc = " Install a marshal function on a proxy"]
    pub fn pw_proxy_install_marshal(
        proxy: *mut pw_proxy,
        implementor: bool,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_permission {
    #[doc = "< id of object, PW_ID_ANY for default permission"]
    pub id: u32,
    #[doc = "< bitmask of above permissions"]
    pub permissions: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_permission"][::std::mem::size_of::<pw_permission>() - 8usize];
    ["Alignment of pw_permission"][::std::mem::align_of::<pw_permission>() - 4usize];
    ["Offset of field: pw_permission::id"][::std::mem::offset_of!(pw_permission, id) - 0usize];
    ["Offset of field: pw_permission::permissions"]
        [::std::mem::offset_of!(pw_permission, permissions) - 4usize];
};
#[doc = " The client information. Extra information can be added in later versions"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_client_info {
    #[doc = "< id of the global"]
    pub id: u32,
    #[doc = "< bitfield of changed fields since last call"]
    pub change_mask: u64,
    #[doc = "< extra properties"]
    pub props: *mut spa_dict,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_client_info"][::std::mem::size_of::<pw_client_info>() - 24usize];
    ["Alignment of pw_client_info"][::std::mem::align_of::<pw_client_info>() - 8usize];
    ["Offset of field: pw_client_info::id"][::std::mem::offset_of!(pw_client_info, id) - 0usize];
    ["Offset of field: pw_client_info::change_mask"]
        [::std::mem::offset_of!(pw_client_info, change_mask) - 8usize];
    ["Offset of field: pw_client_info::props"]
        [::std::mem::offset_of!(pw_client_info, props) - 16usize];
};
unsafe extern "C" {
    #[doc = " Update an existing \\ref pw_client_info with \\a update with reset"]
    pub fn pw_client_info_update(
        info: *mut pw_client_info,
        update: *const pw_client_info,
    ) -> *mut pw_client_info;
}
unsafe extern "C" {
    #[doc = " Merge an existing \\ref pw_client_info with \\a update"]
    pub fn pw_client_info_merge(
        info: *mut pw_client_info,
        update: *const pw_client_info,
        reset: bool,
    ) -> *mut pw_client_info;
}
unsafe extern "C" {
    #[doc = " Free a \\ref pw_client_info"]
    pub fn pw_client_info_free(info: *mut pw_client_info);
}
#[doc = " Client events"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_client_events {
    pub version: u32,
    #[doc = " Notify client info\n\n \\param info info about the client"]
    pub info: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, info: *const pw_client_info),
    >,
    #[doc = " Notify a client permission\n\n Event emitted as a result of the get_permissions method.\n\n \\param default_permissions the default permissions\n \\param index the index of the first permission entry\n \\param n_permissions the number of permissions\n \\param permissions the permissions"]
    pub permissions: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            index: u32,
            n_permissions: u32,
            permissions: *const pw_permission,
        ),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_client_events"][::std::mem::size_of::<pw_client_events>() - 24usize];
    ["Alignment of pw_client_events"][::std::mem::align_of::<pw_client_events>() - 8usize];
    ["Offset of field: pw_client_events::version"]
        [::std::mem::offset_of!(pw_client_events, version) - 0usize];
    ["Offset of field: pw_client_events::info"]
        [::std::mem::offset_of!(pw_client_events, info) - 8usize];
    ["Offset of field: pw_client_events::permissions"]
        [::std::mem::offset_of!(pw_client_events, permissions) - 16usize];
};
#[doc = " Client methods"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_client_methods {
    pub version: u32,
    pub add_listener: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            listener: *mut spa_hook,
            events: *const pw_client_events,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Send an error to a client\n\n \\param id the global id to report the error on\n \\param res an errno style error code\n \\param message an error string\n\n This requires W and X permissions on the client."]
    pub error: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            id: u32,
            res: ::std::os::raw::c_int,
            message: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Update client properties\n\n \\param props new properties\n\n This requires W and X permissions on the client."]
    pub update_properties: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            props: *const spa_dict,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Get client permissions\n\n A permissions event will be emitted with the permissions.\n\n \\param index the first index to query, 0 for first\n \\param num the maximum number of items to get\n\n This requires W and X permissions on the client."]
    pub get_permissions: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            index: u32,
            num: u32,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Manage the permissions of the global objects for this\n client\n\n Update the permissions of the global objects using the\n provided array with permissions\n\n Globals can use the default permissions or can have specific\n permissions assigned to them.\n\n \\param n_permissions number of permissions\n \\param permissions array of permissions\n\n This requires W and X permissions on the client."]
    pub update_permissions: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            n_permissions: u32,
            permissions: *const pw_permission,
        ) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_client_methods"][::std::mem::size_of::<pw_client_methods>() - 48usize];
    ["Alignment of pw_client_methods"][::std::mem::align_of::<pw_client_methods>() - 8usize];
    ["Offset of field: pw_client_methods::version"]
        [::std::mem::offset_of!(pw_client_methods, version) - 0usize];
    ["Offset of field: pw_client_methods::add_listener"]
        [::std::mem::offset_of!(pw_client_methods, add_listener) - 8usize];
    ["Offset of field: pw_client_methods::error"]
        [::std::mem::offset_of!(pw_client_methods, error) - 16usize];
    ["Offset of field: pw_client_methods::update_properties"]
        [::std::mem::offset_of!(pw_client_methods, update_properties) - 24usize];
    ["Offset of field: pw_client_methods::get_permissions"]
        [::std::mem::offset_of!(pw_client_methods, get_permissions) - 32usize];
    ["Offset of field: pw_client_methods::update_permissions"]
        [::std::mem::offset_of!(pw_client_methods, update_permissions) - 40usize];
};
pub type float_t = f32;
pub type double_t = f64;
unsafe extern "C" {
    pub fn __fpclassify(__value: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __signbit(__value: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __isinf(__value: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __finite(__value: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __isnan(__value: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __iseqsig(__x: f64, __y: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __issignaling(__value: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn acos(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __acos(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn asin(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __asin(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn atan(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __atan(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn atan2(__y: f64, __x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __atan2(__y: f64, __x: f64) -> f64;
}
unsafe extern "C" {
    pub fn cos(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __cos(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn sin(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __sin(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn tan(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __tan(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn cosh(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __cosh(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn sinh(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __sinh(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn tanh(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __tanh(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn acosh(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __acosh(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn asinh(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __asinh(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn atanh(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __atanh(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn exp(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __exp(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn frexp(__x: f64, __exponent: *mut ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    pub fn __frexp(__x: f64, __exponent: *mut ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    pub fn ldexp(__x: f64, __exponent: ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    pub fn __ldexp(__x: f64, __exponent: ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    pub fn log(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __log(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn log10(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __log10(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn modf(__x: f64, __iptr: *mut f64) -> f64;
}
unsafe extern "C" {
    pub fn __modf(__x: f64, __iptr: *mut f64) -> f64;
}
unsafe extern "C" {
    pub fn expm1(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __expm1(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn log1p(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __log1p(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn logb(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __logb(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn exp2(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __exp2(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn log2(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __log2(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn pow(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __pow(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn sqrt(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __sqrt(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn hypot(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __hypot(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn cbrt(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __cbrt(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn ceil(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __ceil(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn fabs(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __fabs(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn floor(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __floor(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn fmod(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __fmod(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn isinf(__value: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn finite(__value: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn drem(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __drem(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn significand(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __significand(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn copysign(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __copysign(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn nan(__tagb: *const ::std::os::raw::c_char) -> f64;
}
unsafe extern "C" {
    pub fn __nan(__tagb: *const ::std::os::raw::c_char) -> f64;
}
unsafe extern "C" {
    pub fn isnan(__value: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn j0(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn __j0(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn j1(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn __j1(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn __jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn y0(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn __y0(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn y1(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn __y1(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn __yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn erf(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn __erf(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn erfc(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn __erfc(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn lgamma(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn __lgamma(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn tgamma(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn __tgamma(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn gamma(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn __gamma(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn lgamma_r(arg1: f64, __signgamp: *mut ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    pub fn __lgamma_r(arg1: f64, __signgamp: *mut ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    pub fn rint(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __rint(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn nextafter(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __nextafter(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn nexttoward(__x: f64, __y: u128) -> f64;
}
unsafe extern "C" {
    pub fn __nexttoward(__x: f64, __y: u128) -> f64;
}
unsafe extern "C" {
    pub fn remainder(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __remainder(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn scalbn(__x: f64, __n: ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    pub fn __scalbn(__x: f64, __n: ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    pub fn ilogb(__x: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __ilogb(__x: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn scalbln(__x: f64, __n: ::std::os::raw::c_long) -> f64;
}
unsafe extern "C" {
    pub fn __scalbln(__x: f64, __n: ::std::os::raw::c_long) -> f64;
}
unsafe extern "C" {
    pub fn nearbyint(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __nearbyint(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn round(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __round(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn trunc(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __trunc(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn remquo(__x: f64, __y: f64, __quo: *mut ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    pub fn __remquo(__x: f64, __y: f64, __quo: *mut ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    pub fn lrint(__x: f64) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn __lrint(__x: f64) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn llrint(__x: f64) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn __llrint(__x: f64) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn lround(__x: f64) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn __lround(__x: f64) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn llround(__x: f64) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn __llround(__x: f64) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn fdim(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __fdim(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn fmax(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __fmax(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn fmin(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __fmin(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn fma(__x: f64, __y: f64, __z: f64) -> f64;
}
unsafe extern "C" {
    pub fn __fma(__x: f64, __y: f64, __z: f64) -> f64;
}
unsafe extern "C" {
    pub fn scalb(__x: f64, __n: f64) -> f64;
}
unsafe extern "C" {
    pub fn __scalb(__x: f64, __n: f64) -> f64;
}
unsafe extern "C" {
    pub fn __fpclassifyf(__value: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __signbitf(__value: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __isinff(__value: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __finitef(__value: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __isnanf(__value: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __iseqsigf(__x: f32, __y: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __issignalingf(__value: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn acosf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __acosf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn asinf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __asinf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn atanf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __atanf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn atan2f(__y: f32, __x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __atan2f(__y: f32, __x: f32) -> f32;
}
unsafe extern "C" {
    pub fn cosf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __cosf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn sinf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __sinf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn tanf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __tanf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn coshf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __coshf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn sinhf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __sinhf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn tanhf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __tanhf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn acoshf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __acoshf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn asinhf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __asinhf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn atanhf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __atanhf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn expf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __expf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn frexpf(__x: f32, __exponent: *mut ::std::os::raw::c_int) -> f32;
}
unsafe extern "C" {
    pub fn __frexpf(__x: f32, __exponent: *mut ::std::os::raw::c_int) -> f32;
}
unsafe extern "C" {
    pub fn ldexpf(__x: f32, __exponent: ::std::os::raw::c_int) -> f32;
}
unsafe extern "C" {
    pub fn __ldexpf(__x: f32, __exponent: ::std::os::raw::c_int) -> f32;
}
unsafe extern "C" {
    pub fn logf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __logf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn log10f(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __log10f(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn modff(__x: f32, __iptr: *mut f32) -> f32;
}
unsafe extern "C" {
    pub fn __modff(__x: f32, __iptr: *mut f32) -> f32;
}
unsafe extern "C" {
    pub fn expm1f(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __expm1f(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn log1pf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __log1pf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn logbf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __logbf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn exp2f(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __exp2f(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn log2f(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __log2f(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn powf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __powf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn sqrtf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __sqrtf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn hypotf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __hypotf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn cbrtf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __cbrtf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn ceilf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __ceilf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn fabsf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __fabsf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn floorf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __floorf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn fmodf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __fmodf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn isinff(__value: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn finitef(__value: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn dremf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __dremf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn significandf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __significandf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn copysignf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __copysignf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn nanf(__tagb: *const ::std::os::raw::c_char) -> f32;
}
unsafe extern "C" {
    pub fn __nanf(__tagb: *const ::std::os::raw::c_char) -> f32;
}
unsafe extern "C" {
    pub fn isnanf(__value: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn j0f(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn __j0f(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn j1f(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn __j1f(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn jnf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
unsafe extern "C" {
    pub fn __jnf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
unsafe extern "C" {
    pub fn y0f(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn __y0f(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn y1f(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn __y1f(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn ynf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
unsafe extern "C" {
    pub fn __ynf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
unsafe extern "C" {
    pub fn erff(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn __erff(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn erfcf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn __erfcf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn lgammaf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn __lgammaf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn tgammaf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn __tgammaf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn gammaf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn __gammaf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn lgammaf_r(arg1: f32, __signgamp: *mut ::std::os::raw::c_int) -> f32;
}
unsafe extern "C" {
    pub fn __lgammaf_r(arg1: f32, __signgamp: *mut ::std::os::raw::c_int) -> f32;
}
unsafe extern "C" {
    pub fn rintf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __rintf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn nextafterf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __nextafterf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn nexttowardf(__x: f32, __y: u128) -> f32;
}
unsafe extern "C" {
    pub fn __nexttowardf(__x: f32, __y: u128) -> f32;
}
unsafe extern "C" {
    pub fn remainderf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __remainderf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn scalbnf(__x: f32, __n: ::std::os::raw::c_int) -> f32;
}
unsafe extern "C" {
    pub fn __scalbnf(__x: f32, __n: ::std::os::raw::c_int) -> f32;
}
unsafe extern "C" {
    pub fn ilogbf(__x: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __ilogbf(__x: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn scalblnf(__x: f32, __n: ::std::os::raw::c_long) -> f32;
}
unsafe extern "C" {
    pub fn __scalblnf(__x: f32, __n: ::std::os::raw::c_long) -> f32;
}
unsafe extern "C" {
    pub fn nearbyintf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __nearbyintf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn roundf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __roundf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn truncf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __truncf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn remquof(__x: f32, __y: f32, __quo: *mut ::std::os::raw::c_int) -> f32;
}
unsafe extern "C" {
    pub fn __remquof(__x: f32, __y: f32, __quo: *mut ::std::os::raw::c_int) -> f32;
}
unsafe extern "C" {
    pub fn lrintf(__x: f32) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn __lrintf(__x: f32) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn llrintf(__x: f32) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn __llrintf(__x: f32) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn lroundf(__x: f32) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn __lroundf(__x: f32) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn llroundf(__x: f32) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn __llroundf(__x: f32) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn fdimf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __fdimf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn fmaxf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __fmaxf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn fminf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __fminf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn fmaf(__x: f32, __y: f32, __z: f32) -> f32;
}
unsafe extern "C" {
    pub fn __fmaf(__x: f32, __y: f32, __z: f32) -> f32;
}
unsafe extern "C" {
    pub fn scalbf(__x: f32, __n: f32) -> f32;
}
unsafe extern "C" {
    pub fn __scalbf(__x: f32, __n: f32) -> f32;
}
unsafe extern "C" {
    pub fn __fpclassifyl(__value: u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __signbitl(__value: u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __isinfl(__value: u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __finitel(__value: u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __isnanl(__value: u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __iseqsigl(__x: u128, __y: u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __issignalingl(__value: u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn acosl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __acosl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn asinl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __asinl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn atanl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __atanl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn atan2l(__y: u128, __x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __atan2l(__y: u128, __x: u128) -> u128;
}
unsafe extern "C" {
    pub fn cosl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __cosl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn sinl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __sinl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn tanl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __tanl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn coshl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __coshl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn sinhl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __sinhl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn tanhl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __tanhl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn acoshl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __acoshl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn asinhl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __asinhl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn atanhl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __atanhl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn expl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __expl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn frexpl(__x: u128, __exponent: *mut ::std::os::raw::c_int) -> u128;
}
unsafe extern "C" {
    pub fn __frexpl(__x: u128, __exponent: *mut ::std::os::raw::c_int) -> u128;
}
unsafe extern "C" {
    pub fn ldexpl(__x: u128, __exponent: ::std::os::raw::c_int) -> u128;
}
unsafe extern "C" {
    pub fn __ldexpl(__x: u128, __exponent: ::std::os::raw::c_int) -> u128;
}
unsafe extern "C" {
    pub fn logl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __logl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn log10l(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __log10l(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn modfl(__x: u128, __iptr: *mut u128) -> u128;
}
unsafe extern "C" {
    pub fn __modfl(__x: u128, __iptr: *mut u128) -> u128;
}
unsafe extern "C" {
    pub fn expm1l(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __expm1l(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn log1pl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __log1pl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn logbl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __logbl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn exp2l(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __exp2l(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn log2l(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __log2l(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn powl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __powl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn sqrtl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __sqrtl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn hypotl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __hypotl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn cbrtl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __cbrtl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn ceill(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __ceill(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn fabsl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __fabsl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn floorl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __floorl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn fmodl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __fmodl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn isinfl(__value: u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn finitel(__value: u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn dreml(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __dreml(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn significandl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __significandl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn copysignl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __copysignl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn nanl(__tagb: *const ::std::os::raw::c_char) -> u128;
}
unsafe extern "C" {
    pub fn __nanl(__tagb: *const ::std::os::raw::c_char) -> u128;
}
unsafe extern "C" {
    pub fn isnanl(__value: u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn j0l(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn __j0l(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn j1l(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn __j1l(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn jnl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
unsafe extern "C" {
    pub fn __jnl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
unsafe extern "C" {
    pub fn y0l(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn __y0l(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn y1l(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn __y1l(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn ynl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
unsafe extern "C" {
    pub fn __ynl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
unsafe extern "C" {
    pub fn erfl(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn __erfl(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn erfcl(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn __erfcl(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn lgammal(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn __lgammal(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn tgammal(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn __tgammal(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn gammal(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn __gammal(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn lgammal_r(arg1: u128, __signgamp: *mut ::std::os::raw::c_int) -> u128;
}
unsafe extern "C" {
    pub fn __lgammal_r(arg1: u128, __signgamp: *mut ::std::os::raw::c_int) -> u128;
}
unsafe extern "C" {
    pub fn rintl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __rintl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn nextafterl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __nextafterl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn nexttowardl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __nexttowardl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn remainderl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __remainderl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn scalbnl(__x: u128, __n: ::std::os::raw::c_int) -> u128;
}
unsafe extern "C" {
    pub fn __scalbnl(__x: u128, __n: ::std::os::raw::c_int) -> u128;
}
unsafe extern "C" {
    pub fn ilogbl(__x: u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __ilogbl(__x: u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn scalblnl(__x: u128, __n: ::std::os::raw::c_long) -> u128;
}
unsafe extern "C" {
    pub fn __scalblnl(__x: u128, __n: ::std::os::raw::c_long) -> u128;
}
unsafe extern "C" {
    pub fn nearbyintl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __nearbyintl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn roundl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __roundl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn truncl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __truncl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn remquol(__x: u128, __y: u128, __quo: *mut ::std::os::raw::c_int) -> u128;
}
unsafe extern "C" {
    pub fn __remquol(__x: u128, __y: u128, __quo: *mut ::std::os::raw::c_int) -> u128;
}
unsafe extern "C" {
    pub fn lrintl(__x: u128) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn __lrintl(__x: u128) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn llrintl(__x: u128) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn __llrintl(__x: u128) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn lroundl(__x: u128) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn __lroundl(__x: u128) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn llroundl(__x: u128) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn __llroundl(__x: u128) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn fdiml(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __fdiml(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn fmaxl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __fmaxl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn fminl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __fminl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn fmal(__x: u128, __y: u128, __z: u128) -> u128;
}
unsafe extern "C" {
    pub fn __fmal(__x: u128, __y: u128, __z: u128) -> u128;
}
unsafe extern "C" {
    pub fn scalbl(__x: u128, __n: u128) -> u128;
}
unsafe extern "C" {
    pub fn __scalbl(__x: u128, __n: u128) -> u128;
}
unsafe extern "C" {
    pub static mut signgam: ::std::os::raw::c_int;
}
pub const FP_NAN: _bindgen_ty_16 = 0;
pub const FP_INFINITE: _bindgen_ty_16 = 1;
pub const FP_ZERO: _bindgen_ty_16 = 2;
pub const FP_SUBNORMAL: _bindgen_ty_16 = 3;
pub const FP_NORMAL: _bindgen_ty_16 = 4;
pub type _bindgen_ty_16 = ::std::os::raw::c_uint;
#[doc = " \\addtogroup spa_json\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_json {
    pub cur: *const ::std::os::raw::c_char,
    pub end: *const ::std::os::raw::c_char,
    pub parent: *mut spa_json,
    pub state: u32,
    pub depth: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_json"][::std::mem::size_of::<spa_json>() - 32usize];
    ["Alignment of spa_json"][::std::mem::align_of::<spa_json>() - 8usize];
    ["Offset of field: spa_json::cur"][::std::mem::offset_of!(spa_json, cur) - 0usize];
    ["Offset of field: spa_json::end"][::std::mem::offset_of!(spa_json, end) - 8usize];
    ["Offset of field: spa_json::parent"][::std::mem::offset_of!(spa_json, parent) - 16usize];
    ["Offset of field: spa_json::state"][::std::mem::offset_of!(spa_json, state) - 24usize];
    ["Offset of field: spa_json::depth"][::std::mem::offset_of!(spa_json, depth) - 28usize];
};
unsafe extern "C" {
    #[doc = " \\addtogroup pw_conf\n \\{"]
    pub fn pw_conf_load_conf_for_context(
        props: *mut pw_properties,
        conf: *mut pw_properties,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pw_conf_load_conf(
        prefix: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        conf: *mut pw_properties,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pw_conf_load_state(
        prefix: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        conf: *mut pw_properties,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pw_conf_save_state(
        prefix: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        conf: *const pw_properties,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pw_conf_find_match(arr: *mut spa_json, props: *const spa_dict, condition: bool) -> bool;
}
unsafe extern "C" {
    pub fn pw_conf_section_update_props(
        conf: *const spa_dict,
        section: *const ::std::os::raw::c_char,
        props: *mut pw_properties,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pw_conf_section_update_props_rules(
        conf: *const spa_dict,
        context: *const spa_dict,
        section: *const ::std::os::raw::c_char,
        props: *mut pw_properties,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pw_conf_section_for_each(
        conf: *const spa_dict,
        section: *const ::std::os::raw::c_char,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                data: *mut ::std::os::raw::c_void,
                location: *const ::std::os::raw::c_char,
                section: *const ::std::os::raw::c_char,
                str_: *const ::std::os::raw::c_char,
                len: usize,
            ) -> ::std::os::raw::c_int,
        >,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pw_conf_match_rules(
        str_: *const ::std::os::raw::c_char,
        len: usize,
        location: *const ::std::os::raw::c_char,
        props: *const spa_dict,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                data: *mut ::std::os::raw::c_void,
                location: *const ::std::os::raw::c_char,
                action: *const ::std::os::raw::c_char,
                str_: *const ::std::os::raw::c_char,
                len: usize,
            ) -> ::std::os::raw::c_int,
        >,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pw_conf_section_match_rules(
        conf: *const spa_dict,
        section: *const ::std::os::raw::c_char,
        props: *const spa_dict,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                data: *mut ::std::os::raw::c_void,
                location: *const ::std::os::raw::c_char,
                action: *const ::std::os::raw::c_char,
                str_: *const ::std::os::raw::c_char,
                len: usize,
            ) -> ::std::os::raw::c_int,
        >,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_device {
    _unused: [u8; 0],
}
#[doc = " The device information. Extra information can be added in later versions"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_device_info {
    #[doc = "< id of the global"]
    pub id: u32,
    #[doc = "< bitfield of changed fields since last call"]
    pub change_mask: u64,
    #[doc = "< extra properties"]
    pub props: *mut spa_dict,
    #[doc = "< parameters"]
    pub params: *mut spa_param_info,
    #[doc = "< number of items in \\a params"]
    pub n_params: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_device_info"][::std::mem::size_of::<pw_device_info>() - 40usize];
    ["Alignment of pw_device_info"][::std::mem::align_of::<pw_device_info>() - 8usize];
    ["Offset of field: pw_device_info::id"][::std::mem::offset_of!(pw_device_info, id) - 0usize];
    ["Offset of field: pw_device_info::change_mask"]
        [::std::mem::offset_of!(pw_device_info, change_mask) - 8usize];
    ["Offset of field: pw_device_info::props"]
        [::std::mem::offset_of!(pw_device_info, props) - 16usize];
    ["Offset of field: pw_device_info::params"]
        [::std::mem::offset_of!(pw_device_info, params) - 24usize];
    ["Offset of field: pw_device_info::n_params"]
        [::std::mem::offset_of!(pw_device_info, n_params) - 32usize];
};
unsafe extern "C" {
    #[doc = " Update and existing \\ref pw_device_info with \\a update and reset"]
    pub fn pw_device_info_update(
        info: *mut pw_device_info,
        update: *const pw_device_info,
    ) -> *mut pw_device_info;
}
unsafe extern "C" {
    #[doc = " Merge and existing \\ref pw_device_info with \\a update"]
    pub fn pw_device_info_merge(
        info: *mut pw_device_info,
        update: *const pw_device_info,
        reset: bool,
    ) -> *mut pw_device_info;
}
unsafe extern "C" {
    #[doc = " Free a \\ref pw_device_info"]
    pub fn pw_device_info_free(info: *mut pw_device_info);
}
#[doc = " Device events"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_device_events {
    pub version: u32,
    #[doc = " Notify device info\n\n \\param info info about the device"]
    pub info: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, info: *const pw_device_info),
    >,
    #[doc = " Notify a device param\n\n Event emitted as a result of the enum_params method.\n\n \\param seq the sequence number of the request\n \\param id the param id\n \\param index the param index\n \\param next the param index of the next param\n \\param param the parameter"]
    pub param: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            seq: ::std::os::raw::c_int,
            id: u32,
            index: u32,
            next: u32,
            param: *const spa_pod,
        ),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_device_events"][::std::mem::size_of::<pw_device_events>() - 24usize];
    ["Alignment of pw_device_events"][::std::mem::align_of::<pw_device_events>() - 8usize];
    ["Offset of field: pw_device_events::version"]
        [::std::mem::offset_of!(pw_device_events, version) - 0usize];
    ["Offset of field: pw_device_events::info"]
        [::std::mem::offset_of!(pw_device_events, info) - 8usize];
    ["Offset of field: pw_device_events::param"]
        [::std::mem::offset_of!(pw_device_events, param) - 16usize];
};
#[doc = " Device methods"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_device_methods {
    pub version: u32,
    pub add_listener: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            listener: *mut spa_hook,
            events: *const pw_device_events,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Subscribe to parameter changes\n\n Automatically emit param events for the given ids when\n they are changed.\n\n \\param ids an array of param ids\n \\param n_ids the number of ids in \\a ids\n\n This requires X permissions on the device."]
    pub subscribe_params: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            ids: *mut u32,
            n_ids: u32,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Enumerate device parameters\n\n Start enumeration of device parameters. For each param, a\n param event will be emitted.\n\n \\param seq a sequence number to place in the reply\n \\param id the parameter id to enum or PW_ID_ANY for all\n \\param start the start index or 0 for the first param\n \\param num the maximum number of params to retrieve\n \\param filter a param filter or NULL\n\n This requires X permissions on the device."]
    pub enum_params: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            seq: ::std::os::raw::c_int,
            id: u32,
            start: u32,
            num: u32,
            filter: *const spa_pod,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Set a parameter on the device\n\n \\param id the parameter id to set\n \\param flags extra parameter flags\n \\param param the parameter to set\n\n This requires W and X permissions on the device."]
    pub set_param: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            id: u32,
            flags: u32,
            param: *const spa_pod,
        ) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_device_methods"][::std::mem::size_of::<pw_device_methods>() - 40usize];
    ["Alignment of pw_device_methods"][::std::mem::align_of::<pw_device_methods>() - 8usize];
    ["Offset of field: pw_device_methods::version"]
        [::std::mem::offset_of!(pw_device_methods, version) - 0usize];
    ["Offset of field: pw_device_methods::add_listener"]
        [::std::mem::offset_of!(pw_device_methods, add_listener) - 8usize];
    ["Offset of field: pw_device_methods::subscribe_params"]
        [::std::mem::offset_of!(pw_device_methods, subscribe_params) - 16usize];
    ["Offset of field: pw_device_methods::enum_params"]
        [::std::mem::offset_of!(pw_device_methods, enum_params) - 24usize];
    ["Offset of field: pw_device_methods::set_param"]
        [::std::mem::offset_of!(pw_device_methods, set_param) - 32usize];
};
pub const spa_meta_type_SPA_META_Invalid: spa_meta_type = 0;
#[doc = "< struct spa_meta_header"]
pub const spa_meta_type_SPA_META_Header: spa_meta_type = 1;
#[doc = "< struct spa_meta_region with cropping data"]
pub const spa_meta_type_SPA_META_VideoCrop: spa_meta_type = 2;
#[doc = "< array of struct spa_meta_region with damage, where an invalid entry or end-of-array marks the end."]
pub const spa_meta_type_SPA_META_VideoDamage: spa_meta_type = 3;
#[doc = "< struct spa_meta_bitmap"]
pub const spa_meta_type_SPA_META_Bitmap: spa_meta_type = 4;
#[doc = "< struct spa_meta_cursor"]
pub const spa_meta_type_SPA_META_Cursor: spa_meta_type = 5;
#[doc = "< metadata contains a spa_meta_control\n  associated with the data"]
pub const spa_meta_type_SPA_META_Control: spa_meta_type = 6;
#[doc = "< don't write to buffer when count > 0"]
pub const spa_meta_type_SPA_META_Busy: spa_meta_type = 7;
#[doc = "< struct spa_meta_transform"]
pub const spa_meta_type_SPA_META_VideoTransform: spa_meta_type = 8;
#[doc = "< struct spa_meta_sync_timeline"]
pub const spa_meta_type_SPA_META_SyncTimeline: spa_meta_type = 9;
#[doc = "< not part of ABI/API"]
pub const spa_meta_type__SPA_META_LAST: spa_meta_type = 10;
#[doc = " \\addtogroup spa_buffer\n \\{"]
pub type spa_meta_type = ::std::os::raw::c_uint;
#[doc = " A metadata element.\n\n This structure is available on the buffer structure and contains\n the type of the metadata and a pointer/size to the actual metadata\n itself."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_meta {
    #[doc = "< metadata type, one of enum spa_meta_type"]
    pub type_: u32,
    #[doc = "< size of metadata"]
    pub size: u32,
    #[doc = "< pointer to metadata"]
    pub data: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_meta"][::std::mem::size_of::<spa_meta>() - 16usize];
    ["Alignment of spa_meta"][::std::mem::align_of::<spa_meta>() - 8usize];
    ["Offset of field: spa_meta::type_"][::std::mem::offset_of!(spa_meta, type_) - 0usize];
    ["Offset of field: spa_meta::size"][::std::mem::offset_of!(spa_meta, size) - 4usize];
    ["Offset of field: spa_meta::data"][::std::mem::offset_of!(spa_meta, data) - 8usize];
};
#[doc = " Describes essential buffer header metadata such as flags and\n timestamps."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_meta_header {
    #[doc = "< flags"]
    pub flags: u32,
    #[doc = "< offset in current cycle"]
    pub offset: u32,
    #[doc = "< presentation timestamp in nanoseconds"]
    pub pts: i64,
    #[doc = "< decoding timestamp as a difference with pts"]
    pub dts_offset: i64,
    #[doc = "< sequence number, increments with a\n  media specific frequency"]
    pub seq: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_meta_header"][::std::mem::size_of::<spa_meta_header>() - 32usize];
    ["Alignment of spa_meta_header"][::std::mem::align_of::<spa_meta_header>() - 8usize];
    ["Offset of field: spa_meta_header::flags"]
        [::std::mem::offset_of!(spa_meta_header, flags) - 0usize];
    ["Offset of field: spa_meta_header::offset"]
        [::std::mem::offset_of!(spa_meta_header, offset) - 4usize];
    ["Offset of field: spa_meta_header::pts"]
        [::std::mem::offset_of!(spa_meta_header, pts) - 8usize];
    ["Offset of field: spa_meta_header::dts_offset"]
        [::std::mem::offset_of!(spa_meta_header, dts_offset) - 16usize];
    ["Offset of field: spa_meta_header::seq"]
        [::std::mem::offset_of!(spa_meta_header, seq) - 24usize];
};
#[doc = " metadata structure for Region or an array of these for RegionArray"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_meta_region {
    pub region: spa_region,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_meta_region"][::std::mem::size_of::<spa_meta_region>() - 16usize];
    ["Alignment of spa_meta_region"][::std::mem::align_of::<spa_meta_region>() - 4usize];
    ["Offset of field: spa_meta_region::region"]
        [::std::mem::offset_of!(spa_meta_region, region) - 0usize];
};
#[doc = " Bitmap information\n\n This metadata contains a bitmap image in the given format and size.\n It is typically used for cursor images or other small images that are\n better transferred inline."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_meta_bitmap {
    #[doc = "< bitmap video format, one of enum spa_video_format. 0 is\n  and invalid format and should be handled as if there is\n  no new bitmap information."]
    pub format: u32,
    #[doc = "< width and height of bitmap"]
    pub size: spa_rectangle,
    #[doc = "< stride of bitmap data"]
    pub stride: i32,
    #[doc = "< offset of bitmap data in this structure. An offset of\n  0 means no image data (invisible), an offset >=\n  sizeof(struct spa_meta_bitmap) contains valid bitmap\n  info."]
    pub offset: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_meta_bitmap"][::std::mem::size_of::<spa_meta_bitmap>() - 20usize];
    ["Alignment of spa_meta_bitmap"][::std::mem::align_of::<spa_meta_bitmap>() - 4usize];
    ["Offset of field: spa_meta_bitmap::format"]
        [::std::mem::offset_of!(spa_meta_bitmap, format) - 0usize];
    ["Offset of field: spa_meta_bitmap::size"]
        [::std::mem::offset_of!(spa_meta_bitmap, size) - 4usize];
    ["Offset of field: spa_meta_bitmap::stride"]
        [::std::mem::offset_of!(spa_meta_bitmap, stride) - 12usize];
    ["Offset of field: spa_meta_bitmap::offset"]
        [::std::mem::offset_of!(spa_meta_bitmap, offset) - 16usize];
};
#[doc = " Cursor information\n\n Metadata to describe the position and appearance of a pointing device."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_meta_cursor {
    #[doc = "< cursor id. an id of 0 is an invalid id and means that\n  there is no new cursor data"]
    pub id: u32,
    #[doc = "< extra flags"]
    pub flags: u32,
    #[doc = "< position on screen"]
    pub position: spa_point,
    #[doc = "< offsets for hotspot in bitmap, this field has no meaning\n  when there is no valid bitmap (see below)"]
    pub hotspot: spa_point,
    #[doc = "< offset of bitmap meta in this structure. When the offset\n  is 0, there is no new bitmap information. When the offset is\n  >= sizeof(struct spa_meta_cursor) there is a\n  struct spa_meta_bitmap at the offset."]
    pub bitmap_offset: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_meta_cursor"][::std::mem::size_of::<spa_meta_cursor>() - 28usize];
    ["Alignment of spa_meta_cursor"][::std::mem::align_of::<spa_meta_cursor>() - 4usize];
    ["Offset of field: spa_meta_cursor::id"][::std::mem::offset_of!(spa_meta_cursor, id) - 0usize];
    ["Offset of field: spa_meta_cursor::flags"]
        [::std::mem::offset_of!(spa_meta_cursor, flags) - 4usize];
    ["Offset of field: spa_meta_cursor::position"]
        [::std::mem::offset_of!(spa_meta_cursor, position) - 8usize];
    ["Offset of field: spa_meta_cursor::hotspot"]
        [::std::mem::offset_of!(spa_meta_cursor, hotspot) - 16usize];
    ["Offset of field: spa_meta_cursor::bitmap_offset"]
        [::std::mem::offset_of!(spa_meta_cursor, bitmap_offset) - 24usize];
};
#[doc = " a timed set of events associated with the buffer"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_meta_control {
    pub sequence: spa_pod_sequence,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_meta_control"][::std::mem::size_of::<spa_meta_control>() - 16usize];
    ["Alignment of spa_meta_control"][::std::mem::align_of::<spa_meta_control>() - 4usize];
    ["Offset of field: spa_meta_control::sequence"]
        [::std::mem::offset_of!(spa_meta_control, sequence) - 0usize];
};
#[doc = " a busy counter for the buffer"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_meta_busy {
    pub flags: u32,
    #[doc = "< number of users busy with the buffer"]
    pub count: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_meta_busy"][::std::mem::size_of::<spa_meta_busy>() - 8usize];
    ["Alignment of spa_meta_busy"][::std::mem::align_of::<spa_meta_busy>() - 4usize];
    ["Offset of field: spa_meta_busy::flags"]
        [::std::mem::offset_of!(spa_meta_busy, flags) - 0usize];
    ["Offset of field: spa_meta_busy::count"]
        [::std::mem::offset_of!(spa_meta_busy, count) - 4usize];
};
#[doc = "< no transform"]
pub const spa_meta_videotransform_value_SPA_META_TRANSFORMATION_None:
    spa_meta_videotransform_value = 0;
#[doc = "< 90 degree counter-clockwise"]
pub const spa_meta_videotransform_value_SPA_META_TRANSFORMATION_90: spa_meta_videotransform_value =
    1;
#[doc = "< 180 degree counter-clockwise"]
pub const spa_meta_videotransform_value_SPA_META_TRANSFORMATION_180: spa_meta_videotransform_value =
    2;
#[doc = "< 270 degree counter-clockwise"]
pub const spa_meta_videotransform_value_SPA_META_TRANSFORMATION_270: spa_meta_videotransform_value =
    3;
#[doc = "< 180 degree flipped around the vertical axis. Equivalent\n to a reflexion through the vertical line splitting the\n buffer in two equal sized parts"]
pub const spa_meta_videotransform_value_SPA_META_TRANSFORMATION_Flipped:
    spa_meta_videotransform_value = 4;
#[doc = "< flip then rotate around 90 degree counter-clockwise"]
pub const spa_meta_videotransform_value_SPA_META_TRANSFORMATION_Flipped90:
    spa_meta_videotransform_value = 5;
#[doc = "< flip then rotate around 180 degree counter-clockwise"]
pub const spa_meta_videotransform_value_SPA_META_TRANSFORMATION_Flipped180:
    spa_meta_videotransform_value = 6;
#[doc = "< flip then rotate around 270 degree counter-clockwise"]
pub const spa_meta_videotransform_value_SPA_META_TRANSFORMATION_Flipped270:
    spa_meta_videotransform_value = 7;
pub type spa_meta_videotransform_value = ::std::os::raw::c_uint;
#[doc = " a transformation of the buffer"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_meta_videotransform {
    #[doc = "< orientation transformation that was applied to the buffer,\n  one of enum spa_meta_videotransform_value"]
    pub transform: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_meta_videotransform"][::std::mem::size_of::<spa_meta_videotransform>() - 4usize];
    ["Alignment of spa_meta_videotransform"]
        [::std::mem::align_of::<spa_meta_videotransform>() - 4usize];
    ["Offset of field: spa_meta_videotransform::transform"]
        [::std::mem::offset_of!(spa_meta_videotransform, transform) - 0usize];
};
#[doc = " A timeline point for explicit sync\n\n Metadata to describe the time on the timeline when the buffer\n can be acquired and when it can be reused.\n\n This metadata will require negotiation of 2 extra fds for the acquire\n and release timelines respectively.  One way to achieve this is to place\n this metadata as SPA_PARAM_BUFFERS_metaType when negotiating a buffer\n layout with 2 extra fds."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_meta_sync_timeline {
    pub flags: u32,
    pub padding: u32,
    #[doc = "< the timeline acquire point, this is when the data\n  can be accessed."]
    pub acquire_point: u64,
    #[doc = "< the timeline release point, this timeline point should\n  be signaled when the data is no longer accessed."]
    pub release_point: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_meta_sync_timeline"][::std::mem::size_of::<spa_meta_sync_timeline>() - 24usize];
    ["Alignment of spa_meta_sync_timeline"]
        [::std::mem::align_of::<spa_meta_sync_timeline>() - 8usize];
    ["Offset of field: spa_meta_sync_timeline::flags"]
        [::std::mem::offset_of!(spa_meta_sync_timeline, flags) - 0usize];
    ["Offset of field: spa_meta_sync_timeline::padding"]
        [::std::mem::offset_of!(spa_meta_sync_timeline, padding) - 4usize];
    ["Offset of field: spa_meta_sync_timeline::acquire_point"]
        [::std::mem::offset_of!(spa_meta_sync_timeline, acquire_point) - 8usize];
    ["Offset of field: spa_meta_sync_timeline::release_point"]
        [::std::mem::offset_of!(spa_meta_sync_timeline, release_point) - 16usize];
};
pub const spa_data_type_SPA_DATA_Invalid: spa_data_type = 0;
#[doc = "< pointer to memory, the data field in\n  struct spa_data is set."]
pub const spa_data_type_SPA_DATA_MemPtr: spa_data_type = 1;
#[doc = "< memfd, mmap to get to memory."]
pub const spa_data_type_SPA_DATA_MemFd: spa_data_type = 2;
#[doc = "< fd to dmabuf memory. This might not be readily\n  mappable (unless the MAPPABLE flag is set) and should\n  normally be handled with DMABUF apis."]
pub const spa_data_type_SPA_DATA_DmaBuf: spa_data_type = 3;
#[doc = "< memory is identified with an id. The actual memory\n  can be obtained in some other way and can be identified\n  with this id."]
pub const spa_data_type_SPA_DATA_MemId: spa_data_type = 4;
#[doc = "< a syncobj, usually requires a spa_meta_sync_timeline metadata\n  with timeline points."]
pub const spa_data_type_SPA_DATA_SyncObj: spa_data_type = 5;
#[doc = "< not part of ABI"]
pub const spa_data_type__SPA_DATA_LAST: spa_data_type = 6;
#[doc = " \\addtogroup spa_buffer\n \\{"]
pub type spa_data_type = ::std::os::raw::c_uint;
#[doc = " Chunk of memory, can change for each buffer"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_chunk {
    #[doc = "< offset of valid data. Should be taken\n  modulo the data maxsize to get the offset\n  in the data memory."]
    pub offset: u32,
    #[doc = "< size of valid data. Should be clamped to\n  maxsize."]
    pub size: u32,
    #[doc = "< stride of valid data"]
    pub stride: i32,
    #[doc = "< chunk flags"]
    pub flags: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_chunk"][::std::mem::size_of::<spa_chunk>() - 16usize];
    ["Alignment of spa_chunk"][::std::mem::align_of::<spa_chunk>() - 4usize];
    ["Offset of field: spa_chunk::offset"][::std::mem::offset_of!(spa_chunk, offset) - 0usize];
    ["Offset of field: spa_chunk::size"][::std::mem::offset_of!(spa_chunk, size) - 4usize];
    ["Offset of field: spa_chunk::stride"][::std::mem::offset_of!(spa_chunk, stride) - 8usize];
    ["Offset of field: spa_chunk::flags"][::std::mem::offset_of!(spa_chunk, flags) - 12usize];
};
#[doc = " Data for a buffer this stays constant for a buffer"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_data {
    #[doc = "< memory type, one of enum spa_data_type, when\n  allocating memory, the type contains a bitmask\n  of allowed types. SPA_ID_INVALID is a special\n  value for the allocator to indicate that the\n  other side did not explicitly specify any\n  supported data types. It should probably use\n  a memory type that does not require special\n  handling in addition to simple mmap/munmap."]
    pub type_: u32,
    #[doc = "< data flags"]
    pub flags: u32,
    #[doc = "< optional fd for data"]
    pub fd: i64,
    #[doc = "< offset to map fd at, this is page aligned"]
    pub mapoffset: u32,
    #[doc = "< max size of data"]
    pub maxsize: u32,
    #[doc = "< optional data pointer"]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = "< valid chunk of memory"]
    pub chunk: *mut spa_chunk,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_data"][::std::mem::size_of::<spa_data>() - 40usize];
    ["Alignment of spa_data"][::std::mem::align_of::<spa_data>() - 8usize];
    ["Offset of field: spa_data::type_"][::std::mem::offset_of!(spa_data, type_) - 0usize];
    ["Offset of field: spa_data::flags"][::std::mem::offset_of!(spa_data, flags) - 4usize];
    ["Offset of field: spa_data::fd"][::std::mem::offset_of!(spa_data, fd) - 8usize];
    ["Offset of field: spa_data::mapoffset"][::std::mem::offset_of!(spa_data, mapoffset) - 16usize];
    ["Offset of field: spa_data::maxsize"][::std::mem::offset_of!(spa_data, maxsize) - 20usize];
    ["Offset of field: spa_data::data"][::std::mem::offset_of!(spa_data, data) - 24usize];
    ["Offset of field: spa_data::chunk"][::std::mem::offset_of!(spa_data, chunk) - 32usize];
};
#[doc = " A Buffer"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_buffer {
    #[doc = "< number of metadata"]
    pub n_metas: u32,
    #[doc = "< number of data members"]
    pub n_datas: u32,
    #[doc = "< array of metadata"]
    pub metas: *mut spa_meta,
    #[doc = "< array of data members"]
    pub datas: *mut spa_data,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_buffer"][::std::mem::size_of::<spa_buffer>() - 24usize];
    ["Alignment of spa_buffer"][::std::mem::align_of::<spa_buffer>() - 8usize];
    ["Offset of field: spa_buffer::n_metas"][::std::mem::offset_of!(spa_buffer, n_metas) - 0usize];
    ["Offset of field: spa_buffer::n_datas"][::std::mem::offset_of!(spa_buffer, n_datas) - 4usize];
    ["Offset of field: spa_buffer::metas"][::std::mem::offset_of!(spa_buffer, metas) - 8usize];
    ["Offset of field: spa_buffer::datas"][::std::mem::offset_of!(spa_buffer, datas) - 16usize];
};
#[doc = " \\addtogroup spa_pod\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_event_body {
    pub body: spa_pod_object_body,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_event_body"][::std::mem::size_of::<spa_event_body>() - 8usize];
    ["Alignment of spa_event_body"][::std::mem::align_of::<spa_event_body>() - 4usize];
    ["Offset of field: spa_event_body::body"]
        [::std::mem::offset_of!(spa_event_body, body) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_event {
    pub pod: spa_pod,
    pub body: spa_event_body,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_event"][::std::mem::size_of::<spa_event>() - 16usize];
    ["Alignment of spa_event"][::std::mem::align_of::<spa_event>() - 4usize];
    ["Offset of field: spa_event::pod"][::std::mem::offset_of!(spa_event, pod) - 0usize];
    ["Offset of field: spa_event::body"][::std::mem::offset_of!(spa_event, body) - 8usize];
};
pub const spa_node_event_SPA_NODE_EVENT_Error: spa_node_event = 0;
pub const spa_node_event_SPA_NODE_EVENT_Buffering: spa_node_event = 1;
pub const spa_node_event_SPA_NODE_EVENT_RequestRefresh: spa_node_event = 2;
pub const spa_node_event_SPA_NODE_EVENT_RequestProcess: spa_node_event = 3;
pub type spa_node_event = ::std::os::raw::c_uint;
pub const spa_event_node_SPA_EVENT_NODE_START: spa_event_node = 0;
pub type spa_event_node = ::std::os::raw::c_uint;
#[doc = " \\addtogroup spa_pod\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_command_body {
    pub body: spa_pod_object_body,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_command_body"][::std::mem::size_of::<spa_command_body>() - 8usize];
    ["Alignment of spa_command_body"][::std::mem::align_of::<spa_command_body>() - 4usize];
    ["Offset of field: spa_command_body::body"]
        [::std::mem::offset_of!(spa_command_body, body) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_command {
    pub pod: spa_pod,
    pub body: spa_command_body,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_command"][::std::mem::size_of::<spa_command>() - 16usize];
    ["Alignment of spa_command"][::std::mem::align_of::<spa_command>() - 4usize];
    ["Offset of field: spa_command::pod"][::std::mem::offset_of!(spa_command, pod) - 0usize];
    ["Offset of field: spa_command::body"][::std::mem::offset_of!(spa_command, body) - 8usize];
};
#[doc = "< suspend a node, this removes all configured\n formats and closes any devices"]
pub const spa_node_command_SPA_NODE_COMMAND_Suspend: spa_node_command = 0;
#[doc = "< pause a node. this makes it stop emitting\n  scheduling events"]
pub const spa_node_command_SPA_NODE_COMMAND_Pause: spa_node_command = 1;
#[doc = "< start a node, this makes it start emitting\n  scheduling events"]
pub const spa_node_command_SPA_NODE_COMMAND_Start: spa_node_command = 2;
pub const spa_node_command_SPA_NODE_COMMAND_Enable: spa_node_command = 3;
pub const spa_node_command_SPA_NODE_COMMAND_Disable: spa_node_command = 4;
pub const spa_node_command_SPA_NODE_COMMAND_Flush: spa_node_command = 5;
pub const spa_node_command_SPA_NODE_COMMAND_Drain: spa_node_command = 6;
pub const spa_node_command_SPA_NODE_COMMAND_Marker: spa_node_command = 7;
#[doc = "< begin a set of parameter enumerations or\n  configuration that require the device to\n  remain opened, like query formats and then\n  set a format"]
pub const spa_node_command_SPA_NODE_COMMAND_ParamBegin: spa_node_command = 8;
#[doc = "< end a transaction"]
pub const spa_node_command_SPA_NODE_COMMAND_ParamEnd: spa_node_command = 9;
#[doc = "< Sent to a driver when some other node emitted\n  the RequestProcess event."]
pub const spa_node_command_SPA_NODE_COMMAND_RequestProcess: spa_node_command = 10;
pub type spa_node_command = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_node {
    pub iface: spa_interface,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_node"][::std::mem::size_of::<spa_node>() - 32usize];
    ["Alignment of spa_node"][::std::mem::align_of::<spa_node>() - 8usize];
    ["Offset of field: spa_node::iface"][::std::mem::offset_of!(spa_node, iface) - 0usize];
};
#[doc = " Node information structure\n\n Contains the basic node information."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_node_info {
    pub max_input_ports: u32,
    pub max_output_ports: u32,
    pub change_mask: u64,
    pub flags: u64,
    #[doc = "< extra node properties"]
    pub props: *mut spa_dict,
    #[doc = "< parameter information"]
    pub params: *mut spa_param_info,
    #[doc = "< number of items in \\a params"]
    pub n_params: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_node_info"][::std::mem::size_of::<spa_node_info>() - 48usize];
    ["Alignment of spa_node_info"][::std::mem::align_of::<spa_node_info>() - 8usize];
    ["Offset of field: spa_node_info::max_input_ports"]
        [::std::mem::offset_of!(spa_node_info, max_input_ports) - 0usize];
    ["Offset of field: spa_node_info::max_output_ports"]
        [::std::mem::offset_of!(spa_node_info, max_output_ports) - 4usize];
    ["Offset of field: spa_node_info::change_mask"]
        [::std::mem::offset_of!(spa_node_info, change_mask) - 8usize];
    ["Offset of field: spa_node_info::flags"]
        [::std::mem::offset_of!(spa_node_info, flags) - 16usize];
    ["Offset of field: spa_node_info::props"]
        [::std::mem::offset_of!(spa_node_info, props) - 24usize];
    ["Offset of field: spa_node_info::params"]
        [::std::mem::offset_of!(spa_node_info, params) - 32usize];
    ["Offset of field: spa_node_info::n_params"]
        [::std::mem::offset_of!(spa_node_info, n_params) - 40usize];
};
#[doc = " Port information structure\n\n Contains the basic port information."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_port_info {
    pub change_mask: u64,
    #[doc = "< port flags"]
    pub flags: u64,
    #[doc = "< rate of sequence numbers on port"]
    pub rate: spa_fraction,
    #[doc = "< extra port properties"]
    pub props: *const spa_dict,
    #[doc = "< parameter information"]
    pub params: *mut spa_param_info,
    #[doc = "< number of items in \\a params"]
    pub n_params: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_port_info"][::std::mem::size_of::<spa_port_info>() - 48usize];
    ["Alignment of spa_port_info"][::std::mem::align_of::<spa_port_info>() - 8usize];
    ["Offset of field: spa_port_info::change_mask"]
        [::std::mem::offset_of!(spa_port_info, change_mask) - 0usize];
    ["Offset of field: spa_port_info::flags"]
        [::std::mem::offset_of!(spa_port_info, flags) - 8usize];
    ["Offset of field: spa_port_info::rate"][::std::mem::offset_of!(spa_port_info, rate) - 16usize];
    ["Offset of field: spa_port_info::props"]
        [::std::mem::offset_of!(spa_port_info, props) - 24usize];
    ["Offset of field: spa_port_info::params"]
        [::std::mem::offset_of!(spa_port_info, params) - 32usize];
    ["Offset of field: spa_port_info::n_params"]
        [::std::mem::offset_of!(spa_port_info, n_params) - 40usize];
};
#[doc = " an error result"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_result_node_error {
    pub message: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_result_node_error"][::std::mem::size_of::<spa_result_node_error>() - 8usize];
    ["Alignment of spa_result_node_error"]
        [::std::mem::align_of::<spa_result_node_error>() - 8usize];
    ["Offset of field: spa_result_node_error::message"]
        [::std::mem::offset_of!(spa_result_node_error, message) - 0usize];
};
#[doc = " the result of enum_params or port_enum_params."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_result_node_params {
    #[doc = "< id of parameter"]
    pub id: u32,
    #[doc = "< index of parameter"]
    pub index: u32,
    #[doc = "< next index of iteration"]
    pub next: u32,
    #[doc = "< the result param"]
    pub param: *mut spa_pod,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_result_node_params"][::std::mem::size_of::<spa_result_node_params>() - 24usize];
    ["Alignment of spa_result_node_params"]
        [::std::mem::align_of::<spa_result_node_params>() - 8usize];
    ["Offset of field: spa_result_node_params::id"]
        [::std::mem::offset_of!(spa_result_node_params, id) - 0usize];
    ["Offset of field: spa_result_node_params::index"]
        [::std::mem::offset_of!(spa_result_node_params, index) - 4usize];
    ["Offset of field: spa_result_node_params::next"]
        [::std::mem::offset_of!(spa_result_node_params, next) - 8usize];
    ["Offset of field: spa_result_node_params::param"]
        [::std::mem::offset_of!(spa_result_node_params, param) - 16usize];
};
#[doc = " events from the spa_node.\n\n All event are called from the main thread and multiple\n listeners can be registered for the events with\n spa_node_add_listener()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_node_events {
    #[doc = "< version of this structure"]
    pub version: u32,
    #[doc = " Emitted when info changes"]
    pub info: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, info: *const spa_node_info),
    >,
    #[doc = " Emitted when port info changes, NULL when port is removed"]
    pub port_info: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            direction: spa_direction,
            port: u32,
            info: *const spa_port_info,
        ),
    >,
    #[doc = " notify a result.\n\n Some methods will trigger a result event with an optional\n result of the given type. Look at the documentation of the\n method to know when to expect a result event.\n\n The result event can be called synchronously, as an event\n called from inside the method itself, in which case the seq\n number passed to the method will be passed unchanged.\n\n The result event will be called asynchronously when the\n method returned an async return value. In this case, the seq\n number in the result will match the async return value of\n the method call. Users should match the seq number from\n request to the reply."]
    pub result: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            seq: ::std::os::raw::c_int,
            res: ::std::os::raw::c_int,
            type_: u32,
            result: *const ::std::os::raw::c_void,
        ),
    >,
    #[doc = " \\param node a spa_node\n \\param event the event that was emitted\n\n This will be called when an out-of-bound event is notified\n on \\a node."]
    pub event: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, event: *const spa_event),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_node_events"][::std::mem::size_of::<spa_node_events>() - 40usize];
    ["Alignment of spa_node_events"][::std::mem::align_of::<spa_node_events>() - 8usize];
    ["Offset of field: spa_node_events::version"]
        [::std::mem::offset_of!(spa_node_events, version) - 0usize];
    ["Offset of field: spa_node_events::info"]
        [::std::mem::offset_of!(spa_node_events, info) - 8usize];
    ["Offset of field: spa_node_events::port_info"]
        [::std::mem::offset_of!(spa_node_events, port_info) - 16usize];
    ["Offset of field: spa_node_events::result"]
        [::std::mem::offset_of!(spa_node_events, result) - 24usize];
    ["Offset of field: spa_node_events::event"]
        [::std::mem::offset_of!(spa_node_events, event) - 32usize];
};
#[doc = " Node callbacks\n\n Callbacks are called from the real-time data thread. Only\n one callback structure can be set on an spa_node."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_node_callbacks {
    pub version: u32,
    #[doc = " \\param node a spa_node\n\n The node is ready for processing.\n\n When this function is NULL, synchronous operation is requested\n on the ports."]
    pub ready: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            state: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " \\param node a spa_node\n \\param port_id an input port_id\n \\param buffer_id the buffer id to be reused\n\n The node has a buffer that can be reused.\n\n When this function is NULL, the buffers to reuse will be set in\n the io area of the input ports."]
    pub reuse_buffer: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            port_id: u32,
            buffer_id: u32,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " \\param data user data\n \\param trigger the timestamp in microseconds when the xrun happened\n \\param delay the amount of microseconds of xrun.\n \\param info an object with extra info (NULL for now)\n\n The node has encountered an over or underrun\n\n The info contains an object with more information"]
    pub xrun: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            trigger: u64,
            delay: u64,
            info: *mut spa_pod,
        ) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_node_callbacks"][::std::mem::size_of::<spa_node_callbacks>() - 32usize];
    ["Alignment of spa_node_callbacks"][::std::mem::align_of::<spa_node_callbacks>() - 8usize];
    ["Offset of field: spa_node_callbacks::version"]
        [::std::mem::offset_of!(spa_node_callbacks, version) - 0usize];
    ["Offset of field: spa_node_callbacks::ready"]
        [::std::mem::offset_of!(spa_node_callbacks, ready) - 8usize];
    ["Offset of field: spa_node_callbacks::reuse_buffer"]
        [::std::mem::offset_of!(spa_node_callbacks, reuse_buffer) - 16usize];
    ["Offset of field: spa_node_callbacks::xrun"]
        [::std::mem::offset_of!(spa_node_callbacks, xrun) - 24usize];
};
#[doc = " Node methods"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_node_methods {
    pub version: u32,
    #[doc = " Adds an event listener on \\a node.\n\n Setting the events will trigger the info event and a\n port_info event for each managed port on the new\n listener.\n\n \\param node a #spa_node\n \\param listener a listener\n \\param events a struct \\ref spa_node_events\n \\param data data passed as first argument in functions of \\a events\n \\return 0 on success\n\t   < 0 errno on error"]
    pub add_listener: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            listener: *mut spa_hook,
            events: *const spa_node_events,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Set callbacks to on \\a node.\n if \\a callbacks is NULL, the current callbacks are removed.\n\n This function must be called from the main thread.\n\n All callbacks are called from the data thread.\n\n \\param node a spa_node\n \\param callbacks callbacks to set\n \\return 0 on success\n         -EINVAL when node is NULL"]
    pub set_callbacks: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            callbacks: *const spa_node_callbacks,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Perform a sync operation.\n\n This method will emit the result event with the given sequence\n number synchronously or with the returned async return value\n asynchronously.\n\n Because all methods are serialized in the node, this can be used\n to wait for completion of all previous method calls.\n\n \\param seq a sequence number\n \\return 0 on success\n         -EINVAL when node is NULL\n         an async result"]
    pub sync: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            seq: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Enumerate the parameters of a node.\n\n Parameters are identified with an \\a id. Some parameters can have\n multiple values, see the documentation of the parameter id.\n\n Parameters can be filtered by passing a non-NULL \\a filter.\n\n The function will emit the result event up to \\a max times with\n the result value. The seq in the result will either be the \\a seq\n number when executed synchronously or the async return value of\n this function when executed asynchronously.\n\n This function must be called from the main thread.\n\n \\param node a \\ref spa_node\n \\param seq a sequence number to pass to the result event when\n\tthis method is executed synchronously.\n \\param id the param id to enumerate\n \\param start the index of enumeration, pass 0 for the first item\n \\param max the maximum number of parameters to enumerate\n \\param filter and optional filter to use\n\n \\return 0 when no more items can be iterated.\n         -EINVAL when invalid arguments are given\n         -ENOENT the parameter \\a id is unknown\n         -ENOTSUP when there are no parameters\n                 implemented on \\a node\n         an async return value when the result event will be\n             emitted later."]
    pub enum_params: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            seq: ::std::os::raw::c_int,
            id: u32,
            start: u32,
            max: u32,
            filter: *const spa_pod,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Set the configurable parameter in \\a node.\n\n Usually, \\a param will be obtained from enum_params and then\n modified but it is also possible to set another spa_pod\n as long as its keys and types match a supported object.\n\n Objects with property keys that are not known are ignored.\n\n This function must be called from the main thread.\n\n \\param node a \\ref spa_node\n \\param id the parameter id to configure\n \\param flags additional flags\n \\param param the parameter to configure\n\n \\return 0 on success\n         -EINVAL when node is NULL\n         -ENOTSUP when there are no parameters implemented on \\a node\n         -ENOENT the parameter is unknown"]
    pub set_param: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            id: u32,
            flags: u32,
            param: *const spa_pod,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Configure the given memory area with \\a id on \\a node. This\n structure is allocated by the host and is used to exchange\n data and parameters with the node.\n\n Setting an \\a io of NULL will disable the node io.\n\n This function must be called from the main thread.\n\n \\param id the id of the io area, the available ids can be\n        enumerated with the node parameters.\n \\param data a io area memory\n \\param size the size of \\a data\n \\return 0 on success\n         -EINVAL when invalid input is given\n         -ENOENT when \\a id is unknown\n         -ENOSPC when \\a size is too small"]
    pub set_io: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            id: u32,
            data: *mut ::std::os::raw::c_void,
            size: usize,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Send a command to a node.\n\n Upon completion, a command might change the state of a node.\n\n This function must be called from the main thread.\n\n \\param node a  spa_node\n \\param command a spa_command\n \\return 0 on success\n         -EINVAL when node or command is NULL\n         -ENOTSUP when this node can't process commands\n         -EINVAL \\a command is an invalid command"]
    pub send_command: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            command: *const spa_command,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Make a new port with \\a port_id. The caller should use the lowest unused\n port id for the given \\a direction.\n\n Port ids should be between 0 and max_ports as obtained from the info\n event.\n\n This function must be called from the main thread.\n\n \\param node a  spa_node\n \\param direction a enum \\ref spa_direction\n \\param port_id an unused port id\n \\param props extra properties\n \\return 0 on success\n         -EINVAL when node is NULL"]
    pub add_port: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            direction: spa_direction,
            port_id: u32,
            props: *const spa_dict,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Remove a port with \\a port_id.\n\n \\param node a  spa_node\n \\param direction a enum \\ref spa_direction\n \\param port_id a port id\n \\return 0 on success\n         -EINVAL when node is NULL or when port_id is unknown or\n\t\twhen the port can't be removed."]
    pub remove_port: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            direction: spa_direction,
            port_id: u32,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Enumerate all possible parameters of \\a id on \\a port_id of \\a node\n that are compatible with \\a filter.\n\n When SPA_ID_INVALID is given as the port_id, the node will reply with\n the params that would be returned for a new port in the given direction.\n\n The result parameters can be queried and modified and ultimately be used\n to call port_set_param.\n\n The function will emit the result event up to \\a max times with\n the result value. The seq in the result event will either be the\n \\a seq number when executed synchronously or the async return\n value of this function when executed asynchronously.\n\n This function must be called from the main thread.\n\n \\param node a spa_node\n \\param seq a sequence number to pass to the result event when\n\tthis method is executed synchronously.\n \\param direction an spa_direction\n \\param port_id the port to query or SPA_ID_INVALID\n \\param id the parameter id to query\n \\param start the first index to query, 0 to get the first item\n \\param max the maximum number of params to query\n \\param filter a parameter filter or NULL for no filter\n\n \\return 0 when no more items can be iterated.\n         -EINVAL when invalid parameters are given\n         -ENOENT when \\a id is unknown\n         an async return value when the result event will be\n             emitted later."]
    pub port_enum_params: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            seq: ::std::os::raw::c_int,
            direction: spa_direction,
            port_id: u32,
            id: u32,
            start: u32,
            max: u32,
            filter: *const spa_pod,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Set a parameter on \\a port_id of \\a node.\n\n When \\a param is NULL, the parameter will be unset.\n\n This function must be called from the main thread. The node muse be paused\n or the port SPA_IO_Buffers area is NULL when this function is called with\n a param that changes the processing state (like a format change).\n\n \\param node a struct \\ref spa_node\n \\param direction a enum \\ref spa_direction\n \\param port_id the port to configure\n \\param id the parameter id to set\n \\param flags optional flags\n \\param param a struct \\ref spa_pod with the parameter to set\n \\return 0 on success\n         1 on success, the value of \\a param might have been\n                changed depending on \\a flags and the final value can be found by\n                doing port_enum_params.\n         -EINVAL when node is NULL or invalid arguments are given\n         -ESRCH when one of the mandatory param\n                 properties is not specified and SPA_NODE_PARAM_FLAG_FIXATE was\n                 not set in \\a flags.\n         -ESRCH when the type or size of a property is not correct.\n         -ENOENT when the param id is not found"]
    pub port_set_param: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            direction: spa_direction,
            port_id: u32,
            id: u32,
            flags: u32,
            param: *const spa_pod,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Tell the port to use the given buffers\n\n When \\a flags contains SPA_NODE_BUFFERS_FLAG_ALLOC, the data\n in the buffers should point to an array of at least 1 data entry\n with the desired supported type that will be filled by this function.\n\n The port should also have a spa_io_buffers io area configured to exchange\n the buffers with the port.\n\n For an input port, all the buffers will remain dequeued.\n Once a buffer has been queued on a port in the spa_io_buffers,\n it should not be reused until the reuse_buffer callback is notified\n or when the buffer has been returned in the spa_io_buffers of\n the port.\n\n For output ports, all buffers will be queued in the port. When process\n returns SPA_STATUS_HAVE_DATA, buffers are available in one or more\n of the spa_io_buffers areas.\n\n When a buffer can be reused, port_reuse_buffer() should be called or the\n buffer_id should be placed in the spa_io_buffers area before calling\n process.\n\n Passing NULL as \\a buffers will remove the reference that the port has\n on the buffers.\n\n When this function returns async, use the spa_node_sync operation to\n wait for completion.\n\n This function must be called from the main thread. The node muse be paused\n or the port SPA_IO_Buffers area is NULL when this function is called.\n\n \\param object an object implementing the interface\n \\param direction a port direction\n \\param port_id a port id\n \\param flags extra flags\n \\param buffers an array of buffer pointers\n \\param n_buffers number of elements in \\a buffers\n \\return 0 on success"]
    pub port_use_buffers: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            direction: spa_direction,
            port_id: u32,
            flags: u32,
            buffers: *mut *mut spa_buffer,
            n_buffers: u32,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Configure the given memory area with \\a id on \\a port_id. This\n structure is allocated by the host and is used to exchange\n data and parameters with the port.\n\n Setting an \\a io of NULL will disable the port io.\n\n This function must be called from the main thread.\n\n This function can be called when the node is running and the node\n must be prepared to handle changes in io areas while running. This\n is normally done by synchronizing the port io updates with the\n data processing loop.\n\n \\param direction a spa_direction\n \\param port_id a port id\n \\param id the id of the io area, the available ids can be\n        enumerated with the port parameters.\n \\param data a io area memory\n \\param size the size of \\a data\n \\return 0 on success\n         -EINVAL when invalid input is given\n         -ENOENT when \\a id is unknown\n         -ENOSPC when \\a size is too small"]
    pub port_set_io: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            direction: spa_direction,
            port_id: u32,
            id: u32,
            data: *mut ::std::os::raw::c_void,
            size: usize,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Tell an output port to reuse a buffer.\n\n This function must be called from the data thread.\n\n \\param node a spa_node\n \\param port_id a port id\n \\param buffer_id a buffer id to reuse\n \\return 0 on success\n         -EINVAL when node is NULL"]
    pub port_reuse_buffer: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            port_id: u32,
            buffer_id: u32,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Process the node\n\n This function must be called from the data thread.\n\n Output io areas with SPA_STATUS_NEED_DATA will recycle the\n buffers if any.\n\n Input areas with SPA_STATUS_HAVE_DATA are consumed if possible\n and the status is set to SPA_STATUS_NEED_DATA or SPA_STATUS_OK.\n\n When the node has new output buffers, the SPA_STATUS_HAVE_DATA\n bit will be set.\n\n When the node can accept new input in the next cycle, the\n SPA_STATUS_NEED_DATA bit will be set.\n\n Note that the node might return SPA_STATUS_NEED_DATA even when\n no input ports have this status. This means that the amount of\n data still available on the input ports is likely not going to\n be enough for the next cycle and the host might need to prefetch\n data for the next cycle."]
    pub process: ::std::option::Option<
        unsafe extern "C" fn(object: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_node_methods"][::std::mem::size_of::<spa_node_methods>() - 128usize];
    ["Alignment of spa_node_methods"][::std::mem::align_of::<spa_node_methods>() - 8usize];
    ["Offset of field: spa_node_methods::version"]
        [::std::mem::offset_of!(spa_node_methods, version) - 0usize];
    ["Offset of field: spa_node_methods::add_listener"]
        [::std::mem::offset_of!(spa_node_methods, add_listener) - 8usize];
    ["Offset of field: spa_node_methods::set_callbacks"]
        [::std::mem::offset_of!(spa_node_methods, set_callbacks) - 16usize];
    ["Offset of field: spa_node_methods::sync"]
        [::std::mem::offset_of!(spa_node_methods, sync) - 24usize];
    ["Offset of field: spa_node_methods::enum_params"]
        [::std::mem::offset_of!(spa_node_methods, enum_params) - 32usize];
    ["Offset of field: spa_node_methods::set_param"]
        [::std::mem::offset_of!(spa_node_methods, set_param) - 40usize];
    ["Offset of field: spa_node_methods::set_io"]
        [::std::mem::offset_of!(spa_node_methods, set_io) - 48usize];
    ["Offset of field: spa_node_methods::send_command"]
        [::std::mem::offset_of!(spa_node_methods, send_command) - 56usize];
    ["Offset of field: spa_node_methods::add_port"]
        [::std::mem::offset_of!(spa_node_methods, add_port) - 64usize];
    ["Offset of field: spa_node_methods::remove_port"]
        [::std::mem::offset_of!(spa_node_methods, remove_port) - 72usize];
    ["Offset of field: spa_node_methods::port_enum_params"]
        [::std::mem::offset_of!(spa_node_methods, port_enum_params) - 80usize];
    ["Offset of field: spa_node_methods::port_set_param"]
        [::std::mem::offset_of!(spa_node_methods, port_set_param) - 88usize];
    ["Offset of field: spa_node_methods::port_use_buffers"]
        [::std::mem::offset_of!(spa_node_methods, port_use_buffers) - 96usize];
    ["Offset of field: spa_node_methods::port_set_io"]
        [::std::mem::offset_of!(spa_node_methods, port_set_io) - 104usize];
    ["Offset of field: spa_node_methods::port_reuse_buffer"]
        [::std::mem::offset_of!(spa_node_methods, port_reuse_buffer) - 112usize];
    ["Offset of field: spa_node_methods::process"]
        [::std::mem::offset_of!(spa_node_methods, process) - 120usize];
};
pub const pw_memblock_flags_PW_MEMBLOCK_FLAG_NONE: pw_memblock_flags = 0;
#[doc = "< memory is readable"]
pub const pw_memblock_flags_PW_MEMBLOCK_FLAG_READABLE: pw_memblock_flags = 1;
#[doc = "< memory is writable"]
pub const pw_memblock_flags_PW_MEMBLOCK_FLAG_WRITABLE: pw_memblock_flags = 2;
#[doc = "< seal the fd"]
pub const pw_memblock_flags_PW_MEMBLOCK_FLAG_SEAL: pw_memblock_flags = 4;
#[doc = "< mmap the fd"]
pub const pw_memblock_flags_PW_MEMBLOCK_FLAG_MAP: pw_memblock_flags = 8;
#[doc = "< don't close fd"]
pub const pw_memblock_flags_PW_MEMBLOCK_FLAG_DONT_CLOSE: pw_memblock_flags = 16;
#[doc = "< don't notify events"]
pub const pw_memblock_flags_PW_MEMBLOCK_FLAG_DONT_NOTIFY: pw_memblock_flags = 32;
#[doc = "< the fd can not be mmapped"]
pub const pw_memblock_flags_PW_MEMBLOCK_FLAG_UNMAPPABLE: pw_memblock_flags = 64;
pub const pw_memblock_flags_PW_MEMBLOCK_FLAG_READWRITE: pw_memblock_flags = 3;
#[doc = " Flags passed to \\ref pw_mempool_alloc()"]
pub type pw_memblock_flags = ::std::os::raw::c_uint;
pub const pw_memmap_flags_PW_MEMMAP_FLAG_NONE: pw_memmap_flags = 0;
#[doc = "< map in read mode"]
pub const pw_memmap_flags_PW_MEMMAP_FLAG_READ: pw_memmap_flags = 1;
#[doc = "< map in write mode"]
pub const pw_memmap_flags_PW_MEMMAP_FLAG_WRITE: pw_memmap_flags = 2;
#[doc = "< map the same area twice after each other,\n  creating a circular ringbuffer"]
pub const pw_memmap_flags_PW_MEMMAP_FLAG_TWICE: pw_memmap_flags = 4;
#[doc = "< writes will be private"]
pub const pw_memmap_flags_PW_MEMMAP_FLAG_PRIVATE: pw_memmap_flags = 8;
#[doc = "< lock the memory into RAM"]
pub const pw_memmap_flags_PW_MEMMAP_FLAG_LOCKED: pw_memmap_flags = 16;
pub const pw_memmap_flags_PW_MEMMAP_FLAG_READWRITE: pw_memmap_flags = 3;
pub type pw_memmap_flags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_memchunk {
    _unused: [u8; 0],
}
#[doc = " A memory pool is a collection of pw_memblocks"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_mempool {
    pub props: *mut pw_properties,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_mempool"][::std::mem::size_of::<pw_mempool>() - 8usize];
    ["Alignment of pw_mempool"][::std::mem::align_of::<pw_mempool>() - 8usize];
    ["Offset of field: pw_mempool::props"][::std::mem::offset_of!(pw_mempool, props) - 0usize];
};
#[doc = " Memory block structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_memblock {
    #[doc = "< owner pool"]
    pub pool: *mut pw_mempool,
    #[doc = "< unique id"]
    pub id: u32,
    #[doc = "< refcount"]
    pub ref_: ::std::os::raw::c_int,
    #[doc = "< flags for the memory block on of enum pw_memblock_flags"]
    pub flags: u32,
    #[doc = "< type of the fd, one of enum spa_data_type"]
    pub type_: u32,
    #[doc = "< fd"]
    pub fd: ::std::os::raw::c_int,
    #[doc = "< size of memory"]
    pub size: u32,
    #[doc = "< optional map when PW_MEMBLOCK_FLAG_MAP was given"]
    pub map: *mut pw_memmap,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_memblock"][::std::mem::size_of::<pw_memblock>() - 40usize];
    ["Alignment of pw_memblock"][::std::mem::align_of::<pw_memblock>() - 8usize];
    ["Offset of field: pw_memblock::pool"][::std::mem::offset_of!(pw_memblock, pool) - 0usize];
    ["Offset of field: pw_memblock::id"][::std::mem::offset_of!(pw_memblock, id) - 8usize];
    ["Offset of field: pw_memblock::ref_"][::std::mem::offset_of!(pw_memblock, ref_) - 12usize];
    ["Offset of field: pw_memblock::flags"][::std::mem::offset_of!(pw_memblock, flags) - 16usize];
    ["Offset of field: pw_memblock::type_"][::std::mem::offset_of!(pw_memblock, type_) - 20usize];
    ["Offset of field: pw_memblock::fd"][::std::mem::offset_of!(pw_memblock, fd) - 24usize];
    ["Offset of field: pw_memblock::size"][::std::mem::offset_of!(pw_memblock, size) - 28usize];
    ["Offset of field: pw_memblock::map"][::std::mem::offset_of!(pw_memblock, map) - 32usize];
};
#[doc = " a mapped region of a pw_memblock"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_memmap {
    #[doc = "< owner memblock"]
    pub block: *mut pw_memblock,
    #[doc = "< mapped pointer"]
    pub ptr: *mut ::std::os::raw::c_void,
    #[doc = "< flags for the mapping on of enum pw_memmap_flags"]
    pub flags: u32,
    #[doc = "< offset in memblock"]
    pub offset: u32,
    #[doc = "< size in memblock"]
    pub size: u32,
    #[doc = "< user tag"]
    pub tag: [u32; 5usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_memmap"][::std::mem::size_of::<pw_memmap>() - 48usize];
    ["Alignment of pw_memmap"][::std::mem::align_of::<pw_memmap>() - 8usize];
    ["Offset of field: pw_memmap::block"][::std::mem::offset_of!(pw_memmap, block) - 0usize];
    ["Offset of field: pw_memmap::ptr"][::std::mem::offset_of!(pw_memmap, ptr) - 8usize];
    ["Offset of field: pw_memmap::flags"][::std::mem::offset_of!(pw_memmap, flags) - 16usize];
    ["Offset of field: pw_memmap::offset"][::std::mem::offset_of!(pw_memmap, offset) - 20usize];
    ["Offset of field: pw_memmap::size"][::std::mem::offset_of!(pw_memmap, size) - 24usize];
    ["Offset of field: pw_memmap::tag"][::std::mem::offset_of!(pw_memmap, tag) - 28usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_mempool_events {
    pub version: u32,
    #[doc = " the pool is destroyed"]
    pub destroy: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " a new memory block is added to the pool"]
    pub added: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, block: *mut pw_memblock),
    >,
    #[doc = " a memory block is removed from the pool"]
    pub removed: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, block: *mut pw_memblock),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_mempool_events"][::std::mem::size_of::<pw_mempool_events>() - 32usize];
    ["Alignment of pw_mempool_events"][::std::mem::align_of::<pw_mempool_events>() - 8usize];
    ["Offset of field: pw_mempool_events::version"]
        [::std::mem::offset_of!(pw_mempool_events, version) - 0usize];
    ["Offset of field: pw_mempool_events::destroy"]
        [::std::mem::offset_of!(pw_mempool_events, destroy) - 8usize];
    ["Offset of field: pw_mempool_events::added"]
        [::std::mem::offset_of!(pw_mempool_events, added) - 16usize];
    ["Offset of field: pw_mempool_events::removed"]
        [::std::mem::offset_of!(pw_mempool_events, removed) - 24usize];
};
unsafe extern "C" {
    #[doc = " Create a new memory pool"]
    pub fn pw_mempool_new(props: *mut pw_properties) -> *mut pw_mempool;
}
unsafe extern "C" {
    #[doc = " Listen for events"]
    pub fn pw_mempool_add_listener(
        pool: *mut pw_mempool,
        listener: *mut spa_hook,
        events: *const pw_mempool_events,
        data: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = " Clear a pool"]
    pub fn pw_mempool_clear(pool: *mut pw_mempool);
}
unsafe extern "C" {
    #[doc = " Clear and destroy a pool"]
    pub fn pw_mempool_destroy(pool: *mut pw_mempool);
}
unsafe extern "C" {
    #[doc = " Allocate a memory block from the pool"]
    pub fn pw_mempool_alloc(
        pool: *mut pw_mempool,
        flags: pw_memblock_flags,
        type_: u32,
        size: usize,
    ) -> *mut pw_memblock;
}
unsafe extern "C" {
    #[doc = " Import a block from another pool"]
    pub fn pw_mempool_import_block(
        pool: *mut pw_mempool,
        mem: *mut pw_memblock,
    ) -> *mut pw_memblock;
}
unsafe extern "C" {
    #[doc = " Import an fd into the pool"]
    pub fn pw_mempool_import(
        pool: *mut pw_mempool,
        flags: pw_memblock_flags,
        type_: u32,
        fd: ::std::os::raw::c_int,
    ) -> *mut pw_memblock;
}
unsafe extern "C" {
    #[doc = " Free a memblock regardless of the refcount and destroy all mappings"]
    pub fn pw_memblock_free(mem: *mut pw_memblock);
}
unsafe extern "C" {
    #[doc = " Remove a memblock for given \\a id"]
    pub fn pw_mempool_remove_id(pool: *mut pw_mempool, id: u32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Find memblock for given \\a ptr"]
    pub fn pw_mempool_find_ptr(
        pool: *mut pw_mempool,
        ptr: *const ::std::os::raw::c_void,
    ) -> *mut pw_memblock;
}
unsafe extern "C" {
    #[doc = " Find memblock for given \\a id"]
    pub fn pw_mempool_find_id(pool: *mut pw_mempool, id: u32) -> *mut pw_memblock;
}
unsafe extern "C" {
    #[doc = " Find memblock for given \\a fd"]
    pub fn pw_mempool_find_fd(pool: *mut pw_mempool, fd: ::std::os::raw::c_int)
        -> *mut pw_memblock;
}
unsafe extern "C" {
    #[doc = " Map a region of a memory block"]
    pub fn pw_memblock_map(
        block: *mut pw_memblock,
        flags: pw_memmap_flags,
        offset: u32,
        size: u32,
        tag: *mut u32,
    ) -> *mut pw_memmap;
}
unsafe extern "C" {
    #[doc = " Map a region of a memory block with \\a id"]
    pub fn pw_mempool_map_id(
        pool: *mut pw_mempool,
        id: u32,
        flags: pw_memmap_flags,
        offset: u32,
        size: u32,
        tag: *mut u32,
    ) -> *mut pw_memmap;
}
unsafe extern "C" {
    pub fn pw_mempool_import_map(
        pool: *mut pw_mempool,
        other: *mut pw_mempool,
        data: *mut ::std::os::raw::c_void,
        size: u32,
        tag: *mut u32,
    ) -> *mut pw_memmap;
}
unsafe extern "C" {
    #[doc = " find a map with the given tag"]
    pub fn pw_mempool_find_tag(pool: *mut pw_mempool, tag: *mut u32, size: usize)
        -> *mut pw_memmap;
}
unsafe extern "C" {
    #[doc = " Unmap a region"]
    pub fn pw_memmap_free(map: *mut pw_memmap) -> ::std::os::raw::c_int;
}
#[doc = " parameters to map a memory range"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_map_range {
    pub start: u32,
    #[doc = " offset in first page with start of data"]
    pub offset: u32,
    #[doc = " page aligned offset to map"]
    pub size: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_map_range"][::std::mem::size_of::<pw_map_range>() - 12usize];
    ["Alignment of pw_map_range"][::std::mem::align_of::<pw_map_range>() - 4usize];
    ["Offset of field: pw_map_range::start"][::std::mem::offset_of!(pw_map_range, start) - 0usize];
    ["Offset of field: pw_map_range::offset"]
        [::std::mem::offset_of!(pw_map_range, offset) - 4usize];
    ["Offset of field: pw_map_range::size"][::std::mem::offset_of!(pw_map_range, size) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_buffers {
    #[doc = "< allocated buffer memory"]
    pub mem: *mut pw_memblock,
    #[doc = "< port buffers"]
    pub buffers: *mut *mut spa_buffer,
    #[doc = "< number of port buffers"]
    pub n_buffers: u32,
    #[doc = "< flags"]
    pub flags: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_buffers"][::std::mem::size_of::<pw_buffers>() - 24usize];
    ["Alignment of pw_buffers"][::std::mem::align_of::<pw_buffers>() - 8usize];
    ["Offset of field: pw_buffers::mem"][::std::mem::offset_of!(pw_buffers, mem) - 0usize];
    ["Offset of field: pw_buffers::buffers"][::std::mem::offset_of!(pw_buffers, buffers) - 8usize];
    ["Offset of field: pw_buffers::n_buffers"]
        [::std::mem::offset_of!(pw_buffers, n_buffers) - 16usize];
    ["Offset of field: pw_buffers::flags"][::std::mem::offset_of!(pw_buffers, flags) - 20usize];
};
unsafe extern "C" {
    pub fn pw_buffers_negotiate(
        context: *mut pw_context,
        flags: u32,
        outnode: *mut spa_node,
        out_port_id: u32,
        innode: *mut spa_node,
        in_port_id: u32,
        result: *mut pw_buffers,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pw_buffers_clear(buffers: *mut pw_buffers);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_factory {
    _unused: [u8; 0],
}
#[doc = " The factory information. Extra information can be added in later versions"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_factory_info {
    #[doc = "< id of the global"]
    pub id: u32,
    #[doc = "< name the factory"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "< type of the objects created by this factory"]
    pub type_: *const ::std::os::raw::c_char,
    #[doc = "< version of the objects"]
    pub version: u32,
    #[doc = "< bitfield of changed fields since last call"]
    pub change_mask: u64,
    #[doc = "< the properties of the factory"]
    pub props: *mut spa_dict,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_factory_info"][::std::mem::size_of::<pw_factory_info>() - 48usize];
    ["Alignment of pw_factory_info"][::std::mem::align_of::<pw_factory_info>() - 8usize];
    ["Offset of field: pw_factory_info::id"][::std::mem::offset_of!(pw_factory_info, id) - 0usize];
    ["Offset of field: pw_factory_info::name"]
        [::std::mem::offset_of!(pw_factory_info, name) - 8usize];
    ["Offset of field: pw_factory_info::type_"]
        [::std::mem::offset_of!(pw_factory_info, type_) - 16usize];
    ["Offset of field: pw_factory_info::version"]
        [::std::mem::offset_of!(pw_factory_info, version) - 24usize];
    ["Offset of field: pw_factory_info::change_mask"]
        [::std::mem::offset_of!(pw_factory_info, change_mask) - 32usize];
    ["Offset of field: pw_factory_info::props"]
        [::std::mem::offset_of!(pw_factory_info, props) - 40usize];
};
unsafe extern "C" {
    pub fn pw_factory_info_update(
        info: *mut pw_factory_info,
        update: *const pw_factory_info,
    ) -> *mut pw_factory_info;
}
unsafe extern "C" {
    pub fn pw_factory_info_merge(
        info: *mut pw_factory_info,
        update: *const pw_factory_info,
        reset: bool,
    ) -> *mut pw_factory_info;
}
unsafe extern "C" {
    pub fn pw_factory_info_free(info: *mut pw_factory_info);
}
#[doc = " Factory events"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_factory_events {
    pub version: u32,
    #[doc = " Notify factory info\n\n \\param info info about the factory"]
    pub info: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, info: *const pw_factory_info),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_factory_events"][::std::mem::size_of::<pw_factory_events>() - 16usize];
    ["Alignment of pw_factory_events"][::std::mem::align_of::<pw_factory_events>() - 8usize];
    ["Offset of field: pw_factory_events::version"]
        [::std::mem::offset_of!(pw_factory_events, version) - 0usize];
    ["Offset of field: pw_factory_events::info"]
        [::std::mem::offset_of!(pw_factory_events, info) - 8usize];
};
#[doc = " Factory methods"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_factory_methods {
    pub version: u32,
    pub add_listener: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            listener: *mut spa_hook,
            events: *const pw_factory_events,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_factory_methods"][::std::mem::size_of::<pw_factory_methods>() - 16usize];
    ["Alignment of pw_factory_methods"][::std::mem::align_of::<pw_factory_methods>() - 8usize];
    ["Offset of field: pw_factory_methods::version"]
        [::std::mem::offset_of!(pw_factory_methods, version) - 0usize];
    ["Offset of field: pw_factory_methods::add_listener"]
        [::std::mem::offset_of!(pw_factory_methods, add_listener) - 8usize];
};
pub const spa_log_level_SPA_LOG_LEVEL_NONE: spa_log_level = 0;
pub const spa_log_level_SPA_LOG_LEVEL_ERROR: spa_log_level = 1;
pub const spa_log_level_SPA_LOG_LEVEL_WARN: spa_log_level = 2;
pub const spa_log_level_SPA_LOG_LEVEL_INFO: spa_log_level = 3;
pub const spa_log_level_SPA_LOG_LEVEL_DEBUG: spa_log_level = 4;
pub const spa_log_level_SPA_LOG_LEVEL_TRACE: spa_log_level = 5;
pub type spa_log_level = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_log {
    pub iface: spa_interface,
    #[doc = " Logging level, everything above this level is not logged"]
    pub level: spa_log_level,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_log"][::std::mem::size_of::<spa_log>() - 40usize];
    ["Alignment of spa_log"][::std::mem::align_of::<spa_log>() - 8usize];
    ["Offset of field: spa_log::iface"][::std::mem::offset_of!(spa_log, iface) - 0usize];
    ["Offset of field: spa_log::level"][::std::mem::offset_of!(spa_log, level) - 32usize];
};
#[doc = " \\struct spa_log_topic\n\n Identifier for a topic. Topics are string-based filters that logically\n group messages together. An implementation may decide to filter different\n topics on different levels, for example the \"protocol\" topic may require\n debug level TRACE while the \"core\" topic defaults to debug level INFO.\n\n spa_log_topics require a spa_log_methods version of 1 or higher."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_log_topic {
    #[doc = " the version of this topic. This can be used to expand this\n structure in the future"]
    pub version: u32,
    #[doc = " The string identifier for the topic"]
    pub topic: *const ::std::os::raw::c_char,
    #[doc = " Logging level set for this topic"]
    pub level: spa_log_level,
    #[doc = " False if this topic follows the \\ref spa_log level"]
    pub has_custom_level: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_log_topic"][::std::mem::size_of::<spa_log_topic>() - 24usize];
    ["Alignment of spa_log_topic"][::std::mem::align_of::<spa_log_topic>() - 8usize];
    ["Offset of field: spa_log_topic::version"]
        [::std::mem::offset_of!(spa_log_topic, version) - 0usize];
    ["Offset of field: spa_log_topic::topic"]
        [::std::mem::offset_of!(spa_log_topic, topic) - 8usize];
    ["Offset of field: spa_log_topic::level"]
        [::std::mem::offset_of!(spa_log_topic, level) - 16usize];
    ["Offset of field: spa_log_topic::has_custom_level"]
        [::std::mem::offset_of!(spa_log_topic, has_custom_level) - 20usize];
};
#[doc = " Enumeration of log topics in a plugin\n\n \\since 1.1.0"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_log_topic_enum {
    pub version: u32,
    #[doc = " Array of pointers to log topics"]
    pub topics: *const *mut spa_log_topic,
    #[doc = " End of topics array"]
    pub topics_end: *const *mut spa_log_topic,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_log_topic_enum"][::std::mem::size_of::<spa_log_topic_enum>() - 24usize];
    ["Alignment of spa_log_topic_enum"][::std::mem::align_of::<spa_log_topic_enum>() - 8usize];
    ["Offset of field: spa_log_topic_enum::version"]
        [::std::mem::offset_of!(spa_log_topic_enum, version) - 0usize];
    ["Offset of field: spa_log_topic_enum::topics"]
        [::std::mem::offset_of!(spa_log_topic_enum, topics) - 8usize];
    ["Offset of field: spa_log_topic_enum::topics_end"]
        [::std::mem::offset_of!(spa_log_topic_enum, topics_end) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_log_methods {
    pub version: u32,
    #[doc = " Log a message with the given log level.\n\n \\note If compiled with this header, this function is only called\n for implementations of version 0. For versions 1 and above, see\n logt() instead.\n\n \\param log a spa_log\n \\param level a spa_log_level\n \\param file the file name\n \\param line the line number\n \\param func the function name\n \\param fmt printf style format\n \\param ... format arguments"]
    pub log: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            level: spa_log_level,
            file: *const ::std::os::raw::c_char,
            line: ::std::os::raw::c_int,
            func: *const ::std::os::raw::c_char,
            fmt: *const ::std::os::raw::c_char,
            ...
        ),
    >,
    #[doc = " Log a message with the given log level.\n\n \\note If compiled with this header, this function is only called\n for implementations of version 0. For versions 1 and above, see\n logtv() instead.\n\n \\param log a spa_log\n \\param level a spa_log_level\n \\param file the file name\n \\param line the line number\n \\param func the function name\n \\param fmt printf style format\n \\param args format arguments"]
    pub logv: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            level: spa_log_level,
            file: *const ::std::os::raw::c_char,
            line: ::std::os::raw::c_int,
            func: *const ::std::os::raw::c_char,
            fmt: *const ::std::os::raw::c_char,
            args: *mut __va_list_tag,
        ),
    >,
    #[doc = " Log a message with the given log level for the given topic.\n\n \\note Callers that do not use topic-based logging (version 0), the \\a\n topic is NULL\n\n \\param log a spa_log\n \\param level a spa_log_level\n \\param topic the topic for this message, may be NULL\n \\param file the file name\n \\param line the line number\n \\param func the function name\n \\param fmt printf style format\n \\param ... format arguments\n\n \\since 1"]
    pub logt: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            level: spa_log_level,
            topic: *const spa_log_topic,
            file: *const ::std::os::raw::c_char,
            line: ::std::os::raw::c_int,
            func: *const ::std::os::raw::c_char,
            fmt: *const ::std::os::raw::c_char,
            ...
        ),
    >,
    #[doc = " Log a message with the given log level for the given topic.\n\n \\note For callers that do not use topic-based logging (version 0),\n the \\a topic is NULL\n\n \\param log a spa_log\n \\param level a spa_log_level\n \\param topic the topic for this message, may be NULL\n \\param file the file name\n \\param line the line number\n \\param func the function name\n \\param fmt printf style format\n \\param args format arguments\n\n \\since 1"]
    pub logtv: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            level: spa_log_level,
            topic: *const spa_log_topic,
            file: *const ::std::os::raw::c_char,
            line: ::std::os::raw::c_int,
            func: *const ::std::os::raw::c_char,
            fmt: *const ::std::os::raw::c_char,
            args: *mut __va_list_tag,
        ),
    >,
    #[doc = " Initializes a \\ref spa_log_topic to the correct logging level.\n\n \\deprecated\n Plugin host should obtain log topics from \\ref SPA_LOG_TOPIC_ENUM_NAME\n and update them itself.\n\n \\since 1"]
    pub topic_init: ::std::option::Option<
        unsafe extern "C" fn(object: *mut ::std::os::raw::c_void, topic: *mut spa_log_topic),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_log_methods"][::std::mem::size_of::<spa_log_methods>() - 48usize];
    ["Alignment of spa_log_methods"][::std::mem::align_of::<spa_log_methods>() - 8usize];
    ["Offset of field: spa_log_methods::version"]
        [::std::mem::offset_of!(spa_log_methods, version) - 0usize];
    ["Offset of field: spa_log_methods::log"]
        [::std::mem::offset_of!(spa_log_methods, log) - 8usize];
    ["Offset of field: spa_log_methods::logv"]
        [::std::mem::offset_of!(spa_log_methods, logv) - 16usize];
    ["Offset of field: spa_log_methods::logt"]
        [::std::mem::offset_of!(spa_log_methods, logt) - 24usize];
    ["Offset of field: spa_log_methods::logtv"]
        [::std::mem::offset_of!(spa_log_methods, logtv) - 32usize];
    ["Offset of field: spa_log_methods::topic_init"]
        [::std::mem::offset_of!(spa_log_methods, topic_init) - 40usize];
};
unsafe extern "C" {
    #[doc = " \\addtogroup pw_log\n \\{\n/\n/** The global log level"]
    pub static mut pw_log_level: spa_log_level;
}
unsafe extern "C" {
    pub static PW_LOG_TOPIC_DEFAULT: *mut spa_log_topic;
}
unsafe extern "C" {
    #[doc = " Configure a logging module. This is usually done automatically\n in pw_init() but you can install a custom logger before calling\n pw_init()."]
    pub fn pw_log_set(log: *mut spa_log);
}
unsafe extern "C" {
    #[doc = " Get the log interface"]
    pub fn pw_log_get() -> *mut spa_log;
}
unsafe extern "C" {
    #[doc = " Configure the logging level"]
    pub fn pw_log_set_level(level: spa_log_level);
}
unsafe extern "C" {
    #[doc = " Configure the logging level using a string\n in PIPEWIRE_DEBUG format.\n\n \\since 1.1.0"]
    pub fn pw_log_set_level_string(str_: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Log a message for a topic"]
    pub fn pw_log_logt(
        level: spa_log_level,
        topic: *const spa_log_topic,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
unsafe extern "C" {
    #[doc = " Log a message for a topic"]
    pub fn pw_log_logtv(
        level: spa_log_level,
        topic: *const spa_log_topic,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        fmt: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    );
}
unsafe extern "C" {
    #[doc = " Log a message for the default topic"]
    pub fn pw_log_log(
        level: spa_log_level,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
unsafe extern "C" {
    #[doc = " Log a message for the default topic"]
    pub fn pw_log_logv(
        level: spa_log_level,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        fmt: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    );
}
unsafe extern "C" {
    #[doc = " Register log topic with the logger, to enable dynamic log levels.\n Topic must be unregistered before freeing it or plugin unload.\n May be used instead of \\ref PW_LOG_TOPIC_INIT\n This function is threadsafe.\n\n \\since 1.1.0"]
    pub fn pw_log_topic_register(t: *mut spa_log_topic);
}
unsafe extern "C" {
    #[doc = " Unregister log topic. This function is threadsafe.\n\n \\since 1.1.0"]
    pub fn pw_log_topic_unregister(t: *mut spa_log_topic);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_link {
    _unused: [u8; 0],
}
#[doc = "< the link is in error"]
pub const pw_link_state_PW_LINK_STATE_ERROR: pw_link_state = -2;
#[doc = "< the link is unlinked"]
pub const pw_link_state_PW_LINK_STATE_UNLINKED: pw_link_state = -1;
#[doc = "< the link is initialized"]
pub const pw_link_state_PW_LINK_STATE_INIT: pw_link_state = 0;
#[doc = "< the link is negotiating formats"]
pub const pw_link_state_PW_LINK_STATE_NEGOTIATING: pw_link_state = 1;
#[doc = "< the link is allocating buffers"]
pub const pw_link_state_PW_LINK_STATE_ALLOCATING: pw_link_state = 2;
#[doc = "< the link is paused"]
pub const pw_link_state_PW_LINK_STATE_PAUSED: pw_link_state = 3;
#[doc = "< the link is active"]
pub const pw_link_state_PW_LINK_STATE_ACTIVE: pw_link_state = 4;
#[doc = " \\enum pw_link_state The different link states"]
pub type pw_link_state = ::std::os::raw::c_int;
unsafe extern "C" {
    #[doc = " Convert a \\ref pw_link_state to a readable string"]
    pub fn pw_link_state_as_string(state: pw_link_state) -> *const ::std::os::raw::c_char;
}
#[doc = " The link information. Extra information can be added in later versions"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_link_info {
    #[doc = "< id of the global"]
    pub id: u32,
    #[doc = "< server side output node id"]
    pub output_node_id: u32,
    #[doc = "< output port id"]
    pub output_port_id: u32,
    #[doc = "< server side input node id"]
    pub input_node_id: u32,
    #[doc = "< input port id"]
    pub input_port_id: u32,
    #[doc = "< bitfield of changed fields since last call"]
    pub change_mask: u64,
    #[doc = "< the current state of the link"]
    pub state: pw_link_state,
    #[doc = "< an error reason if \\a state is error"]
    pub error: *const ::std::os::raw::c_char,
    #[doc = "< format over link"]
    pub format: *mut spa_pod,
    #[doc = "< the properties of the link"]
    pub props: *mut spa_dict,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_link_info"][::std::mem::size_of::<pw_link_info>() - 64usize];
    ["Alignment of pw_link_info"][::std::mem::align_of::<pw_link_info>() - 8usize];
    ["Offset of field: pw_link_info::id"][::std::mem::offset_of!(pw_link_info, id) - 0usize];
    ["Offset of field: pw_link_info::output_node_id"]
        [::std::mem::offset_of!(pw_link_info, output_node_id) - 4usize];
    ["Offset of field: pw_link_info::output_port_id"]
        [::std::mem::offset_of!(pw_link_info, output_port_id) - 8usize];
    ["Offset of field: pw_link_info::input_node_id"]
        [::std::mem::offset_of!(pw_link_info, input_node_id) - 12usize];
    ["Offset of field: pw_link_info::input_port_id"]
        [::std::mem::offset_of!(pw_link_info, input_port_id) - 16usize];
    ["Offset of field: pw_link_info::change_mask"]
        [::std::mem::offset_of!(pw_link_info, change_mask) - 24usize];
    ["Offset of field: pw_link_info::state"][::std::mem::offset_of!(pw_link_info, state) - 32usize];
    ["Offset of field: pw_link_info::error"][::std::mem::offset_of!(pw_link_info, error) - 40usize];
    ["Offset of field: pw_link_info::format"]
        [::std::mem::offset_of!(pw_link_info, format) - 48usize];
    ["Offset of field: pw_link_info::props"][::std::mem::offset_of!(pw_link_info, props) - 56usize];
};
unsafe extern "C" {
    pub fn pw_link_info_update(
        info: *mut pw_link_info,
        update: *const pw_link_info,
    ) -> *mut pw_link_info;
}
unsafe extern "C" {
    pub fn pw_link_info_merge(
        info: *mut pw_link_info,
        update: *const pw_link_info,
        reset: bool,
    ) -> *mut pw_link_info;
}
unsafe extern "C" {
    pub fn pw_link_info_free(info: *mut pw_link_info);
}
#[doc = " Link events"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_link_events {
    pub version: u32,
    #[doc = " Notify link info\n\n \\param info info about the link"]
    pub info: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, info: *const pw_link_info),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_link_events"][::std::mem::size_of::<pw_link_events>() - 16usize];
    ["Alignment of pw_link_events"][::std::mem::align_of::<pw_link_events>() - 8usize];
    ["Offset of field: pw_link_events::version"]
        [::std::mem::offset_of!(pw_link_events, version) - 0usize];
    ["Offset of field: pw_link_events::info"]
        [::std::mem::offset_of!(pw_link_events, info) - 8usize];
};
#[doc = " Link methods"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_link_methods {
    pub version: u32,
    pub add_listener: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            listener: *mut spa_hook,
            events: *const pw_link_events,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_link_methods"][::std::mem::size_of::<pw_link_methods>() - 16usize];
    ["Alignment of pw_link_methods"][::std::mem::align_of::<pw_link_methods>() - 8usize];
    ["Offset of field: pw_link_methods::version"]
        [::std::mem::offset_of!(pw_link_methods, version) - 0usize];
    ["Offset of field: pw_link_methods::add_listener"]
        [::std::mem::offset_of!(pw_link_methods, add_listener) - 8usize];
};
#[doc = " A main loop object"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_main_loop {
    _unused: [u8; 0],
}
#[doc = " Events of the main loop"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_main_loop_events {
    pub version: u32,
    #[doc = " Emitted when the main loop is destroyed"]
    pub destroy: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_main_loop_events"][::std::mem::size_of::<pw_main_loop_events>() - 16usize];
    ["Alignment of pw_main_loop_events"][::std::mem::align_of::<pw_main_loop_events>() - 8usize];
    ["Offset of field: pw_main_loop_events::version"]
        [::std::mem::offset_of!(pw_main_loop_events, version) - 0usize];
    ["Offset of field: pw_main_loop_events::destroy"]
        [::std::mem::offset_of!(pw_main_loop_events, destroy) - 8usize];
};
unsafe extern "C" {
    #[doc = " Create a new main loop."]
    pub fn pw_main_loop_new(props: *const spa_dict) -> *mut pw_main_loop;
}
unsafe extern "C" {
    #[doc = " Add an event listener"]
    pub fn pw_main_loop_add_listener(
        loop_: *mut pw_main_loop,
        listener: *mut spa_hook,
        events: *const pw_main_loop_events,
        data: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = " Get the loop implementation"]
    pub fn pw_main_loop_get_loop(loop_: *mut pw_main_loop) -> *mut pw_loop;
}
unsafe extern "C" {
    #[doc = " Destroy a loop"]
    pub fn pw_main_loop_destroy(loop_: *mut pw_main_loop);
}
unsafe extern "C" {
    #[doc = " Run a main loop. This blocks until \\ref pw_main_loop_quit is called.\n\n @return 0 on success, otherwise a negative number."]
    pub fn pw_main_loop_run(loop_: *mut pw_main_loop) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Quit a main loop"]
    pub fn pw_main_loop_quit(loop_: *mut pw_main_loop) -> ::std::os::raw::c_int;
}
#[doc = " \\private\n An entry in the map. This is used internally only. Each element in the\n backing pw_array is a union pw_map_item. For real items, the data pointer\n points to the item. If an element has been removed, pw_map->free_list\n is the index of the most recently removed item. That item contains\n the index of the next removed item until item->next is SPA_ID_INVALID.\n\n The free list is prepended only, the last item to be removed will be the\n first item to get re-used on the next insert."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union pw_map_item {
    pub next: usize,
    pub data: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_map_item"][::std::mem::size_of::<pw_map_item>() - 8usize];
    ["Alignment of pw_map_item"][::std::mem::align_of::<pw_map_item>() - 8usize];
    ["Offset of field: pw_map_item::next"][::std::mem::offset_of!(pw_map_item, next) - 0usize];
    ["Offset of field: pw_map_item::data"][::std::mem::offset_of!(pw_map_item, data) - 0usize];
};
#[doc = " A map. This struct should be treated as opaque by the caller."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_map {
    pub items: pw_array,
    pub free_list: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_map"][::std::mem::size_of::<pw_map>() - 40usize];
    ["Alignment of pw_map"][::std::mem::align_of::<pw_map>() - 8usize];
    ["Offset of field: pw_map::items"][::std::mem::offset_of!(pw_map, items) - 0usize];
    ["Offset of field: pw_map::free_list"][::std::mem::offset_of!(pw_map, free_list) - 32usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_module {
    _unused: [u8; 0],
}
#[doc = " The module information. Extra information can be added in later versions"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_module_info {
    #[doc = "< id of the global"]
    pub id: u32,
    #[doc = "< name of the module"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "< filename of the module"]
    pub filename: *const ::std::os::raw::c_char,
    #[doc = "< arguments passed to the module"]
    pub args: *const ::std::os::raw::c_char,
    #[doc = "< bitfield of changed fields since last call"]
    pub change_mask: u64,
    #[doc = "< extra properties"]
    pub props: *mut spa_dict,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_module_info"][::std::mem::size_of::<pw_module_info>() - 48usize];
    ["Alignment of pw_module_info"][::std::mem::align_of::<pw_module_info>() - 8usize];
    ["Offset of field: pw_module_info::id"][::std::mem::offset_of!(pw_module_info, id) - 0usize];
    ["Offset of field: pw_module_info::name"]
        [::std::mem::offset_of!(pw_module_info, name) - 8usize];
    ["Offset of field: pw_module_info::filename"]
        [::std::mem::offset_of!(pw_module_info, filename) - 16usize];
    ["Offset of field: pw_module_info::args"]
        [::std::mem::offset_of!(pw_module_info, args) - 24usize];
    ["Offset of field: pw_module_info::change_mask"]
        [::std::mem::offset_of!(pw_module_info, change_mask) - 32usize];
    ["Offset of field: pw_module_info::props"]
        [::std::mem::offset_of!(pw_module_info, props) - 40usize];
};
unsafe extern "C" {
    #[doc = " Update and existing \\ref pw_module_info with \\a update with reset"]
    pub fn pw_module_info_update(
        info: *mut pw_module_info,
        update: *const pw_module_info,
    ) -> *mut pw_module_info;
}
unsafe extern "C" {
    #[doc = " Merge and existing \\ref pw_module_info with \\a update"]
    pub fn pw_module_info_merge(
        info: *mut pw_module_info,
        update: *const pw_module_info,
        reset: bool,
    ) -> *mut pw_module_info;
}
unsafe extern "C" {
    #[doc = " Free a \\ref pw_module_info"]
    pub fn pw_module_info_free(info: *mut pw_module_info);
}
#[doc = " Module events"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_module_events {
    pub version: u32,
    #[doc = " Notify module info\n\n \\param info info about the module"]
    pub info: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, info: *const pw_module_info),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_module_events"][::std::mem::size_of::<pw_module_events>() - 16usize];
    ["Alignment of pw_module_events"][::std::mem::align_of::<pw_module_events>() - 8usize];
    ["Offset of field: pw_module_events::version"]
        [::std::mem::offset_of!(pw_module_events, version) - 0usize];
    ["Offset of field: pw_module_events::info"]
        [::std::mem::offset_of!(pw_module_events, info) - 8usize];
};
#[doc = " Module methods"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_module_methods {
    pub version: u32,
    pub add_listener: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            listener: *mut spa_hook,
            events: *const pw_module_events,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_module_methods"][::std::mem::size_of::<pw_module_methods>() - 16usize];
    ["Alignment of pw_module_methods"][::std::mem::align_of::<pw_module_methods>() - 8usize];
    ["Offset of field: pw_module_methods::version"]
        [::std::mem::offset_of!(pw_module_methods, version) - 0usize];
    ["Offset of field: pw_module_methods::add_listener"]
        [::std::mem::offset_of!(pw_module_methods, add_listener) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_node {
    _unused: [u8; 0],
}
#[doc = "< error state"]
pub const pw_node_state_PW_NODE_STATE_ERROR: pw_node_state = -1;
#[doc = "< the node is being created"]
pub const pw_node_state_PW_NODE_STATE_CREATING: pw_node_state = 0;
#[doc = "< the node is suspended, the device might\n   be closed"]
pub const pw_node_state_PW_NODE_STATE_SUSPENDED: pw_node_state = 1;
#[doc = "< the node is running but there is no active\n   port"]
pub const pw_node_state_PW_NODE_STATE_IDLE: pw_node_state = 2;
#[doc = "< the node is running"]
pub const pw_node_state_PW_NODE_STATE_RUNNING: pw_node_state = 3;
#[doc = " \\enum pw_node_state The different node states"]
pub type pw_node_state = ::std::os::raw::c_int;
unsafe extern "C" {
    #[doc = " Convert a \\ref pw_node_state to a readable string"]
    pub fn pw_node_state_as_string(state: pw_node_state) -> *const ::std::os::raw::c_char;
}
#[doc = " The node information. Extra information can be added in later versions"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_node_info {
    #[doc = "< id of the global"]
    pub id: u32,
    #[doc = "< maximum number of inputs"]
    pub max_input_ports: u32,
    #[doc = "< maximum number of outputs"]
    pub max_output_ports: u32,
    #[doc = "< bitfield of changed fields since last call"]
    pub change_mask: u64,
    #[doc = "< number of inputs"]
    pub n_input_ports: u32,
    #[doc = "< number of outputs"]
    pub n_output_ports: u32,
    #[doc = "< the current state of the node"]
    pub state: pw_node_state,
    #[doc = "< an error reason if \\a state is error"]
    pub error: *const ::std::os::raw::c_char,
    #[doc = "< the properties of the node"]
    pub props: *mut spa_dict,
    #[doc = "< parameters"]
    pub params: *mut spa_param_info,
    #[doc = "< number of items in \\a params"]
    pub n_params: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_node_info"][::std::mem::size_of::<pw_node_info>() - 72usize];
    ["Alignment of pw_node_info"][::std::mem::align_of::<pw_node_info>() - 8usize];
    ["Offset of field: pw_node_info::id"][::std::mem::offset_of!(pw_node_info, id) - 0usize];
    ["Offset of field: pw_node_info::max_input_ports"]
        [::std::mem::offset_of!(pw_node_info, max_input_ports) - 4usize];
    ["Offset of field: pw_node_info::max_output_ports"]
        [::std::mem::offset_of!(pw_node_info, max_output_ports) - 8usize];
    ["Offset of field: pw_node_info::change_mask"]
        [::std::mem::offset_of!(pw_node_info, change_mask) - 16usize];
    ["Offset of field: pw_node_info::n_input_ports"]
        [::std::mem::offset_of!(pw_node_info, n_input_ports) - 24usize];
    ["Offset of field: pw_node_info::n_output_ports"]
        [::std::mem::offset_of!(pw_node_info, n_output_ports) - 28usize];
    ["Offset of field: pw_node_info::state"][::std::mem::offset_of!(pw_node_info, state) - 32usize];
    ["Offset of field: pw_node_info::error"][::std::mem::offset_of!(pw_node_info, error) - 40usize];
    ["Offset of field: pw_node_info::props"][::std::mem::offset_of!(pw_node_info, props) - 48usize];
    ["Offset of field: pw_node_info::params"]
        [::std::mem::offset_of!(pw_node_info, params) - 56usize];
    ["Offset of field: pw_node_info::n_params"]
        [::std::mem::offset_of!(pw_node_info, n_params) - 64usize];
};
unsafe extern "C" {
    pub fn pw_node_info_update(
        info: *mut pw_node_info,
        update: *const pw_node_info,
    ) -> *mut pw_node_info;
}
unsafe extern "C" {
    pub fn pw_node_info_merge(
        info: *mut pw_node_info,
        update: *const pw_node_info,
        reset: bool,
    ) -> *mut pw_node_info;
}
unsafe extern "C" {
    pub fn pw_node_info_free(info: *mut pw_node_info);
}
#[doc = " Node events"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_node_events {
    pub version: u32,
    #[doc = " Notify node info\n\n \\param info info about the node"]
    pub info: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, info: *const pw_node_info),
    >,
    #[doc = " Notify a node param\n\n Event emitted as a result of the enum_params method.\n\n \\param seq the sequence number of the request\n \\param id the param id\n \\param index the param index\n \\param next the param index of the next param\n \\param param the parameter"]
    pub param: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            seq: ::std::os::raw::c_int,
            id: u32,
            index: u32,
            next: u32,
            param: *const spa_pod,
        ),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_node_events"][::std::mem::size_of::<pw_node_events>() - 24usize];
    ["Alignment of pw_node_events"][::std::mem::align_of::<pw_node_events>() - 8usize];
    ["Offset of field: pw_node_events::version"]
        [::std::mem::offset_of!(pw_node_events, version) - 0usize];
    ["Offset of field: pw_node_events::info"]
        [::std::mem::offset_of!(pw_node_events, info) - 8usize];
    ["Offset of field: pw_node_events::param"]
        [::std::mem::offset_of!(pw_node_events, param) - 16usize];
};
#[doc = " Node methods"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_node_methods {
    pub version: u32,
    pub add_listener: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            listener: *mut spa_hook,
            events: *const pw_node_events,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Subscribe to parameter changes\n\n Automatically emit param events for the given ids when\n they are changed.\n\n \\param ids an array of param ids\n \\param n_ids the number of ids in \\a ids\n\n This requires X permissions on the node."]
    pub subscribe_params: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            ids: *mut u32,
            n_ids: u32,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Enumerate node parameters\n\n Start enumeration of node parameters. For each param, a\n param event will be emitted.\n\n \\param seq a sequence number to place in the reply\n \\param id the parameter id to enum or PW_ID_ANY for all\n \\param start the start index or 0 for the first param\n \\param num the maximum number of params to retrieve\n \\param filter a param filter or NULL\n\n This requires X permissions on the node."]
    pub enum_params: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            seq: ::std::os::raw::c_int,
            id: u32,
            start: u32,
            num: u32,
            filter: *const spa_pod,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Set a parameter on the node\n\n \\param id the parameter id to set\n \\param flags extra parameter flags\n \\param param the parameter to set\n\n This requires X and W permissions on the node."]
    pub set_param: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            id: u32,
            flags: u32,
            param: *const spa_pod,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Send a command to the node\n\n \\param command the command to send\n\n This requires X and W permissions on the node."]
    pub send_command: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            command: *const spa_command,
        ) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_node_methods"][::std::mem::size_of::<pw_node_methods>() - 48usize];
    ["Alignment of pw_node_methods"][::std::mem::align_of::<pw_node_methods>() - 8usize];
    ["Offset of field: pw_node_methods::version"]
        [::std::mem::offset_of!(pw_node_methods, version) - 0usize];
    ["Offset of field: pw_node_methods::add_listener"]
        [::std::mem::offset_of!(pw_node_methods, add_listener) - 8usize];
    ["Offset of field: pw_node_methods::subscribe_params"]
        [::std::mem::offset_of!(pw_node_methods, subscribe_params) - 16usize];
    ["Offset of field: pw_node_methods::enum_params"]
        [::std::mem::offset_of!(pw_node_methods, enum_params) - 24usize];
    ["Offset of field: pw_node_methods::set_param"]
        [::std::mem::offset_of!(pw_node_methods, set_param) - 32usize];
    ["Offset of field: pw_node_methods::send_command"]
        [::std::mem::offset_of!(pw_node_methods, send_command) - 40usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_port {
    _unused: [u8; 0],
}
unsafe extern "C" {
    #[doc = " Convert a \\ref pw_direction to a readable string"]
    pub fn pw_direction_as_string(direction: spa_direction) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_port_info {
    #[doc = "< id of the global"]
    pub id: u32,
    #[doc = "< port direction"]
    pub direction: spa_direction,
    #[doc = "< bitfield of changed fields since last call"]
    pub change_mask: u64,
    #[doc = "< the properties of the port"]
    pub props: *mut spa_dict,
    #[doc = "< parameters"]
    pub params: *mut spa_param_info,
    #[doc = "< number of items in \\a params"]
    pub n_params: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_port_info"][::std::mem::size_of::<pw_port_info>() - 40usize];
    ["Alignment of pw_port_info"][::std::mem::align_of::<pw_port_info>() - 8usize];
    ["Offset of field: pw_port_info::id"][::std::mem::offset_of!(pw_port_info, id) - 0usize];
    ["Offset of field: pw_port_info::direction"]
        [::std::mem::offset_of!(pw_port_info, direction) - 4usize];
    ["Offset of field: pw_port_info::change_mask"]
        [::std::mem::offset_of!(pw_port_info, change_mask) - 8usize];
    ["Offset of field: pw_port_info::props"][::std::mem::offset_of!(pw_port_info, props) - 16usize];
    ["Offset of field: pw_port_info::params"]
        [::std::mem::offset_of!(pw_port_info, params) - 24usize];
    ["Offset of field: pw_port_info::n_params"]
        [::std::mem::offset_of!(pw_port_info, n_params) - 32usize];
};
unsafe extern "C" {
    pub fn pw_port_info_update(
        info: *mut pw_port_info,
        update: *const pw_port_info,
    ) -> *mut pw_port_info;
}
unsafe extern "C" {
    pub fn pw_port_info_merge(
        info: *mut pw_port_info,
        update: *const pw_port_info,
        reset: bool,
    ) -> *mut pw_port_info;
}
unsafe extern "C" {
    pub fn pw_port_info_free(info: *mut pw_port_info);
}
#[doc = " Port events"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_port_events {
    pub version: u32,
    #[doc = " Notify port info\n\n \\param info info about the port"]
    pub info: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, info: *const pw_port_info),
    >,
    #[doc = " Notify a port param\n\n Event emitted as a result of the enum_params method.\n\n \\param seq the sequence number of the request\n \\param id the param id\n \\param index the param index\n \\param next the param index of the next param\n \\param param the parameter"]
    pub param: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            seq: ::std::os::raw::c_int,
            id: u32,
            index: u32,
            next: u32,
            param: *const spa_pod,
        ),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_port_events"][::std::mem::size_of::<pw_port_events>() - 24usize];
    ["Alignment of pw_port_events"][::std::mem::align_of::<pw_port_events>() - 8usize];
    ["Offset of field: pw_port_events::version"]
        [::std::mem::offset_of!(pw_port_events, version) - 0usize];
    ["Offset of field: pw_port_events::info"]
        [::std::mem::offset_of!(pw_port_events, info) - 8usize];
    ["Offset of field: pw_port_events::param"]
        [::std::mem::offset_of!(pw_port_events, param) - 16usize];
};
#[doc = " Port methods"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_port_methods {
    pub version: u32,
    pub add_listener: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            listener: *mut spa_hook,
            events: *const pw_port_events,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Subscribe to parameter changes\n\n Automatically emit param events for the given ids when\n they are changed.\n\n \\param ids an array of param ids\n \\param n_ids the number of ids in \\a ids\n\n This requires X permissions on the port."]
    pub subscribe_params: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            ids: *mut u32,
            n_ids: u32,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Enumerate port parameters\n\n Start enumeration of port parameters. For each param, a\n param event will be emitted.\n\n \\param seq a sequence number returned in the reply\n \\param id the parameter id to enumerate\n \\param start the start index or 0 for the first param\n \\param num the maximum number of params to retrieve\n \\param filter a param filter or NULL\n\n This requires X permissions on the port."]
    pub enum_params: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            seq: ::std::os::raw::c_int,
            id: u32,
            start: u32,
            num: u32,
            filter: *const spa_pod,
        ) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_port_methods"][::std::mem::size_of::<pw_port_methods>() - 32usize];
    ["Alignment of pw_port_methods"][::std::mem::align_of::<pw_port_methods>() - 8usize];
    ["Offset of field: pw_port_methods::version"]
        [::std::mem::offset_of!(pw_port_methods, version) - 0usize];
    ["Offset of field: pw_port_methods::add_listener"]
        [::std::mem::offset_of!(pw_port_methods, add_listener) - 8usize];
    ["Offset of field: pw_port_methods::subscribe_params"]
        [::std::mem::offset_of!(pw_port_methods, subscribe_params) - 16usize];
    ["Offset of field: pw_port_methods::enum_params"]
        [::std::mem::offset_of!(pw_port_methods, enum_params) - 24usize];
};
#[doc = " \\addtogroup pw_stream\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_stream {
    _unused: [u8; 0],
}
#[doc = "< the stream is in error"]
pub const pw_stream_state_PW_STREAM_STATE_ERROR: pw_stream_state = -1;
#[doc = "< unconnected"]
pub const pw_stream_state_PW_STREAM_STATE_UNCONNECTED: pw_stream_state = 0;
#[doc = "< connection is in progress"]
pub const pw_stream_state_PW_STREAM_STATE_CONNECTING: pw_stream_state = 1;
#[doc = "< paused"]
pub const pw_stream_state_PW_STREAM_STATE_PAUSED: pw_stream_state = 2;
#[doc = "< streaming"]
pub const pw_stream_state_PW_STREAM_STATE_STREAMING: pw_stream_state = 3;
#[doc = " \\enum pw_stream_state The state of a stream"]
pub type pw_stream_state = ::std::os::raw::c_int;
#[doc = " a buffer structure obtained from pw_stream_dequeue_buffer(). The size of this\n structure can grow as more fields are added in the future"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_buffer {
    #[doc = "< the spa buffer"]
    pub buffer: *mut spa_buffer,
    #[doc = "< user data attached to the buffer. The user of\n  the stream can set custom data associated with the\n  buffer, typically in the add_buffer event. Any\n  cleanup should be performed in the remove_buffer\n  event. The user data is returned unmodified each\n  time a buffer is dequeued."]
    pub user_data: *mut ::std::os::raw::c_void,
    #[doc = "< This field is set by the user and the sum of\n  all queued buffers is returned in the time info.\n  For audio, it is advised to use the number of\n  frames in the buffer for this field."]
    pub size: u64,
    #[doc = "< For playback streams, this field contains the\n  suggested amount of data to provide. For audio\n  streams this will be the amount of frames\n  required by the resampler. This field is 0\n  when no suggestion is provided. Since 0.3.49"]
    pub requested: u64,
    #[doc = "< For capture streams, this field contains the\n  cycle time in nanoseconds when this buffer was\n  queued in the stream. It can be compared against\n  the pw_time values or pw_stream_get_nsec()\n  Since 1.0.5"]
    pub time: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_buffer"][::std::mem::size_of::<pw_buffer>() - 40usize];
    ["Alignment of pw_buffer"][::std::mem::align_of::<pw_buffer>() - 8usize];
    ["Offset of field: pw_buffer::buffer"][::std::mem::offset_of!(pw_buffer, buffer) - 0usize];
    ["Offset of field: pw_buffer::user_data"]
        [::std::mem::offset_of!(pw_buffer, user_data) - 8usize];
    ["Offset of field: pw_buffer::size"][::std::mem::offset_of!(pw_buffer, size) - 16usize];
    ["Offset of field: pw_buffer::requested"]
        [::std::mem::offset_of!(pw_buffer, requested) - 24usize];
    ["Offset of field: pw_buffer::time"][::std::mem::offset_of!(pw_buffer, time) - 32usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_stream_control {
    #[doc = "< name of the control"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "< extra flags (unused)"]
    pub flags: u32,
    #[doc = "< default value"]
    pub def: f32,
    #[doc = "< min value"]
    pub min: f32,
    #[doc = "< max value"]
    pub max: f32,
    #[doc = "< array of values"]
    pub values: *mut f32,
    #[doc = "< number of values in array"]
    pub n_values: u32,
    #[doc = "< max values that can be set on this control"]
    pub max_values: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_stream_control"][::std::mem::size_of::<pw_stream_control>() - 40usize];
    ["Alignment of pw_stream_control"][::std::mem::align_of::<pw_stream_control>() - 8usize];
    ["Offset of field: pw_stream_control::name"]
        [::std::mem::offset_of!(pw_stream_control, name) - 0usize];
    ["Offset of field: pw_stream_control::flags"]
        [::std::mem::offset_of!(pw_stream_control, flags) - 8usize];
    ["Offset of field: pw_stream_control::def"]
        [::std::mem::offset_of!(pw_stream_control, def) - 12usize];
    ["Offset of field: pw_stream_control::min"]
        [::std::mem::offset_of!(pw_stream_control, min) - 16usize];
    ["Offset of field: pw_stream_control::max"]
        [::std::mem::offset_of!(pw_stream_control, max) - 20usize];
    ["Offset of field: pw_stream_control::values"]
        [::std::mem::offset_of!(pw_stream_control, values) - 24usize];
    ["Offset of field: pw_stream_control::n_values"]
        [::std::mem::offset_of!(pw_stream_control, n_values) - 32usize];
    ["Offset of field: pw_stream_control::max_values"]
        [::std::mem::offset_of!(pw_stream_control, max_values) - 36usize];
};
#[doc = " A time structure.\n\n Use pw_stream_get_time_n() to get an updated time snapshot of the stream.\n The time snapshot can give information about the time in the driver of the\n graph, the delay to the edge of the graph and the internal queuing in the\n stream.\n\n pw_time.ticks gives a monotonic increasing counter of the time in the graph\n driver. I can be used to generate a timetime to schedule samples as well\n as detect discontinuities in the timeline caused by xruns.\n\n pw_time.delay is expressed as pw_time.rate, the time domain of the graph. This\n value, and pw_time.ticks, were captured at pw_time.now and can be extrapolated\n to the current time like this:\n\n\\code{.c}\n    uint64_t now = pw_stream_get_nsec(stream);\n    int64_t diff = now - pw_time.now;\n    int64_t elapsed = (pw_time.rate.denom * diff) / (pw_time.rate.num * SPA_NSEC_PER_SEC);\n\\endcode\n\n pw_time.delay contains the total delay that a signal will travel through the\n graph. This includes the delay caused by filters in the graph as well as delays\n caused by the hardware. The delay is usually quite stable and should only change when\n the topology, quantum or samplerate of the graph changes.\n\n The delay requires the application to send the stream early relative to other synchronized\n streams in order to arrive at the edge of the graph in time. This is usually done by\n delaying the other streams with the given delay.\n\n Note that the delay can be negative. A negative delay means that this stream should be\n delayed with the (positive) delay relative to other streams.\n\n pw_time.queued and pw_time.buffered is expressed in the time domain of the stream,\n or the format that is used for the buffers of this stream.\n\n pw_time.queued is the sum of all the pw_buffer.size fields of the buffers that are\n currently queued in the stream but not yet processed. The application can choose\n the units of this value, for example, time, samples, frames or bytes (below\n expressed as app.rate).\n\n pw_time.buffered is format dependent, for audio/raw it contains the number of frames\n that are buffered inside the resampler/converter.\n\n The total delay of data in a stream is the sum of the queued and buffered data\n (not yet processed data) and the delay to the edge of the graph, usually a\n playback or capture device.\n\n For an audio playback stream, if you were to queue a buffer, the total delay\n in milliseconds for the first sample in the newly queued buffer to be played\n by the hardware can be calculated as:\n\n\\code{.unparsed}\n  (pw_time.buffered * 1000 / stream.samplerate) +\n    (pw_time.queued * 1000 / app.rate) +\n     ((pw_time.delay - elapsed) * 1000 * pw_time.rate.num / pw_time.rate.denom)\n\\endcode\n\n The current extrapolated time (in ms) in the source or sink can be calculated as:\n\n\\code{.unparsed}\n  (pw_time.ticks + elapsed) * 1000 * pw_time.rate.num / pw_time.rate.denom\n\\endcode\n\n Below is an overview of the different timing values:\n\n\\code{.unparsed}\n           stream time domain           graph time domain\n         /-----------------------\\/-----------------------------\\\n\n queue     +-+ +-+  +-----------+                 +--------+\n ---->     | | | |->| converter | ->   graph  ->  | kernel | -> speaker\n <----     +-+ +-+  +-----------+                 +--------+\n dequeue   buffers                \\-------------------/\\--------/\n                                     graph              internal\n                                    latency             latency\n         \\--------/\\-------------/\\-----------------------------/\n           queued      buffered            delay\n\\endcode"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_time {
    #[doc = "< the time in nanoseconds. This is the time when this\n  time report was updated. It is usually updated every\n  graph cycle. You can use pw_stream_get_nsec() to\n  calculate the elapsed time between this report and\n  the current time and calculate updated ticks and delay\n  values."]
    pub now: i64,
    #[doc = "< the rate of \\a ticks and delay. This is usually\n  expressed in 1/<samplerate>."]
    pub rate: spa_fraction,
    #[doc = "< the ticks at \\a now. This is the current time that\n  the remote end is reading/writing. This is monotonicaly\n  increasing."]
    pub ticks: u64,
    #[doc = "< delay to device. This is the time it will take for\n  the next output sample of the stream to be presented by\n  the playback device or the time a sample traveled\n  from the capture device. This delay includes the\n  delay introduced by all filters on the path between\n  the stream and the device. The delay is normally\n  constant in a graph and can change when the topology\n  of the graph or the quantum changes. This delay does\n  not include the delay caused by queued buffers."]
    pub delay: i64,
    #[doc = "< data queued in the stream, this is the sum\n  of the size fields in the pw_buffer that are\n  currently queued"]
    pub queued: u64,
    #[doc = "< for audio/raw streams, this contains the extra\n  number of frames buffered in the resampler.\n  Since 0.3.50."]
    pub buffered: u64,
    #[doc = "< the number of buffers that are queued. Since 0.3.50"]
    pub queued_buffers: u32,
    #[doc = "< the number of buffers that can be dequeued. Since 0.3.50"]
    pub avail_buffers: u32,
    #[doc = "< for audio/raw playback streams, this contains the number of\n  samples requested by the resampler for the current\n  quantum. for audio/raw capture streams this will be the number\n  of samples available for the current quantum. Since 1.1.0"]
    pub size: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_time"][::std::mem::size_of::<pw_time>() - 64usize];
    ["Alignment of pw_time"][::std::mem::align_of::<pw_time>() - 8usize];
    ["Offset of field: pw_time::now"][::std::mem::offset_of!(pw_time, now) - 0usize];
    ["Offset of field: pw_time::rate"][::std::mem::offset_of!(pw_time, rate) - 8usize];
    ["Offset of field: pw_time::ticks"][::std::mem::offset_of!(pw_time, ticks) - 16usize];
    ["Offset of field: pw_time::delay"][::std::mem::offset_of!(pw_time, delay) - 24usize];
    ["Offset of field: pw_time::queued"][::std::mem::offset_of!(pw_time, queued) - 32usize];
    ["Offset of field: pw_time::buffered"][::std::mem::offset_of!(pw_time, buffered) - 40usize];
    ["Offset of field: pw_time::queued_buffers"]
        [::std::mem::offset_of!(pw_time, queued_buffers) - 48usize];
    ["Offset of field: pw_time::avail_buffers"]
        [::std::mem::offset_of!(pw_time, avail_buffers) - 52usize];
    ["Offset of field: pw_time::size"][::std::mem::offset_of!(pw_time, size) - 56usize];
};
#[doc = " Events for a stream. These events are always called from the mainloop\n unless explicitly documented otherwise."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_stream_events {
    pub version: u32,
    pub destroy: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " when the stream state changes. Since 1.4 this also sets errno when the\n new state is PW_STREAM_STATE_ERROR"]
    pub state_changed: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            old: pw_stream_state,
            state: pw_stream_state,
            error: *const ::std::os::raw::c_char,
        ),
    >,
    #[doc = " Notify information about a control."]
    pub control_info: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            id: u32,
            control: *const pw_stream_control,
        ),
    >,
    #[doc = " when io changed on the stream."]
    pub io_changed: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            id: u32,
            area: *mut ::std::os::raw::c_void,
            size: u32,
        ),
    >,
    #[doc = " when a parameter changed"]
    pub param_changed: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, id: u32, param: *const spa_pod),
    >,
    #[doc = " when a new buffer was created for this stream"]
    pub add_buffer: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, buffer: *mut pw_buffer),
    >,
    #[doc = " when a buffer was destroyed for this stream"]
    pub remove_buffer: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, buffer: *mut pw_buffer),
    >,
    #[doc = " when a buffer can be queued (for playback streams) or\n  dequeued (for capture streams). This is normally called from the\n  mainloop but can also be called directly from the realtime data\n  thread if the user is prepared to deal with this."]
    pub process: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " The stream is drained"]
    pub drained: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " A command notify, Since 0.3.39:1"]
    pub command: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, command: *const spa_command),
    >,
    #[doc = " a trigger_process completed. Since version 0.3.40:2.\n  This is normally called from the mainloop but since 1.1.0 it\n  can also be called directly from the realtime data\n  thread if the user is prepared to deal with this."]
    pub trigger_done:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_stream_events"][::std::mem::size_of::<pw_stream_events>() - 96usize];
    ["Alignment of pw_stream_events"][::std::mem::align_of::<pw_stream_events>() - 8usize];
    ["Offset of field: pw_stream_events::version"]
        [::std::mem::offset_of!(pw_stream_events, version) - 0usize];
    ["Offset of field: pw_stream_events::destroy"]
        [::std::mem::offset_of!(pw_stream_events, destroy) - 8usize];
    ["Offset of field: pw_stream_events::state_changed"]
        [::std::mem::offset_of!(pw_stream_events, state_changed) - 16usize];
    ["Offset of field: pw_stream_events::control_info"]
        [::std::mem::offset_of!(pw_stream_events, control_info) - 24usize];
    ["Offset of field: pw_stream_events::io_changed"]
        [::std::mem::offset_of!(pw_stream_events, io_changed) - 32usize];
    ["Offset of field: pw_stream_events::param_changed"]
        [::std::mem::offset_of!(pw_stream_events, param_changed) - 40usize];
    ["Offset of field: pw_stream_events::add_buffer"]
        [::std::mem::offset_of!(pw_stream_events, add_buffer) - 48usize];
    ["Offset of field: pw_stream_events::remove_buffer"]
        [::std::mem::offset_of!(pw_stream_events, remove_buffer) - 56usize];
    ["Offset of field: pw_stream_events::process"]
        [::std::mem::offset_of!(pw_stream_events, process) - 64usize];
    ["Offset of field: pw_stream_events::drained"]
        [::std::mem::offset_of!(pw_stream_events, drained) - 72usize];
    ["Offset of field: pw_stream_events::command"]
        [::std::mem::offset_of!(pw_stream_events, command) - 80usize];
    ["Offset of field: pw_stream_events::trigger_done"]
        [::std::mem::offset_of!(pw_stream_events, trigger_done) - 88usize];
};
unsafe extern "C" {
    #[doc = " Convert a stream state to a readable string"]
    pub fn pw_stream_state_as_string(state: pw_stream_state) -> *const ::std::os::raw::c_char;
}
#[doc = "< no flags"]
pub const pw_stream_flags_PW_STREAM_FLAG_NONE: pw_stream_flags = 0;
#[doc = "< try to automatically connect\n  this stream"]
pub const pw_stream_flags_PW_STREAM_FLAG_AUTOCONNECT: pw_stream_flags = 1;
#[doc = "< start the stream inactive,\n  pw_stream_set_active() needs to be\n  called explicitly"]
pub const pw_stream_flags_PW_STREAM_FLAG_INACTIVE: pw_stream_flags = 2;
#[doc = "< mmap the buffers except DmaBuf that is not\n  explicitly marked as mappable."]
pub const pw_stream_flags_PW_STREAM_FLAG_MAP_BUFFERS: pw_stream_flags = 4;
#[doc = "< be a driver"]
pub const pw_stream_flags_PW_STREAM_FLAG_DRIVER: pw_stream_flags = 8;
#[doc = "< call process from the realtime\n  thread. You MUST use RT safe functions\n  in the process callback."]
pub const pw_stream_flags_PW_STREAM_FLAG_RT_PROCESS: pw_stream_flags = 16;
#[doc = "< don't convert format"]
pub const pw_stream_flags_PW_STREAM_FLAG_NO_CONVERT: pw_stream_flags = 32;
#[doc = "< require exclusive access to the\n  device"]
pub const pw_stream_flags_PW_STREAM_FLAG_EXCLUSIVE: pw_stream_flags = 64;
#[doc = "< don't try to reconnect this stream\n  when the sink/source is removed"]
pub const pw_stream_flags_PW_STREAM_FLAG_DONT_RECONNECT: pw_stream_flags = 128;
#[doc = "< the application will allocate buffer\n  memory. In the add_buffer event, the\n  data of the buffer should be set"]
pub const pw_stream_flags_PW_STREAM_FLAG_ALLOC_BUFFERS: pw_stream_flags = 256;
#[doc = "< the output stream will not be scheduled\n  automatically but _trigger_process()\n  needs to be called. This can be used\n  when the output of the stream depends\n  on input from other streams."]
pub const pw_stream_flags_PW_STREAM_FLAG_TRIGGER: pw_stream_flags = 512;
#[doc = "< Buffers will not be dequeued/queued from\n  the realtime process() function. This is\n  assumed when RT_PROCESS is unset but can\n  also be the case when the process() function\n  does a trigger_process() that will then\n  dequeue/queue a buffer from another process()\n  function. since 0.3.73"]
pub const pw_stream_flags_PW_STREAM_FLAG_ASYNC: pw_stream_flags = 1024;
#[doc = "< Call process as soon as there is a buffer\n  to dequeue. This is only relevant for\n  playback and when not using RT_PROCESS. It\n  can be used to keep the maximum number of\n  buffers queued. Since 0.3.81"]
pub const pw_stream_flags_PW_STREAM_FLAG_EARLY_PROCESS: pw_stream_flags = 2048;
#[doc = "< Call trigger_done from the realtime\n  thread. You MUST use RT safe functions\n  in the trigger_done callback. Since 1.1.0"]
pub const pw_stream_flags_PW_STREAM_FLAG_RT_TRIGGER_DONE: pw_stream_flags = 4096;
#[doc = " \\enum pw_stream_flags Extra flags that can be used in \\ref pw_stream_connect()"]
pub type pw_stream_flags = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " Create a new unconnected \\ref pw_stream\n \\return a newly allocated \\ref pw_stream"]
    pub fn pw_stream_new(
        core: *mut pw_core,
        name: *const ::std::os::raw::c_char,
        props: *mut pw_properties,
    ) -> *mut pw_stream;
}
unsafe extern "C" {
    pub fn pw_stream_new_simple(
        loop_: *mut pw_loop,
        name: *const ::std::os::raw::c_char,
        props: *mut pw_properties,
        events: *const pw_stream_events,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut pw_stream;
}
unsafe extern "C" {
    #[doc = " Destroy a stream"]
    pub fn pw_stream_destroy(stream: *mut pw_stream);
}
unsafe extern "C" {
    pub fn pw_stream_add_listener(
        stream: *mut pw_stream,
        listener: *mut spa_hook,
        events: *const pw_stream_events,
        data: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = " Get the current stream state. Since 1.4 this also sets errno when the\n state is PW_STREAM_STATE_ERROR"]
    pub fn pw_stream_get_state(
        stream: *mut pw_stream,
        error: *mut *const ::std::os::raw::c_char,
    ) -> pw_stream_state;
}
unsafe extern "C" {
    pub fn pw_stream_get_name(stream: *mut pw_stream) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn pw_stream_get_core(stream: *mut pw_stream) -> *mut pw_core;
}
unsafe extern "C" {
    pub fn pw_stream_get_properties(stream: *mut pw_stream) -> *const pw_properties;
}
unsafe extern "C" {
    pub fn pw_stream_update_properties(
        stream: *mut pw_stream,
        dict: *const spa_dict,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Connect a stream for input or output on \\a port_path.\n \\return 0 on success < 0 on error.\n\n You should connect to the process event and use pw_stream_dequeue_buffer()\n to get the latest metadata and data."]
    pub fn pw_stream_connect(
        stream: *mut pw_stream,
        direction: spa_direction,
        target_id: u32,
        flags: pw_stream_flags,
        params: *mut *const spa_pod,
        n_params: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the node ID of the stream.\n \\return node ID."]
    pub fn pw_stream_get_node_id(stream: *mut pw_stream) -> u32;
}
unsafe extern "C" {
    #[doc = " Disconnect \\a stream"]
    pub fn pw_stream_disconnect(stream: *mut pw_stream) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Set the stream in error state"]
    pub fn pw_stream_set_error(
        stream: *mut pw_stream,
        res: ::std::os::raw::c_int,
        error: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Update the param exposed on the stream."]
    pub fn pw_stream_update_params(
        stream: *mut pw_stream,
        params: *mut *const spa_pod,
        n_params: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Set a parameter on the stream. This is like pw_stream_set_control() but with\n a complete spa_pod param. It can also be called from the param_changed event handler\n to intercept and modify the param for the adapter. Since 0.3.70"]
    pub fn pw_stream_set_param(
        stream: *mut pw_stream,
        id: u32,
        param: *const spa_pod,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get control values"]
    pub fn pw_stream_get_control(stream: *mut pw_stream, id: u32) -> *const pw_stream_control;
}
unsafe extern "C" {
    #[doc = " Set control values"]
    pub fn pw_stream_set_control(
        stream: *mut pw_stream,
        id: u32,
        n_values: u32,
        values: *mut f32,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Query the time on the stream, RT safe"]
    pub fn pw_stream_get_time_n(
        stream: *mut pw_stream,
        time: *mut pw_time,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the current time in nanoseconds. This value can be compared with\n the \\ref pw_time.now value. RT safe. Since 1.1.0"]
    pub fn pw_stream_get_nsec(stream: *mut pw_stream) -> u64;
}
unsafe extern "C" {
    #[doc = " Get the data loop that is doing the processing of this stream. This loop\n is assigned after pw_stream_connect().  * Since 1.1.0"]
    pub fn pw_stream_get_data_loop(stream: *mut pw_stream) -> *mut pw_loop;
}
unsafe extern "C" {
    #[doc = " Query the time on the stream, deprecated since 0.3.50,\n use pw_stream_get_time_n() to get the fields added since 0.3.50. RT safe."]
    pub fn pw_stream_get_time(stream: *mut pw_stream, time: *mut pw_time) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get a buffer that can be filled for playback streams or consumed\n for capture streams. RT safe."]
    pub fn pw_stream_dequeue_buffer(stream: *mut pw_stream) -> *mut pw_buffer;
}
unsafe extern "C" {
    #[doc = " Submit a buffer for playback or recycle a buffer for capture. RT safe."]
    pub fn pw_stream_queue_buffer(
        stream: *mut pw_stream,
        buffer: *mut pw_buffer,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Return a buffer to the queue without using it. This makes the buffer\n immediately available to dequeue again. RT safe."]
    pub fn pw_stream_return_buffer(
        stream: *mut pw_stream,
        buffer: *mut pw_buffer,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Activate or deactivate the stream"]
    pub fn pw_stream_set_active(stream: *mut pw_stream, active: bool) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Flush a stream. When \\a drain is true, the drained callback will\n be called when all data is played or recorded. The stream can be resumed\n after the drain by setting it active again with\n \\ref pw_stream_set_active(). A flush without a drain is mostly useful afer\n a state change to PAUSED, to flush any remaining data from the queues and\n the converters. RT safe."]
    pub fn pw_stream_flush(stream: *mut pw_stream, drain: bool) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Check if the stream is driving. The stream needs to have the\n PW_STREAM_FLAG_DRIVER set. When the stream is driving,\n pw_stream_trigger_process() needs to be called when data is\n available (output) or needed (input). Since 0.3.34"]
    pub fn pw_stream_is_driving(stream: *mut pw_stream) -> bool;
}
unsafe extern "C" {
    #[doc = " Check if the graph is using lazy scheduling. If the stream is\n driving according to \\ref pw_stream_is_driving(), then it should\n consider taking into account the RequestProcess commands when\n driving the graph.\n\n If the stream is not driving, it should send out RequestProcess\n events with \\ref pw_stream_emit_event() or indirectly with\n \\ref pw_stream_trigger_process() to suggest a new graph cycle\n to the driver.\n\n It is not a requirement that all RequestProcess events/commands\n need to start a graph cycle.\n Since 1.4.0"]
    pub fn pw_stream_is_lazy(stream: *mut pw_stream) -> bool;
}
unsafe extern "C" {
    #[doc = " Trigger a push/pull on the stream. One iteration of the graph will\n be scheduled when the stream is driving according to\n \\ref pw_stream_is_driving(). If it successfully finishes, process()\n will be called and the trigger_done event will be emitted. It is\n possible for the graph iteration to not finish, so\n pw_stream_trigger_process() needs to be called again even if process()\n and trigger_done is not called.\n\n If there is a deadline after which the stream will have xrun,\n pw_stream_trigger_process() should be called then, whether or not\n process()/trigger_done has been called. Sound hardware will xrun if\n there is any delay in audio processing, so the ALSA plugin triggers the\n graph every quantum to ensure audio keeps flowing. Drivers that\n do not have a deadline, such as the freewheel driver, should\n use a timeout to ensure that forward progress keeps being made.\n A reasonable choice of deadline is three times the quantum: if\n the graph is taking 3x longer than normal, it is likely that it\n is hung and should be retriggered.\n\n Streams that are not drivers according to \\ref pw_stream_is_driving()\n can also call this method. The result is that a RequestProcess event\n is sent to the driver. If the graph is lazy scheduling according to\n \\ref pw_stream_is_lazy(), this might result in a graph cycle by the\n driver. If the graph is not lazy scheduling and the stream is not a\n driver, this method will have no effect.\n\n RT safe.\n\n Since 0.3.34"]
    pub fn pw_stream_trigger_process(stream: *mut pw_stream) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Emit an event from this stream. RT safe.\n Since 1.2.6"]
    pub fn pw_stream_emit_event(
        stream: *mut pw_stream,
        event: *const spa_event,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Adjust the rate of the stream.\n When the stream is using an adaptive resampler, adjust the resampler rate.\n When there is no resampler, -ENOTSUP is returned. Activating the adaptive\n resampler will add a small amount of delay to the samples, you can deactivate\n it again by setting a value <= 0.0. RT safe.\n Since 1.4.0"]
    pub fn pw_stream_set_rate(stream: *mut pw_stream, rate: f64) -> ::std::os::raw::c_int;
}
#[doc = " \\addtogroup pw_filter\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_filter {
    _unused: [u8; 0],
}
pub const spa_io_type_SPA_IO_Invalid: spa_io_type = 0;
#[doc = "< area to exchange buffers, struct spa_io_buffers"]
pub const spa_io_type_SPA_IO_Buffers: spa_io_type = 1;
#[doc = "< expected byte range, struct spa_io_range (currently not used in PipeWire)"]
pub const spa_io_type_SPA_IO_Range: spa_io_type = 2;
#[doc = "< area to update clock information, struct spa_io_clock"]
pub const spa_io_type_SPA_IO_Clock: spa_io_type = 3;
#[doc = "< latency reporting, struct spa_io_latency (currently not used in\n PipeWire). \\see spa_param_latency"]
pub const spa_io_type_SPA_IO_Latency: spa_io_type = 4;
#[doc = "< area for control messages, struct spa_io_sequence"]
pub const spa_io_type_SPA_IO_Control: spa_io_type = 5;
#[doc = "< area for notify messages, struct spa_io_sequence"]
pub const spa_io_type_SPA_IO_Notify: spa_io_type = 6;
#[doc = "< position information in the graph, struct spa_io_position"]
pub const spa_io_type_SPA_IO_Position: spa_io_type = 7;
#[doc = "< rate matching between nodes, struct spa_io_rate_match"]
pub const spa_io_type_SPA_IO_RateMatch: spa_io_type = 8;
#[doc = "< memory pointer, struct spa_io_memory (currently not used in PipeWire)"]
pub const spa_io_type_SPA_IO_Memory: spa_io_type = 9;
#[doc = "< async area to exchange buffers, struct spa_io_async_buffers"]
pub const spa_io_type_SPA_IO_AsyncBuffers: spa_io_type = 10;
#[doc = " Different IO area types"]
pub type spa_io_type = ::std::os::raw::c_uint;
#[doc = " IO area to exchange buffers.\n\n A set of buffers should first be configured on the node/port.\n Further references to those buffers will be made by using the\n id of the buffer.\n\n If status is SPA_STATUS_OK, the host should ignore\n the io area.\n\n If status is SPA_STATUS_NEED_DATA, the host should:\n 1) recycle the buffer in buffer_id, if possible\n 2) prepare a new buffer and place the id in buffer_id.\n\n If status is SPA_STATUS_HAVE_DATA, the host should consume\n the buffer in buffer_id and set the state to\n SPA_STATUS_NEED_DATA when new data is requested.\n\n If status is SPA_STATUS_STOPPED, some error occurred on the\n port.\n\n If status is SPA_STATUS_DRAINED, data from the io area was\n used to drain.\n\n Status can also be a negative errno value to indicate errors.\n such as:\n -EINVAL: buffer_id is invalid\n -EPIPE: no more buffers available"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_io_buffers {
    #[doc = "< the status code"]
    pub status: i32,
    #[doc = "< a buffer id"]
    pub buffer_id: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_io_buffers"][::std::mem::size_of::<spa_io_buffers>() - 8usize];
    ["Alignment of spa_io_buffers"][::std::mem::align_of::<spa_io_buffers>() - 4usize];
    ["Offset of field: spa_io_buffers::status"]
        [::std::mem::offset_of!(spa_io_buffers, status) - 0usize];
    ["Offset of field: spa_io_buffers::buffer_id"]
        [::std::mem::offset_of!(spa_io_buffers, buffer_id) - 4usize];
};
#[doc = " IO area to exchange a memory region"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_io_memory {
    #[doc = "< the status code"]
    pub status: i32,
    #[doc = "< the size of \\a data"]
    pub size: u32,
    #[doc = "< a memory pointer"]
    pub data: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_io_memory"][::std::mem::size_of::<spa_io_memory>() - 16usize];
    ["Alignment of spa_io_memory"][::std::mem::align_of::<spa_io_memory>() - 8usize];
    ["Offset of field: spa_io_memory::status"]
        [::std::mem::offset_of!(spa_io_memory, status) - 0usize];
    ["Offset of field: spa_io_memory::size"][::std::mem::offset_of!(spa_io_memory, size) - 4usize];
    ["Offset of field: spa_io_memory::data"][::std::mem::offset_of!(spa_io_memory, data) - 8usize];
};
#[doc = " A range, suitable for input ports that can suggest a range to output ports"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_io_range {
    #[doc = "< offset in range"]
    pub offset: u64,
    #[doc = "< minimum size of data"]
    pub min_size: u32,
    #[doc = "< maximum size of data"]
    pub max_size: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_io_range"][::std::mem::size_of::<spa_io_range>() - 16usize];
    ["Alignment of spa_io_range"][::std::mem::align_of::<spa_io_range>() - 8usize];
    ["Offset of field: spa_io_range::offset"]
        [::std::mem::offset_of!(spa_io_range, offset) - 0usize];
    ["Offset of field: spa_io_range::min_size"]
        [::std::mem::offset_of!(spa_io_range, min_size) - 8usize];
    ["Offset of field: spa_io_range::max_size"]
        [::std::mem::offset_of!(spa_io_range, max_size) - 12usize];
};
#[doc = " Absolute time reporting.\n\n Nodes that can report clocking information will receive this io block.\n The application sets the id. This is usually set as part of the\n position information but can also be set separately.\n\n The clock counts the elapsed time according to the clock provider\n since the provider was last started.\n\n Driver nodes are supposed to update the contents of \\ref SPA_IO_Clock before\n signaling the start of a graph cycle.  These updated clock values become\n visible to other nodes in \\ref SPA_IO_Position. Non-driver nodes do\n not need to update the contents of their \\ref SPA_IO_Clock.\n\n The host generally gives each node a separate \\ref spa_io_clock in \\ref\n SPA_IO_Clock, so that updates made by the driver are not visible in the\n contents of \\ref SPA_IO_Clock of other nodes. Instead, \\ref SPA_IO_Position\n is used to look up the current graph time.\n\n A node is a driver when \\ref spa_io_clock.id in \\ref SPA_IO_Clock and\n \\ref spa_io_position.clock.id in \\ref SPA_IO_Position are the same."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_io_clock {
    #[doc = "< Clock flags"]
    pub flags: u32,
    #[doc = "< Unique clock id, set by host application"]
    pub id: u32,
    #[doc = "< Clock name prefixed with API, set by node when it receives\n  \\ref SPA_IO_Clock. The clock name is unique per clock and\n  can be used to check if nodes share the same clock."]
    pub name: [::std::os::raw::c_char; 64usize],
    #[doc = "< Time in nanoseconds against monotonic clock\n (CLOCK_MONOTONIC). This fields reflects a real time instant\n in the past. The value may have jitter."]
    pub nsec: u64,
    #[doc = "< Rate for position/duration/delay/xrun"]
    pub rate: spa_fraction,
    #[doc = "< Current position, in samples @ \\ref rate"]
    pub position: u64,
    #[doc = "< Duration of current cycle, in samples @ \\ref rate"]
    pub duration: u64,
    #[doc = "< Delay between position and hardware, in samples @ \\ref rate"]
    pub delay: i64,
    #[doc = "< Rate difference between clock and monotonic time, as a ratio of\n  clock speeds."]
    pub rate_diff: f64,
    #[doc = "< Estimated next wakeup time in nanoseconds.\n  This time is a logical start time of the next cycle, and\n  is not necessarily in the future."]
    pub next_nsec: u64,
    #[doc = "< Target rate of next cycle"]
    pub target_rate: spa_fraction,
    #[doc = "< Target duration of next cycle"]
    pub target_duration: u64,
    #[doc = "< Seq counter. must be equal at start and\n  end of read and lower bit must be 0"]
    pub target_seq: u32,
    #[doc = "< incremented each time the graph is started"]
    pub cycle: u32,
    #[doc = "< Estimated accumulated xrun duration"]
    pub xrun: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_io_clock"][::std::mem::size_of::<spa_io_clock>() - 160usize];
    ["Alignment of spa_io_clock"][::std::mem::align_of::<spa_io_clock>() - 8usize];
    ["Offset of field: spa_io_clock::flags"][::std::mem::offset_of!(spa_io_clock, flags) - 0usize];
    ["Offset of field: spa_io_clock::id"][::std::mem::offset_of!(spa_io_clock, id) - 4usize];
    ["Offset of field: spa_io_clock::name"][::std::mem::offset_of!(spa_io_clock, name) - 8usize];
    ["Offset of field: spa_io_clock::nsec"][::std::mem::offset_of!(spa_io_clock, nsec) - 72usize];
    ["Offset of field: spa_io_clock::rate"][::std::mem::offset_of!(spa_io_clock, rate) - 80usize];
    ["Offset of field: spa_io_clock::position"]
        [::std::mem::offset_of!(spa_io_clock, position) - 88usize];
    ["Offset of field: spa_io_clock::duration"]
        [::std::mem::offset_of!(spa_io_clock, duration) - 96usize];
    ["Offset of field: spa_io_clock::delay"]
        [::std::mem::offset_of!(spa_io_clock, delay) - 104usize];
    ["Offset of field: spa_io_clock::rate_diff"]
        [::std::mem::offset_of!(spa_io_clock, rate_diff) - 112usize];
    ["Offset of field: spa_io_clock::next_nsec"]
        [::std::mem::offset_of!(spa_io_clock, next_nsec) - 120usize];
    ["Offset of field: spa_io_clock::target_rate"]
        [::std::mem::offset_of!(spa_io_clock, target_rate) - 128usize];
    ["Offset of field: spa_io_clock::target_duration"]
        [::std::mem::offset_of!(spa_io_clock, target_duration) - 136usize];
    ["Offset of field: spa_io_clock::target_seq"]
        [::std::mem::offset_of!(spa_io_clock, target_seq) - 144usize];
    ["Offset of field: spa_io_clock::cycle"]
        [::std::mem::offset_of!(spa_io_clock, cycle) - 148usize];
    ["Offset of field: spa_io_clock::xrun"][::std::mem::offset_of!(spa_io_clock, xrun) - 152usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_io_video_size {
    #[doc = "< optional flags"]
    pub flags: u32,
    #[doc = "< video stride in bytes"]
    pub stride: u32,
    #[doc = "< the video size"]
    pub size: spa_rectangle,
    #[doc = "< the minimum framerate, the cycle duration is\n  always smaller to ensure there is only one\n  video frame per cycle."]
    pub framerate: spa_fraction,
    pub padding: [u32; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_io_video_size"][::std::mem::size_of::<spa_io_video_size>() - 40usize];
    ["Alignment of spa_io_video_size"][::std::mem::align_of::<spa_io_video_size>() - 4usize];
    ["Offset of field: spa_io_video_size::flags"]
        [::std::mem::offset_of!(spa_io_video_size, flags) - 0usize];
    ["Offset of field: spa_io_video_size::stride"]
        [::std::mem::offset_of!(spa_io_video_size, stride) - 4usize];
    ["Offset of field: spa_io_video_size::size"]
        [::std::mem::offset_of!(spa_io_video_size, size) - 8usize];
    ["Offset of field: spa_io_video_size::framerate"]
        [::std::mem::offset_of!(spa_io_video_size, framerate) - 16usize];
    ["Offset of field: spa_io_video_size::padding"]
        [::std::mem::offset_of!(spa_io_video_size, padding) - 24usize];
};
#[doc = " Latency reporting\n\n Currently not used in PipeWire. Instead, \\see spa_param_latency"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_io_latency {
    #[doc = "< rate for min/max"]
    pub rate: spa_fraction,
    #[doc = "< min latency"]
    pub min: u64,
    #[doc = "< max latency"]
    pub max: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_io_latency"][::std::mem::size_of::<spa_io_latency>() - 24usize];
    ["Alignment of spa_io_latency"][::std::mem::align_of::<spa_io_latency>() - 8usize];
    ["Offset of field: spa_io_latency::rate"]
        [::std::mem::offset_of!(spa_io_latency, rate) - 0usize];
    ["Offset of field: spa_io_latency::min"][::std::mem::offset_of!(spa_io_latency, min) - 8usize];
    ["Offset of field: spa_io_latency::max"][::std::mem::offset_of!(spa_io_latency, max) - 16usize];
};
#[doc = " control stream, io area for SPA_IO_Control and SPA_IO_Notify"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_io_sequence {
    #[doc = "< sequence of timed events"]
    pub sequence: spa_pod_sequence,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_io_sequence"][::std::mem::size_of::<spa_io_sequence>() - 16usize];
    ["Alignment of spa_io_sequence"][::std::mem::align_of::<spa_io_sequence>() - 4usize];
    ["Offset of field: spa_io_sequence::sequence"]
        [::std::mem::offset_of!(spa_io_sequence, sequence) - 0usize];
};
#[doc = " bar and beat segment"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_io_segment_bar {
    #[doc = "< extra flags"]
    pub flags: u32,
    #[doc = "< offset in segment of this beat"]
    pub offset: u32,
    #[doc = "< time signature numerator"]
    pub signature_num: f32,
    #[doc = "< time signature denominator"]
    pub signature_denom: f32,
    #[doc = "< beats per minute"]
    pub bpm: f64,
    #[doc = "< current beat in segment"]
    pub beat: f64,
    pub bar_start_tick: f64,
    pub ticks_per_beat: f64,
    pub padding: [u32; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_io_segment_bar"][::std::mem::size_of::<spa_io_segment_bar>() - 64usize];
    ["Alignment of spa_io_segment_bar"][::std::mem::align_of::<spa_io_segment_bar>() - 8usize];
    ["Offset of field: spa_io_segment_bar::flags"]
        [::std::mem::offset_of!(spa_io_segment_bar, flags) - 0usize];
    ["Offset of field: spa_io_segment_bar::offset"]
        [::std::mem::offset_of!(spa_io_segment_bar, offset) - 4usize];
    ["Offset of field: spa_io_segment_bar::signature_num"]
        [::std::mem::offset_of!(spa_io_segment_bar, signature_num) - 8usize];
    ["Offset of field: spa_io_segment_bar::signature_denom"]
        [::std::mem::offset_of!(spa_io_segment_bar, signature_denom) - 12usize];
    ["Offset of field: spa_io_segment_bar::bpm"]
        [::std::mem::offset_of!(spa_io_segment_bar, bpm) - 16usize];
    ["Offset of field: spa_io_segment_bar::beat"]
        [::std::mem::offset_of!(spa_io_segment_bar, beat) - 24usize];
    ["Offset of field: spa_io_segment_bar::bar_start_tick"]
        [::std::mem::offset_of!(spa_io_segment_bar, bar_start_tick) - 32usize];
    ["Offset of field: spa_io_segment_bar::ticks_per_beat"]
        [::std::mem::offset_of!(spa_io_segment_bar, ticks_per_beat) - 40usize];
    ["Offset of field: spa_io_segment_bar::padding"]
        [::std::mem::offset_of!(spa_io_segment_bar, padding) - 48usize];
};
#[doc = " video frame segment"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_io_segment_video {
    #[doc = "< flags"]
    pub flags: u32,
    #[doc = "< offset in segment"]
    pub offset: u32,
    pub framerate: spa_fraction,
    pub hours: u32,
    pub minutes: u32,
    pub seconds: u32,
    pub frames: u32,
    #[doc = "< 0 for progressive, 1 and 2 for interlaced"]
    pub field_count: u32,
    pub padding: [u32; 11usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_io_segment_video"][::std::mem::size_of::<spa_io_segment_video>() - 80usize];
    ["Alignment of spa_io_segment_video"][::std::mem::align_of::<spa_io_segment_video>() - 4usize];
    ["Offset of field: spa_io_segment_video::flags"]
        [::std::mem::offset_of!(spa_io_segment_video, flags) - 0usize];
    ["Offset of field: spa_io_segment_video::offset"]
        [::std::mem::offset_of!(spa_io_segment_video, offset) - 4usize];
    ["Offset of field: spa_io_segment_video::framerate"]
        [::std::mem::offset_of!(spa_io_segment_video, framerate) - 8usize];
    ["Offset of field: spa_io_segment_video::hours"]
        [::std::mem::offset_of!(spa_io_segment_video, hours) - 16usize];
    ["Offset of field: spa_io_segment_video::minutes"]
        [::std::mem::offset_of!(spa_io_segment_video, minutes) - 20usize];
    ["Offset of field: spa_io_segment_video::seconds"]
        [::std::mem::offset_of!(spa_io_segment_video, seconds) - 24usize];
    ["Offset of field: spa_io_segment_video::frames"]
        [::std::mem::offset_of!(spa_io_segment_video, frames) - 28usize];
    ["Offset of field: spa_io_segment_video::field_count"]
        [::std::mem::offset_of!(spa_io_segment_video, field_count) - 32usize];
    ["Offset of field: spa_io_segment_video::padding"]
        [::std::mem::offset_of!(spa_io_segment_video, padding) - 36usize];
};
#[doc = " A segment converts a running time to a segment (stream) position.\n\n The segment position is valid when the current running time is between\n start and start + duration. The position is then\n calculated as:\n\n   (running time - start) * rate + position;\n\n Support for looping is done by specifying the LOOPING flags with a\n non-zero duration. When the running time reaches start + duration,\n duration is added to start and the loop repeats.\n\n Care has to be taken when the running time + clock.duration extends\n past the start + duration from the segment; the user should correctly\n wrap around and partially repeat the loop in the current cycle.\n\n Extra information can be placed in the segment by setting the valid flags\n and filling up the corresponding structures."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_io_segment {
    pub version: u32,
    #[doc = "< extra flags"]
    pub flags: u32,
    #[doc = "< value of running time when this\n  info is active. Can be in the future for\n  pending changes. It does not have to be in\n  exact multiples of the clock duration."]
    pub start: u64,
    #[doc = "< duration when this info becomes invalid expressed\n  in running time. If the duration is 0, this\n  segment extends to the next segment. If the\n  segment becomes invalid and the looping flag is\n  set, the segment repeats."]
    pub duration: u64,
    #[doc = "< overall rate of the segment, can be negative for\n  backwards time reporting."]
    pub rate: f64,
    #[doc = "< The position when the running time == start.\n  can be invalid when the owner of the extra segment\n  information has not yet made the mapping."]
    pub position: u64,
    pub bar: spa_io_segment_bar,
    pub video: spa_io_segment_video,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_io_segment"][::std::mem::size_of::<spa_io_segment>() - 184usize];
    ["Alignment of spa_io_segment"][::std::mem::align_of::<spa_io_segment>() - 8usize];
    ["Offset of field: spa_io_segment::version"]
        [::std::mem::offset_of!(spa_io_segment, version) - 0usize];
    ["Offset of field: spa_io_segment::flags"]
        [::std::mem::offset_of!(spa_io_segment, flags) - 4usize];
    ["Offset of field: spa_io_segment::start"]
        [::std::mem::offset_of!(spa_io_segment, start) - 8usize];
    ["Offset of field: spa_io_segment::duration"]
        [::std::mem::offset_of!(spa_io_segment, duration) - 16usize];
    ["Offset of field: spa_io_segment::rate"]
        [::std::mem::offset_of!(spa_io_segment, rate) - 24usize];
    ["Offset of field: spa_io_segment::position"]
        [::std::mem::offset_of!(spa_io_segment, position) - 32usize];
    ["Offset of field: spa_io_segment::bar"][::std::mem::offset_of!(spa_io_segment, bar) - 40usize];
    ["Offset of field: spa_io_segment::video"]
        [::std::mem::offset_of!(spa_io_segment, video) - 104usize];
};
pub const spa_io_position_state_SPA_IO_POSITION_STATE_STOPPED: spa_io_position_state = 0;
pub const spa_io_position_state_SPA_IO_POSITION_STATE_STARTING: spa_io_position_state = 1;
pub const spa_io_position_state_SPA_IO_POSITION_STATE_RUNNING: spa_io_position_state = 2;
pub type spa_io_position_state = ::std::os::raw::c_uint;
#[doc = " The position information adds extra meaning to the raw clock times.\n\n It is set on all nodes in \\ref SPA_IO_Position, and the contents of \\ref\n spa_io_position.clock contain the clock updates made by the driving node in\n the graph in its \\ref SPA_IO_Clock.  Also, \\ref spa_io_position.clock.id\n will contain the clock id of the driving node in the graph.\n\n The position clock indicates the logical start time of the current graph\n cycle.\n\n The position information contains 1 or more segments that convert the\n raw clock times to a stream time. They are sorted based on their\n start times, and thus the order in which they will activate in\n the future. This makes it possible to look ahead in the scheduled\n segments and anticipate the changes in the timeline."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_io_position {
    #[doc = "< clock position of driver, always valid and\n  read only"]
    pub clock: spa_io_clock,
    #[doc = "< size of the video in the current cycle"]
    pub video: spa_io_video_size,
    #[doc = "< an offset to subtract from the clock position\n  to get a running time. This is the time that\n  the state has been in the RUNNING state and the\n  time that should be used to compare the segment\n  start values against."]
    pub offset: i64,
    #[doc = "< one of enum spa_io_position_state"]
    pub state: u32,
    #[doc = "< number of segments"]
    pub n_segments: u32,
    #[doc = "< segments"]
    pub segments: [spa_io_segment; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_io_position"][::std::mem::size_of::<spa_io_position>() - 1688usize];
    ["Alignment of spa_io_position"][::std::mem::align_of::<spa_io_position>() - 8usize];
    ["Offset of field: spa_io_position::clock"]
        [::std::mem::offset_of!(spa_io_position, clock) - 0usize];
    ["Offset of field: spa_io_position::video"]
        [::std::mem::offset_of!(spa_io_position, video) - 160usize];
    ["Offset of field: spa_io_position::offset"]
        [::std::mem::offset_of!(spa_io_position, offset) - 200usize];
    ["Offset of field: spa_io_position::state"]
        [::std::mem::offset_of!(spa_io_position, state) - 208usize];
    ["Offset of field: spa_io_position::n_segments"]
        [::std::mem::offset_of!(spa_io_position, n_segments) - 212usize];
    ["Offset of field: spa_io_position::segments"]
        [::std::mem::offset_of!(spa_io_position, segments) - 216usize];
};
#[doc = " Rate matching.\n\n It is usually set on the nodes that process resampled data, by\n the component (audioadapter) that handles resampling between graph\n and node rates. The \\a flags and \\a rate fields may be modified by the node.\n\n The node can request a correction to the resampling rate in its process(), by setting\n \\ref SPA_IO_RATE_MATCH_ACTIVE on \\a flags, and setting \\a rate to the desired rate\n correction.  Usually the rate is obtained from DLL or other adaptive mechanism that\n e.g. drives the node buffer fill level toward a specific value.\n\n When resampling to (graph->node) direction, the number of samples produced\n by the resampler varies on each cycle, as the rates are not commensurate.\n\n When resampling to (node->graph) direction, the number of samples consumed by the\n resampler varies. Node output ports in process() should produce \\a size number of\n samples to match what the resampler needs to produce one graph quantum of output\n samples.\n\n Resampling filters introduce processing delay, given by \\a delay and \\a delay_frac, in\n samples at node rate. The delay varies on each cycle e.g. when resampling between\n noncommensurate rates.\n\n The first sample output (graph->node) or consumed (node->graph) by the resampler is\n offset by \\a delay + \\a delay_frac / 1e9 node samples relative to the nominal graph\n cycle start position:\n\n \\code{.unparsed}\n first_resampled_sample_nsec =\n\tfirst_original_sample_nsec\n\t- (rate_match->delay * SPA_NSEC_PER_SEC + rate_match->delay_frac) / node_rate\n \\endcode"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_io_rate_match {
    #[doc = "< resampling delay, in samples at\n node rate"]
    pub delay: u32,
    #[doc = "< requested input size for resampler"]
    pub size: u32,
    #[doc = "< rate for resampler (set by node)"]
    pub rate: f64,
    #[doc = "< extra flags (set by node)"]
    pub flags: u32,
    #[doc = "< resampling delay fractional part,\n in units of nanosamples (1/10^9 sample) at node rate"]
    pub delay_frac: i32,
    pub padding: [u32; 6usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_io_rate_match"][::std::mem::size_of::<spa_io_rate_match>() - 48usize];
    ["Alignment of spa_io_rate_match"][::std::mem::align_of::<spa_io_rate_match>() - 8usize];
    ["Offset of field: spa_io_rate_match::delay"]
        [::std::mem::offset_of!(spa_io_rate_match, delay) - 0usize];
    ["Offset of field: spa_io_rate_match::size"]
        [::std::mem::offset_of!(spa_io_rate_match, size) - 4usize];
    ["Offset of field: spa_io_rate_match::rate"]
        [::std::mem::offset_of!(spa_io_rate_match, rate) - 8usize];
    ["Offset of field: spa_io_rate_match::flags"]
        [::std::mem::offset_of!(spa_io_rate_match, flags) - 16usize];
    ["Offset of field: spa_io_rate_match::delay_frac"]
        [::std::mem::offset_of!(spa_io_rate_match, delay_frac) - 20usize];
    ["Offset of field: spa_io_rate_match::padding"]
        [::std::mem::offset_of!(spa_io_rate_match, padding) - 24usize];
};
#[doc = " async buffers"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_io_async_buffers {
    #[doc = "< async buffers, writers write to current (cycle+1)&1,\n  readers read from (cycle)&1"]
    pub buffers: [spa_io_buffers; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_io_async_buffers"][::std::mem::size_of::<spa_io_async_buffers>() - 16usize];
    ["Alignment of spa_io_async_buffers"][::std::mem::align_of::<spa_io_async_buffers>() - 4usize];
    ["Offset of field: spa_io_async_buffers::buffers"]
        [::std::mem::offset_of!(spa_io_async_buffers, buffers) - 0usize];
};
#[doc = "< the stream is in error"]
pub const pw_filter_state_PW_FILTER_STATE_ERROR: pw_filter_state = -1;
#[doc = "< unconnected"]
pub const pw_filter_state_PW_FILTER_STATE_UNCONNECTED: pw_filter_state = 0;
#[doc = "< connection is in progress"]
pub const pw_filter_state_PW_FILTER_STATE_CONNECTING: pw_filter_state = 1;
#[doc = "< filter is connected and paused"]
pub const pw_filter_state_PW_FILTER_STATE_PAUSED: pw_filter_state = 2;
#[doc = "< filter is streaming"]
pub const pw_filter_state_PW_FILTER_STATE_STREAMING: pw_filter_state = 3;
#[doc = " \\enum pw_filter_state The state of a filter"]
pub type pw_filter_state = ::std::os::raw::c_int;
#[doc = " Events for a filter. These events are always called from the mainloop\n unless explicitly documented otherwise."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_filter_events {
    pub version: u32,
    pub destroy: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " when the filter state changes. Since 1.4 this also sets errno when the\n new state is PW_FILTER_STATE_ERROR"]
    pub state_changed: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            old: pw_filter_state,
            state: pw_filter_state,
            error: *const ::std::os::raw::c_char,
        ),
    >,
    #[doc = " when io changed on a port of the filter (when port_data is NULL)."]
    pub io_changed: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            port_data: *mut ::std::os::raw::c_void,
            id: u32,
            area: *mut ::std::os::raw::c_void,
            size: u32,
        ),
    >,
    #[doc = " when a parameter changed on a port of the filter (when port_data is NULL)."]
    pub param_changed: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            port_data: *mut ::std::os::raw::c_void,
            id: u32,
            param: *const spa_pod,
        ),
    >,
    #[doc = " when a new buffer was created for a port"]
    pub add_buffer: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            port_data: *mut ::std::os::raw::c_void,
            buffer: *mut pw_buffer,
        ),
    >,
    #[doc = " when a buffer was destroyed for a port"]
    pub remove_buffer: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            port_data: *mut ::std::os::raw::c_void,
            buffer: *mut pw_buffer,
        ),
    >,
    #[doc = " do processing. This is normally called from the\n  mainloop but can also be called directly from the realtime data\n  thread if the user is prepared to deal with this with the\n  PW_FILTER_FLAG_RT_PROCESS. Only call methods marked with RT safe\n  from this event when called from the realtime thread."]
    pub process: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, position: *mut spa_io_position),
    >,
    #[doc = " The filter is drained"]
    pub drained: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " A command notify, Since 0.3.39:1"]
    pub command: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, command: *const spa_command),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_filter_events"][::std::mem::size_of::<pw_filter_events>() - 80usize];
    ["Alignment of pw_filter_events"][::std::mem::align_of::<pw_filter_events>() - 8usize];
    ["Offset of field: pw_filter_events::version"]
        [::std::mem::offset_of!(pw_filter_events, version) - 0usize];
    ["Offset of field: pw_filter_events::destroy"]
        [::std::mem::offset_of!(pw_filter_events, destroy) - 8usize];
    ["Offset of field: pw_filter_events::state_changed"]
        [::std::mem::offset_of!(pw_filter_events, state_changed) - 16usize];
    ["Offset of field: pw_filter_events::io_changed"]
        [::std::mem::offset_of!(pw_filter_events, io_changed) - 24usize];
    ["Offset of field: pw_filter_events::param_changed"]
        [::std::mem::offset_of!(pw_filter_events, param_changed) - 32usize];
    ["Offset of field: pw_filter_events::add_buffer"]
        [::std::mem::offset_of!(pw_filter_events, add_buffer) - 40usize];
    ["Offset of field: pw_filter_events::remove_buffer"]
        [::std::mem::offset_of!(pw_filter_events, remove_buffer) - 48usize];
    ["Offset of field: pw_filter_events::process"]
        [::std::mem::offset_of!(pw_filter_events, process) - 56usize];
    ["Offset of field: pw_filter_events::drained"]
        [::std::mem::offset_of!(pw_filter_events, drained) - 64usize];
    ["Offset of field: pw_filter_events::command"]
        [::std::mem::offset_of!(pw_filter_events, command) - 72usize];
};
unsafe extern "C" {
    #[doc = " Convert a filter state to a readable string"]
    pub fn pw_filter_state_as_string(state: pw_filter_state) -> *const ::std::os::raw::c_char;
}
#[doc = "< no flags"]
pub const pw_filter_flags_PW_FILTER_FLAG_NONE: pw_filter_flags = 0;
#[doc = "< start the filter inactive,\n  pw_filter_set_active() needs to be\n  called explicitly"]
pub const pw_filter_flags_PW_FILTER_FLAG_INACTIVE: pw_filter_flags = 1;
#[doc = "< be a driver"]
pub const pw_filter_flags_PW_FILTER_FLAG_DRIVER: pw_filter_flags = 2;
#[doc = "< call process from the realtime\n  thread. Only call methods marked as\n  RT safe."]
pub const pw_filter_flags_PW_FILTER_FLAG_RT_PROCESS: pw_filter_flags = 4;
#[doc = "< don't call the default latency algorithm\n  but emit the param_changed event for the\n  ports when Latency params are received."]
pub const pw_filter_flags_PW_FILTER_FLAG_CUSTOM_LATENCY: pw_filter_flags = 8;
#[doc = "< the filter will not be scheduled\n  automatically but _trigger_process()\n  needs to be called. This can be used\n  when the filter depends on processing\n  of other filters."]
pub const pw_filter_flags_PW_FILTER_FLAG_TRIGGER: pw_filter_flags = 16;
#[doc = "< Buffers will not be dequeued/queued from\n  the realtime process() function. This is\n  assumed when RT_PROCESS is unset but can\n  also be the case when the process() function\n  does a trigger_process() that will then\n  dequeue/queue a buffer from another process()\n  function. since 0.3.73"]
pub const pw_filter_flags_PW_FILTER_FLAG_ASYNC: pw_filter_flags = 32;
#[doc = " \\enum pw_filter_flags Extra flags that can be used in \\ref pw_filter_connect()"]
pub type pw_filter_flags = ::std::os::raw::c_uint;
#[doc = "< no flags"]
pub const pw_filter_port_flags_PW_FILTER_PORT_FLAG_NONE: pw_filter_port_flags = 0;
#[doc = "< mmap the buffers except DmaBuf that is not\n  explicitly marked as mappable."]
pub const pw_filter_port_flags_PW_FILTER_PORT_FLAG_MAP_BUFFERS: pw_filter_port_flags = 1;
#[doc = "< the application will allocate buffer\n  memory. In the add_buffer event, the\n  data of the buffer should be set"]
pub const pw_filter_port_flags_PW_FILTER_PORT_FLAG_ALLOC_BUFFERS: pw_filter_port_flags = 2;
pub type pw_filter_port_flags = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " Create a new unconnected \\ref pw_filter\n \\return a newly allocated \\ref pw_filter"]
    pub fn pw_filter_new(
        core: *mut pw_core,
        name: *const ::std::os::raw::c_char,
        props: *mut pw_properties,
    ) -> *mut pw_filter;
}
unsafe extern "C" {
    pub fn pw_filter_new_simple(
        loop_: *mut pw_loop,
        name: *const ::std::os::raw::c_char,
        props: *mut pw_properties,
        events: *const pw_filter_events,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut pw_filter;
}
unsafe extern "C" {
    #[doc = " Destroy a filter"]
    pub fn pw_filter_destroy(filter: *mut pw_filter);
}
unsafe extern "C" {
    pub fn pw_filter_add_listener(
        filter: *mut pw_filter,
        listener: *mut spa_hook,
        events: *const pw_filter_events,
        data: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = " Get the current filter state. Since 1.4 this also sets errno when the\n state is PW_FILTER_STATE_ERROR"]
    pub fn pw_filter_get_state(
        filter: *mut pw_filter,
        error: *mut *const ::std::os::raw::c_char,
    ) -> pw_filter_state;
}
unsafe extern "C" {
    pub fn pw_filter_get_name(filter: *mut pw_filter) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn pw_filter_get_core(filter: *mut pw_filter) -> *mut pw_core;
}
unsafe extern "C" {
    #[doc = " Connect a filter for processing.\n \\return 0 on success < 0 on error.\n\n You should connect to the process event and use pw_filter_dequeue_buffer()\n to get the latest metadata and data."]
    pub fn pw_filter_connect(
        filter: *mut pw_filter,
        flags: pw_filter_flags,
        params: *mut *const spa_pod,
        n_params: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the node ID of the filter.\n \\return node ID."]
    pub fn pw_filter_get_node_id(filter: *mut pw_filter) -> u32;
}
unsafe extern "C" {
    #[doc = " Disconnect \\a filter"]
    pub fn pw_filter_disconnect(filter: *mut pw_filter) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " add a port to the filter, returns user data of port_data_size."]
    pub fn pw_filter_add_port(
        filter: *mut pw_filter,
        direction: spa_direction,
        flags: pw_filter_port_flags,
        port_data_size: usize,
        props: *mut pw_properties,
        params: *mut *const spa_pod,
        n_params: u32,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " remove a port from the filter"]
    pub fn pw_filter_remove_port(port_data: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " get properties, port_data of NULL will give global properties"]
    pub fn pw_filter_get_properties(
        filter: *mut pw_filter,
        port_data: *mut ::std::os::raw::c_void,
    ) -> *const pw_properties;
}
unsafe extern "C" {
    #[doc = " Update properties, use NULL port_data for global filter properties"]
    pub fn pw_filter_update_properties(
        filter: *mut pw_filter,
        port_data: *mut ::std::os::raw::c_void,
        dict: *const spa_dict,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Set the filter in error state"]
    pub fn pw_filter_set_error(
        filter: *mut pw_filter,
        res: ::std::os::raw::c_int,
        error: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Update params, use NULL port_data for global filter params"]
    pub fn pw_filter_update_params(
        filter: *mut pw_filter,
        port_data: *mut ::std::os::raw::c_void,
        params: *mut *const spa_pod,
        n_params: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Query the time on the filter, deprecated, use the spa_io_position in the\n process() method for timing information. RT safe."]
    pub fn pw_filter_get_time(filter: *mut pw_filter, time: *mut pw_time) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the current time in nanoseconds. This value can be compared with\n the nsec value in the spa_io_position. RT safe. Since 1.1.0"]
    pub fn pw_filter_get_nsec(filter: *mut pw_filter) -> u64;
}
unsafe extern "C" {
    #[doc = " Get the data loop that is doing the processing of this filter. This loop\n is assigned after pw_filter_connect(). Since 1.1.0"]
    pub fn pw_filter_get_data_loop(filter: *mut pw_filter) -> *mut pw_loop;
}
unsafe extern "C" {
    #[doc = " Get a buffer that can be filled for output ports or consumed\n for input ports. RT safe."]
    pub fn pw_filter_dequeue_buffer(port_data: *mut ::std::os::raw::c_void) -> *mut pw_buffer;
}
unsafe extern "C" {
    #[doc = " Submit a buffer for playback or recycle a buffer for capture. RT safe."]
    pub fn pw_filter_queue_buffer(
        port_data: *mut ::std::os::raw::c_void,
        buffer: *mut pw_buffer,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get a data pointer to the buffer data. RT safe."]
    pub fn pw_filter_get_dsp_buffer(
        port_data: *mut ::std::os::raw::c_void,
        n_samples: u32,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " Activate or deactivate the filter"]
    pub fn pw_filter_set_active(filter: *mut pw_filter, active: bool) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Flush a filter. When \\a drain is true, the drained callback will\n be called when all data is played or recorded. The filter can be resumed\n after the drain by setting it active again with\n \\ref pw_filter_set_active(). A flush without a drain is mostly useful afer\n a state change to PAUSED, to flush any remaining data from the queues.\n RT safe."]
    pub fn pw_filter_flush(filter: *mut pw_filter, drain: bool) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Check if the filter is driving. The filter needs to have the\n PW_FILTER_FLAG_DRIVER set. When the filter is driving,\n pw_filter_trigger_process() needs to be called when data is\n available (output) or needed (input). Since 0.3.66"]
    pub fn pw_filter_is_driving(filter: *mut pw_filter) -> bool;
}
unsafe extern "C" {
    #[doc = " Check if the graph is using lazy scheduling.\n Since 1.4.0"]
    pub fn pw_filter_is_lazy(filter: *mut pw_filter) -> bool;
}
unsafe extern "C" {
    #[doc = " Trigger a push/pull on the filter. One iteration of the graph will\n be scheduled and process() will be called. RT safe. Since 0.3.66"]
    pub fn pw_filter_trigger_process(filter: *mut pw_filter) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Emit an event from this filter. RT safe.\n Since 1.2.6"]
    pub fn pw_filter_emit_event(
        filter: *mut pw_filter,
        event: *const spa_event,
    ) -> ::std::os::raw::c_int;
}
#[doc = " \\addtogroup pw_thread_loop\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_thread_loop {
    _unused: [u8; 0],
}
#[doc = " Thread loop events"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_thread_loop_events {
    pub version: u32,
    #[doc = " the loop is destroyed"]
    pub destroy: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_thread_loop_events"][::std::mem::size_of::<pw_thread_loop_events>() - 16usize];
    ["Alignment of pw_thread_loop_events"]
        [::std::mem::align_of::<pw_thread_loop_events>() - 8usize];
    ["Offset of field: pw_thread_loop_events::version"]
        [::std::mem::offset_of!(pw_thread_loop_events, version) - 0usize];
    ["Offset of field: pw_thread_loop_events::destroy"]
        [::std::mem::offset_of!(pw_thread_loop_events, destroy) - 8usize];
};
unsafe extern "C" {
    #[doc = " Make a new thread loop with the given name and optional properties."]
    pub fn pw_thread_loop_new(
        name: *const ::std::os::raw::c_char,
        props: *const spa_dict,
    ) -> *mut pw_thread_loop;
}
unsafe extern "C" {
    #[doc = " Make a new thread loop with the given loop, name and optional properties.\n When \\a loop is NULL, a new loop will be created."]
    pub fn pw_thread_loop_new_full(
        loop_: *mut pw_loop,
        name: *const ::std::os::raw::c_char,
        props: *const spa_dict,
    ) -> *mut pw_thread_loop;
}
unsafe extern "C" {
    #[doc = " Destroy a thread loop"]
    pub fn pw_thread_loop_destroy(loop_: *mut pw_thread_loop);
}
unsafe extern "C" {
    #[doc = " Add an event listener"]
    pub fn pw_thread_loop_add_listener(
        loop_: *mut pw_thread_loop,
        listener: *mut spa_hook,
        events: *const pw_thread_loop_events,
        data: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = " Get the loop implementation of the thread loop"]
    pub fn pw_thread_loop_get_loop(loop_: *mut pw_thread_loop) -> *mut pw_loop;
}
unsafe extern "C" {
    #[doc = " Start the thread loop"]
    pub fn pw_thread_loop_start(loop_: *mut pw_thread_loop) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Stop the thread loop"]
    pub fn pw_thread_loop_stop(loop_: *mut pw_thread_loop);
}
unsafe extern "C" {
    #[doc = " Lock the loop. This ensures exclusive ownership of the loop"]
    pub fn pw_thread_loop_lock(loop_: *mut pw_thread_loop);
}
unsafe extern "C" {
    #[doc = " Unlock the loop"]
    pub fn pw_thread_loop_unlock(loop_: *mut pw_thread_loop);
}
unsafe extern "C" {
    #[doc = " Release the lock and wait until some thread calls \\ref pw_thread_loop_signal"]
    pub fn pw_thread_loop_wait(loop_: *mut pw_thread_loop);
}
unsafe extern "C" {
    #[doc = " Release the lock and wait a maximum of 'wait_max_sec' seconds\n  until some thread calls \\ref pw_thread_loop_signal or time out"]
    pub fn pw_thread_loop_timed_wait(
        loop_: *mut pw_thread_loop,
        wait_max_sec: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get a struct timespec suitable for \\ref pw_thread_loop_timed_wait_full.\n Since: 0.3.7"]
    pub fn pw_thread_loop_get_time(
        loop_: *mut pw_thread_loop,
        abstime: *mut timespec,
        timeout: i64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Release the lock and wait up to \\a abstime until some thread calls\n \\ref pw_thread_loop_signal. Use \\ref pw_thread_loop_get_time to make a timeout.\n Since: 0.3.7"]
    pub fn pw_thread_loop_timed_wait_full(
        loop_: *mut pw_thread_loop,
        abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Signal all threads waiting with \\ref pw_thread_loop_wait"]
    pub fn pw_thread_loop_signal(loop_: *mut pw_thread_loop, wait_for_accept: bool);
}
unsafe extern "C" {
    #[doc = " Signal all threads executing \\ref pw_thread_loop_signal with wait_for_accept"]
    pub fn pw_thread_loop_accept(loop_: *mut pw_thread_loop);
}
unsafe extern "C" {
    #[doc = " Check if inside the thread"]
    pub fn pw_thread_loop_in_thread(loop_: *mut pw_thread_loop) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_thread {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_thread_utils {
    pub iface: spa_interface,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_thread_utils"][::std::mem::size_of::<spa_thread_utils>() - 32usize];
    ["Alignment of spa_thread_utils"][::std::mem::align_of::<spa_thread_utils>() - 8usize];
    ["Offset of field: spa_thread_utils::iface"]
        [::std::mem::offset_of!(spa_thread_utils, iface) - 0usize];
};
#[doc = " thread utils"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_thread_utils_methods {
    pub version: u32,
    #[doc = " create a new thread that runs \\a start with \\a arg"]
    pub create: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            props: *const spa_dict,
            start: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut ::std::os::raw::c_void,
                ) -> *mut ::std::os::raw::c_void,
            >,
            arg: *mut ::std::os::raw::c_void,
        ) -> *mut spa_thread,
    >,
    #[doc = " stop and join a thread"]
    pub join: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            thread: *mut spa_thread,
            retval: *mut *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " get realtime priority range for threads created with \\a props"]
    pub get_rt_range: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            props: *const spa_dict,
            min: *mut ::std::os::raw::c_int,
            max: *mut ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " acquire realtime priority, a priority of -1 refers to the priority\n configured in the realtime module"]
    pub acquire_rt: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            thread: *mut spa_thread,
            priority: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " drop realtime priority"]
    pub drop_rt: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            thread: *mut spa_thread,
        ) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_thread_utils_methods"]
        [::std::mem::size_of::<spa_thread_utils_methods>() - 48usize];
    ["Alignment of spa_thread_utils_methods"]
        [::std::mem::align_of::<spa_thread_utils_methods>() - 8usize];
    ["Offset of field: spa_thread_utils_methods::version"]
        [::std::mem::offset_of!(spa_thread_utils_methods, version) - 0usize];
    ["Offset of field: spa_thread_utils_methods::create"]
        [::std::mem::offset_of!(spa_thread_utils_methods, create) - 8usize];
    ["Offset of field: spa_thread_utils_methods::join"]
        [::std::mem::offset_of!(spa_thread_utils_methods, join) - 16usize];
    ["Offset of field: spa_thread_utils_methods::get_rt_range"]
        [::std::mem::offset_of!(spa_thread_utils_methods, get_rt_range) - 24usize];
    ["Offset of field: spa_thread_utils_methods::acquire_rt"]
        [::std::mem::offset_of!(spa_thread_utils_methods, acquire_rt) - 32usize];
    ["Offset of field: spa_thread_utils_methods::drop_rt"]
        [::std::mem::offset_of!(spa_thread_utils_methods, drop_rt) - 40usize];
};
#[doc = " Loop events, use \\ref pw_data_loop_add_listener to add a listener"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_data_loop_events {
    pub version: u32,
    #[doc = " The loop is destroyed"]
    pub destroy: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_data_loop_events"][::std::mem::size_of::<pw_data_loop_events>() - 16usize];
    ["Alignment of pw_data_loop_events"][::std::mem::align_of::<pw_data_loop_events>() - 8usize];
    ["Offset of field: pw_data_loop_events::version"]
        [::std::mem::offset_of!(pw_data_loop_events, version) - 0usize];
    ["Offset of field: pw_data_loop_events::destroy"]
        [::std::mem::offset_of!(pw_data_loop_events, destroy) - 8usize];
};
unsafe extern "C" {
    #[doc = " Make a new loop."]
    pub fn pw_data_loop_new(props: *const spa_dict) -> *mut pw_data_loop;
}
unsafe extern "C" {
    #[doc = " Add an event listener to loop"]
    pub fn pw_data_loop_add_listener(
        loop_: *mut pw_data_loop,
        listener: *mut spa_hook,
        events: *const pw_data_loop_events,
        data: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = " wait for activity on the loop up to \\a timeout milliseconds.\n Should be called from the loop function"]
    pub fn pw_data_loop_wait(
        loop_: *mut pw_data_loop,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " make sure the thread will exit. Can be called from a loop callback"]
    pub fn pw_data_loop_exit(loop_: *mut pw_data_loop);
}
unsafe extern "C" {
    #[doc = " Get the loop implementation of this data loop"]
    pub fn pw_data_loop_get_loop(loop_: *mut pw_data_loop) -> *mut pw_loop;
}
unsafe extern "C" {
    #[doc = " Get the loop name. Since 1.1.0"]
    pub fn pw_data_loop_get_name(loop_: *mut pw_data_loop) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Get the loop class. Since 1.1.0"]
    pub fn pw_data_loop_get_class(loop_: *mut pw_data_loop) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Destroy the loop"]
    pub fn pw_data_loop_destroy(loop_: *mut pw_data_loop);
}
unsafe extern "C" {
    #[doc = " Start the processing thread"]
    pub fn pw_data_loop_start(loop_: *mut pw_data_loop) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Stop the processing thread"]
    pub fn pw_data_loop_stop(loop_: *mut pw_data_loop) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Check if the current thread is the processing thread.\n May be called from any thread."]
    pub fn pw_data_loop_in_thread(loop_: *mut pw_data_loop) -> bool;
}
unsafe extern "C" {
    #[doc = " Get the thread object"]
    pub fn pw_data_loop_get_thread(loop_: *mut pw_data_loop) -> *mut spa_thread;
}
unsafe extern "C" {
    #[doc = " invoke func in the context of the thread or in the caller thread when\n the loop is not running. May be called from the loop's thread, but otherwise\n can only be called by a single thread at a time.\n If called from the loop's thread, all callbacks previously queued with\n pw_data_loop_invoke() will be run synchronously, which might cause\n unexpected reentrancy problems.\n\n \\param[in] loop The loop to invoke func on.\n \\param func The function to be invoked.\n \\param seq A sequence number, opaque to PipeWire. This will be made\n            available to func.\n \\param[in] data Data that will be copied into the internal ring buffer and made\n             available to func. Because this data is copied, it is okay to\n             pass a pointer to a local variable, but do not pass a pointer to\n             an object that has identity.\n \\param size The size of data to copy.\n \\param block If \\true, do not return until func has been called. Otherwise,\n              returns immediately. Passing \\true does not risk a deadlock because\n              the data thread is never allowed to wait on any other thread.\n \\param user_data An opaque pointer passed to func.\n \\return `-EPIPE` if the internal ring buffer filled up,\n         if block is \\false, 0 is returned when seq is SPA_ID_INVALID or the\n         sequence number with the ASYNC bit set otherwise. When block is \\true,\n         the return value of func is returned.\n\n Since 0.3.3"]
    pub fn pw_data_loop_invoke(
        loop_: *mut pw_data_loop,
        func: spa_invoke_func_t,
        seq: u32,
        data: *const ::std::os::raw::c_void,
        size: usize,
        block: bool,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Set a custom spa_thread_utils for this loop. Setting NULL restores the\n system default implementation. Since 0.3.50"]
    pub fn pw_data_loop_set_thread_utils(loop_: *mut pw_data_loop, impl_: *mut spa_thread_utils);
}
unsafe extern "C" {
    #[doc = " Return the version of the library the current application is\n linked to."]
    pub fn pw_get_library_version() -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Return TRUE if the currently linked PipeWire library version is equal\n or newer than the specified version. Since 0.3.75"]
    pub fn pw_check_library_version(
        major: ::std::os::raw::c_int,
        minor: ::std::os::raw::c_int,
        micro: ::std::os::raw::c_int,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " \\addtogroup pw_pipewire\n \\{"]
    pub fn pw_init(argc: *mut ::std::os::raw::c_int, argv: *mut *mut *mut ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn pw_deinit();
}
unsafe extern "C" {
    pub fn pw_debug_is_category_enabled(name: *const ::std::os::raw::c_char) -> bool;
}
unsafe extern "C" {
    pub fn pw_get_application_name() -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn pw_get_prgname() -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn pw_get_user_name() -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn pw_get_host_name() -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn pw_get_client_name() -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn pw_check_option(
        option: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> bool;
}
unsafe extern "C" {
    pub fn pw_direction_reverse(direction: spa_direction) -> spa_direction;
}
unsafe extern "C" {
    pub fn pw_set_domain(domain: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pw_get_domain() -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn pw_get_support(support: *mut spa_support, max_support: u32) -> u32;
}
unsafe extern "C" {
    pub fn pw_load_spa_handle(
        lib: *const ::std::os::raw::c_char,
        factory_name: *const ::std::os::raw::c_char,
        info: *const spa_dict,
        n_support: u32,
        support: *const spa_support,
    ) -> *mut spa_handle;
}
unsafe extern "C" {
    pub fn pw_unload_spa_handle(handle: *mut spa_handle) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_client_node {
    _unused: [u8; 0],
}
#[doc = " information about a buffer"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_client_node_buffer {
    #[doc = "< the memory id for the metadata"]
    pub mem_id: u32,
    #[doc = "< offset in memory"]
    pub offset: u32,
    #[doc = "< size in memory"]
    pub size: u32,
    #[doc = "< buffer describing metadata and buffer memory"]
    pub buffer: *mut spa_buffer,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_client_node_buffer"][::std::mem::size_of::<pw_client_node_buffer>() - 24usize];
    ["Alignment of pw_client_node_buffer"]
        [::std::mem::align_of::<pw_client_node_buffer>() - 8usize];
    ["Offset of field: pw_client_node_buffer::mem_id"]
        [::std::mem::offset_of!(pw_client_node_buffer, mem_id) - 0usize];
    ["Offset of field: pw_client_node_buffer::offset"]
        [::std::mem::offset_of!(pw_client_node_buffer, offset) - 4usize];
    ["Offset of field: pw_client_node_buffer::size"]
        [::std::mem::offset_of!(pw_client_node_buffer, size) - 8usize];
    ["Offset of field: pw_client_node_buffer::buffer"]
        [::std::mem::offset_of!(pw_client_node_buffer, buffer) - 16usize];
};
#[doc = " \\ref pw_client_node events"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_client_node_events {
    pub version: u32,
    #[doc = " Notify of a new transport area\n\n The transport area is used to signal the client and the server.\n\n \\param readfd fd for signal data can be read\n \\param writefd fd for signal data can be written\n \\param mem_id id for activation memory\n \\param offset offset of activation memory\n \\param size size of activation memory"]
    pub transport: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            readfd: ::std::os::raw::c_int,
            writefd: ::std::os::raw::c_int,
            mem_id: u32,
            offset: u32,
            size: u32,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Notify of a property change\n\n When the server configures the properties on the node\n this event is sent\n\n \\param id the id of the parameter\n \\param flags parameter flags\n \\param param the param to set"]
    pub set_param: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            id: u32,
            flags: u32,
            param: *const spa_pod,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Configure an IO area for the client\n\n IO areas are identified with an id and are used to\n exchange state between client and server\n\n \\param id the id of the io area\n \\param mem_id the id of the memory to use\n \\param offset offset of io area in memory\n \\param size size of the io area"]
    pub set_io: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            id: u32,
            mem_id: u32,
            offset: u32,
            size: u32,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Receive an event from the client node\n \\param event the received event"]
    pub event: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            event: *const spa_event,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Notify of a new node command\n\n \\param command the command"]
    pub command: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            command: *const spa_command,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " A new port was added to the node\n\n The server can at any time add a port to the node when there\n are free ports available.\n\n \\param direction the direction of the port\n \\param port_id the new port id\n \\param props extra properties"]
    pub add_port: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            direction: spa_direction,
            port_id: u32,
            props: *const spa_dict,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " A port was removed from the node\n\n \\param direction a port direction\n \\param port_id the remove port id"]
    pub remove_port: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            direction: spa_direction,
            port_id: u32,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " A parameter was configured on the port\n\n \\param direction a port direction\n \\param port_id the port id\n \\param id the id of the parameter\n \\param flags flags used when setting the param\n \\param param the new param"]
    pub port_set_param: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            direction: spa_direction,
            port_id: u32,
            id: u32,
            flags: u32,
            param: *const spa_pod,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Notify the port of buffers\n\n \\param direction a port direction\n \\param port_id the port id\n \\param mix_id the mixer port id\n \\param n_buffer the number of buffers\n \\param buffers and array of buffer descriptions"]
    pub port_use_buffers: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            direction: spa_direction,
            port_id: u32,
            mix_id: u32,
            flags: u32,
            n_buffers: u32,
            buffers: *mut pw_client_node_buffer,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Configure the io area with \\a id of \\a port_id.\n\n \\param direction the direction of the port\n \\param port_id the port id\n \\param mix_id the mixer port id\n \\param id the id of the io area to set\n \\param mem_id the id of the memory to use\n \\param offset offset of io area in memory\n \\param size size of the io area"]
    pub port_set_io: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            direction: spa_direction,
            port_id: u32,
            mix_id: u32,
            id: u32,
            mem_id: u32,
            offset: u32,
            size: u32,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Notify the activation record of the next\n node to trigger\n\n \\param node_id the peer node id\n \\param signalfd the fd to wake up the peer\n \\param mem_id the mem id of the memory\n \\param the offset in \\a mem_id to map\n \\param the size of \\a mem_id to map"]
    pub set_activation: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            node_id: u32,
            signalfd: ::std::os::raw::c_int,
            mem_id: u32,
            offset: u32,
            size: u32,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Notify about the peer of mix_id\n\n \\param direction the direction of the port\n \\param port_id the port id\n \\param mix_id the mix id\n \\param peer_id the id of the peer port\n \\param props extra properties\n\n Since version 4:1"]
    pub port_set_mix_info: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            direction: spa_direction,
            port_id: u32,
            mix_id: u32,
            peer_id: u32,
            props: *const spa_dict,
        ) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_client_node_events"][::std::mem::size_of::<pw_client_node_events>() - 104usize];
    ["Alignment of pw_client_node_events"]
        [::std::mem::align_of::<pw_client_node_events>() - 8usize];
    ["Offset of field: pw_client_node_events::version"]
        [::std::mem::offset_of!(pw_client_node_events, version) - 0usize];
    ["Offset of field: pw_client_node_events::transport"]
        [::std::mem::offset_of!(pw_client_node_events, transport) - 8usize];
    ["Offset of field: pw_client_node_events::set_param"]
        [::std::mem::offset_of!(pw_client_node_events, set_param) - 16usize];
    ["Offset of field: pw_client_node_events::set_io"]
        [::std::mem::offset_of!(pw_client_node_events, set_io) - 24usize];
    ["Offset of field: pw_client_node_events::event"]
        [::std::mem::offset_of!(pw_client_node_events, event) - 32usize];
    ["Offset of field: pw_client_node_events::command"]
        [::std::mem::offset_of!(pw_client_node_events, command) - 40usize];
    ["Offset of field: pw_client_node_events::add_port"]
        [::std::mem::offset_of!(pw_client_node_events, add_port) - 48usize];
    ["Offset of field: pw_client_node_events::remove_port"]
        [::std::mem::offset_of!(pw_client_node_events, remove_port) - 56usize];
    ["Offset of field: pw_client_node_events::port_set_param"]
        [::std::mem::offset_of!(pw_client_node_events, port_set_param) - 64usize];
    ["Offset of field: pw_client_node_events::port_use_buffers"]
        [::std::mem::offset_of!(pw_client_node_events, port_use_buffers) - 72usize];
    ["Offset of field: pw_client_node_events::port_set_io"]
        [::std::mem::offset_of!(pw_client_node_events, port_set_io) - 80usize];
    ["Offset of field: pw_client_node_events::set_activation"]
        [::std::mem::offset_of!(pw_client_node_events, set_activation) - 88usize];
    ["Offset of field: pw_client_node_events::port_set_mix_info"]
        [::std::mem::offset_of!(pw_client_node_events, port_set_mix_info) - 96usize];
};
#[doc = " \\ref pw_client_node methods"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_client_node_methods {
    pub version: u32,
    pub add_listener: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            listener: *mut spa_hook,
            events: *const pw_client_node_events,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " get the node object"]
    pub get_node: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            version: u32,
            user_data_size: usize,
        ) -> *mut pw_node,
    >,
    #[doc = " Update the node ports and properties\n\n Update the maximum number of ports and the params of the\n client node.\n \\param change_mask bitfield with changed parameters\n \\param max_input_ports new max input ports\n \\param max_output_ports new max output ports\n \\param params new params"]
    pub update: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            change_mask: u32,
            n_params: u32,
            params: *mut *const spa_pod,
            info: *const spa_node_info,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Update a node port\n\n Update the information of one port of a node.\n \\param direction the direction of the port\n \\param port_id the port id to update\n \\param change_mask a bitfield of changed items\n \\param n_params number of port parameters\n \\param params array of port parameters\n \\param info port information"]
    pub port_update: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            direction: spa_direction,
            port_id: u32,
            change_mask: u32,
            n_params: u32,
            params: *mut *const spa_pod,
            info: *const spa_port_info,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Activate or deactivate the node"]
    pub set_active: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            active: bool,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Send an event to the node\n \\param event the event to send"]
    pub event: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            event: *const spa_event,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Send allocated buffers"]
    pub port_buffers: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            direction: spa_direction,
            port_id: u32,
            mix_id: u32,
            n_buffers: u32,
            buffers: *mut *mut spa_buffer,
        ) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_client_node_methods"][::std::mem::size_of::<pw_client_node_methods>() - 64usize];
    ["Alignment of pw_client_node_methods"]
        [::std::mem::align_of::<pw_client_node_methods>() - 8usize];
    ["Offset of field: pw_client_node_methods::version"]
        [::std::mem::offset_of!(pw_client_node_methods, version) - 0usize];
    ["Offset of field: pw_client_node_methods::add_listener"]
        [::std::mem::offset_of!(pw_client_node_methods, add_listener) - 8usize];
    ["Offset of field: pw_client_node_methods::get_node"]
        [::std::mem::offset_of!(pw_client_node_methods, get_node) - 16usize];
    ["Offset of field: pw_client_node_methods::update"]
        [::std::mem::offset_of!(pw_client_node_methods, update) - 24usize];
    ["Offset of field: pw_client_node_methods::port_update"]
        [::std::mem::offset_of!(pw_client_node_methods, port_update) - 32usize];
    ["Offset of field: pw_client_node_methods::set_active"]
        [::std::mem::offset_of!(pw_client_node_methods, set_active) - 40usize];
    ["Offset of field: pw_client_node_methods::event"]
        [::std::mem::offset_of!(pw_client_node_methods, event) - 48usize];
    ["Offset of field: pw_client_node_methods::port_buffers"]
        [::std::mem::offset_of!(pw_client_node_methods, port_buffers) - 56usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_metadata {
    _unused: [u8; 0],
}
#[doc = " \\ref pw_metadata events"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_metadata_events {
    pub version: u32,
    pub property: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            subject: u32,
            key: *const ::std::os::raw::c_char,
            type_: *const ::std::os::raw::c_char,
            value: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_metadata_events"][::std::mem::size_of::<pw_metadata_events>() - 16usize];
    ["Alignment of pw_metadata_events"][::std::mem::align_of::<pw_metadata_events>() - 8usize];
    ["Offset of field: pw_metadata_events::version"]
        [::std::mem::offset_of!(pw_metadata_events, version) - 0usize];
    ["Offset of field: pw_metadata_events::property"]
        [::std::mem::offset_of!(pw_metadata_events, property) - 8usize];
};
#[doc = " \\ref pw_metadata methods"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_metadata_methods {
    pub version: u32,
    pub add_listener: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            listener: *mut spa_hook,
            events: *const pw_metadata_events,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Set a metadata property\n\n Automatically emit property events for the subject and key\n when they are changed.\n\n \\param subject the id of the global to associate the metadata\n                with.\n \\param key the key of the metadata, NULL clears all metadata for\n                the subject.\n \\param type the type of the metadata, this can be blank\n \\param value the metadata value. NULL clears the metadata.\n\n This requires X and W permissions on the metadata. It also\n requires M permissions on the subject global."]
    pub set_property: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            subject: u32,
            key: *const ::std::os::raw::c_char,
            type_: *const ::std::os::raw::c_char,
            value: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Clear all metadata\n\n This requires X and W permissions on the metadata."]
    pub clear: ::std::option::Option<
        unsafe extern "C" fn(object: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_metadata_methods"][::std::mem::size_of::<pw_metadata_methods>() - 32usize];
    ["Alignment of pw_metadata_methods"][::std::mem::align_of::<pw_metadata_methods>() - 8usize];
    ["Offset of field: pw_metadata_methods::version"]
        [::std::mem::offset_of!(pw_metadata_methods, version) - 0usize];
    ["Offset of field: pw_metadata_methods::add_listener"]
        [::std::mem::offset_of!(pw_metadata_methods, add_listener) - 8usize];
    ["Offset of field: pw_metadata_methods::set_property"]
        [::std::mem::offset_of!(pw_metadata_methods, set_property) - 16usize];
    ["Offset of field: pw_metadata_methods::clear"]
        [::std::mem::offset_of!(pw_metadata_methods, clear) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_profiler {
    _unused: [u8; 0],
}
#[doc = " \\ref pw_profiler events"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_profiler_events {
    pub version: u32,
    pub profile: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, pod: *const spa_pod),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_profiler_events"][::std::mem::size_of::<pw_profiler_events>() - 16usize];
    ["Alignment of pw_profiler_events"][::std::mem::align_of::<pw_profiler_events>() - 8usize];
    ["Offset of field: pw_profiler_events::version"]
        [::std::mem::offset_of!(pw_profiler_events, version) - 0usize];
    ["Offset of field: pw_profiler_events::profile"]
        [::std::mem::offset_of!(pw_profiler_events, profile) - 8usize];
};
#[doc = " \\ref pw_profiler methods"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_profiler_methods {
    pub version: u32,
    pub add_listener: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            listener: *mut spa_hook,
            events: *const pw_profiler_events,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_profiler_methods"][::std::mem::size_of::<pw_profiler_methods>() - 16usize];
    ["Alignment of pw_profiler_methods"][::std::mem::align_of::<pw_profiler_methods>() - 8usize];
    ["Offset of field: pw_profiler_methods::version"]
        [::std::mem::offset_of!(pw_profiler_methods, version) - 0usize];
    ["Offset of field: pw_profiler_methods::add_listener"]
        [::std::mem::offset_of!(pw_profiler_methods, add_listener) - 8usize];
};
#[doc = " \\addtogroup pw_resource\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_resource {
    _unused: [u8; 0],
}
#[doc = " \\addtogroup pw_impl_module\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_impl_module {
    _unused: [u8; 0],
}
#[doc = " \\addtogroup pw_impl_port\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_impl_port {
    _unused: [u8; 0],
}
#[doc = " \\addtogroup pw_control\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_control {
    _unused: [u8; 0],
}
#[doc = " Port events, use \\ref pw_control_add_listener"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_control_events {
    pub version: u32,
    #[doc = " The control is destroyed"]
    pub destroy: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " The control is freed"]
    pub free: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " control is linked to another control"]
    pub linked: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, other: *mut pw_control),
    >,
    #[doc = " control is unlinked from another control"]
    pub unlinked: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, other: *mut pw_control),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_control_events"][::std::mem::size_of::<pw_control_events>() - 40usize];
    ["Alignment of pw_control_events"][::std::mem::align_of::<pw_control_events>() - 8usize];
    ["Offset of field: pw_control_events::version"]
        [::std::mem::offset_of!(pw_control_events, version) - 0usize];
    ["Offset of field: pw_control_events::destroy"]
        [::std::mem::offset_of!(pw_control_events, destroy) - 8usize];
    ["Offset of field: pw_control_events::free"]
        [::std::mem::offset_of!(pw_control_events, free) - 16usize];
    ["Offset of field: pw_control_events::linked"]
        [::std::mem::offset_of!(pw_control_events, linked) - 24usize];
    ["Offset of field: pw_control_events::unlinked"]
        [::std::mem::offset_of!(pw_control_events, unlinked) - 32usize];
};
unsafe extern "C" {
    #[doc = " Get the control parent port or NULL when not set"]
    pub fn pw_control_get_port(control: *mut pw_control) -> *mut pw_impl_port;
}
unsafe extern "C" {
    #[doc = " Add an event listener on the control. May be called multiple times.\n Each listener must be removed, but they may be removed in any order."]
    pub fn pw_control_add_listener(
        control: *mut pw_control,
        listener: *mut spa_hook,
        events: *const pw_control_events,
        data: *mut ::std::os::raw::c_void,
    );
}
#[doc = " \\addtogroup pw_impl_core\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_impl_core {
    _unused: [u8; 0],
}
#[doc = " Factory events, listen to them with \\ref pw_impl_core_add_listener"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_impl_core_events {
    pub version: u32,
    #[doc = " the core is destroyed"]
    pub destroy: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " the core is freed"]
    pub free: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " the core is initialized"]
    pub initialized: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_impl_core_events"][::std::mem::size_of::<pw_impl_core_events>() - 32usize];
    ["Alignment of pw_impl_core_events"][::std::mem::align_of::<pw_impl_core_events>() - 8usize];
    ["Offset of field: pw_impl_core_events::version"]
        [::std::mem::offset_of!(pw_impl_core_events, version) - 0usize];
    ["Offset of field: pw_impl_core_events::destroy"]
        [::std::mem::offset_of!(pw_impl_core_events, destroy) - 8usize];
    ["Offset of field: pw_impl_core_events::free"]
        [::std::mem::offset_of!(pw_impl_core_events, free) - 16usize];
    ["Offset of field: pw_impl_core_events::initialized"]
        [::std::mem::offset_of!(pw_impl_core_events, initialized) - 24usize];
};
unsafe extern "C" {
    pub fn pw_context_create_core(
        context: *mut pw_context,
        properties: *mut pw_properties,
        user_data_size: usize,
    ) -> *mut pw_impl_core;
}
unsafe extern "C" {
    pub fn pw_context_get_default_core(context: *mut pw_context) -> *mut pw_impl_core;
}
unsafe extern "C" {
    #[doc = " Get the core properties"]
    pub fn pw_impl_core_get_properties(core: *mut pw_impl_core) -> *const pw_properties;
}
unsafe extern "C" {
    #[doc = " Get the core information"]
    pub fn pw_impl_core_get_info(core: *mut pw_impl_core) -> *const pw_core_info;
}
unsafe extern "C" {
    #[doc = " Update the core properties"]
    pub fn pw_impl_core_update_properties(
        core: *mut pw_impl_core,
        dict: *const spa_dict,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pw_impl_core_register(
        core: *mut pw_impl_core,
        properties: *mut pw_properties,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pw_impl_core_destroy(core: *mut pw_impl_core);
}
unsafe extern "C" {
    pub fn pw_impl_core_get_user_data(core: *mut pw_impl_core) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " Get the global of this core"]
    pub fn pw_impl_core_get_global(core: *mut pw_impl_core) -> *mut pw_global;
}
unsafe extern "C" {
    #[doc = " Add an event listener"]
    pub fn pw_impl_core_add_listener(
        core: *mut pw_impl_core,
        listener: *mut spa_hook,
        events: *const pw_impl_core_events,
        data: *mut ::std::os::raw::c_void,
    );
}
#[doc = " \\addtogroup pw_impl_device\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_impl_device {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_device {
    pub iface: spa_interface,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_device"][::std::mem::size_of::<spa_device>() - 32usize];
    ["Alignment of spa_device"][::std::mem::align_of::<spa_device>() - 8usize];
    ["Offset of field: spa_device::iface"][::std::mem::offset_of!(spa_device, iface) - 0usize];
};
#[doc = " Information about the device and parameters it supports\n\n This information is part of the info event on a device."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_device_info {
    pub version: u32,
    pub change_mask: u64,
    pub flags: u64,
    #[doc = "< device properties"]
    pub props: *const spa_dict,
    #[doc = "< supported parameters"]
    pub params: *mut spa_param_info,
    #[doc = "< number of elements in params"]
    pub n_params: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_device_info"][::std::mem::size_of::<spa_device_info>() - 48usize];
    ["Alignment of spa_device_info"][::std::mem::align_of::<spa_device_info>() - 8usize];
    ["Offset of field: spa_device_info::version"]
        [::std::mem::offset_of!(spa_device_info, version) - 0usize];
    ["Offset of field: spa_device_info::change_mask"]
        [::std::mem::offset_of!(spa_device_info, change_mask) - 8usize];
    ["Offset of field: spa_device_info::flags"]
        [::std::mem::offset_of!(spa_device_info, flags) - 16usize];
    ["Offset of field: spa_device_info::props"]
        [::std::mem::offset_of!(spa_device_info, props) - 24usize];
    ["Offset of field: spa_device_info::params"]
        [::std::mem::offset_of!(spa_device_info, params) - 32usize];
    ["Offset of field: spa_device_info::n_params"]
        [::std::mem::offset_of!(spa_device_info, n_params) - 40usize];
};
#[doc = " Information about a device object\n\n This information is part of the object_info event on the device."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_device_object_info {
    pub version: u32,
    #[doc = "< the object type managed by this device"]
    pub type_: *const ::std::os::raw::c_char,
    #[doc = "< a factory name that implements the object"]
    pub factory_name: *const ::std::os::raw::c_char,
    pub change_mask: u64,
    pub flags: u64,
    #[doc = "< extra object properties"]
    pub props: *const spa_dict,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_device_object_info"][::std::mem::size_of::<spa_device_object_info>() - 48usize];
    ["Alignment of spa_device_object_info"]
        [::std::mem::align_of::<spa_device_object_info>() - 8usize];
    ["Offset of field: spa_device_object_info::version"]
        [::std::mem::offset_of!(spa_device_object_info, version) - 0usize];
    ["Offset of field: spa_device_object_info::type_"]
        [::std::mem::offset_of!(spa_device_object_info, type_) - 8usize];
    ["Offset of field: spa_device_object_info::factory_name"]
        [::std::mem::offset_of!(spa_device_object_info, factory_name) - 16usize];
    ["Offset of field: spa_device_object_info::change_mask"]
        [::std::mem::offset_of!(spa_device_object_info, change_mask) - 24usize];
    ["Offset of field: spa_device_object_info::flags"]
        [::std::mem::offset_of!(spa_device_object_info, flags) - 32usize];
    ["Offset of field: spa_device_object_info::props"]
        [::std::mem::offset_of!(spa_device_object_info, props) - 40usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_result_device_params {
    pub id: u32,
    pub index: u32,
    pub next: u32,
    pub param: *mut spa_pod,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_result_device_params"]
        [::std::mem::size_of::<spa_result_device_params>() - 24usize];
    ["Alignment of spa_result_device_params"]
        [::std::mem::align_of::<spa_result_device_params>() - 8usize];
    ["Offset of field: spa_result_device_params::id"]
        [::std::mem::offset_of!(spa_result_device_params, id) - 0usize];
    ["Offset of field: spa_result_device_params::index"]
        [::std::mem::offset_of!(spa_result_device_params, index) - 4usize];
    ["Offset of field: spa_result_device_params::next"]
        [::std::mem::offset_of!(spa_result_device_params, next) - 8usize];
    ["Offset of field: spa_result_device_params::param"]
        [::std::mem::offset_of!(spa_result_device_params, param) - 16usize];
};
#[doc = " spa_device_events:\n\n Events are always emitted from the main thread"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_device_events {
    pub version: u32,
    #[doc = " notify extra information about the device"]
    pub info: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, info: *const spa_device_info),
    >,
    #[doc = " notify a result"]
    pub result: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            seq: ::std::os::raw::c_int,
            res: ::std::os::raw::c_int,
            type_: u32,
            result: *const ::std::os::raw::c_void,
        ),
    >,
    #[doc = " a device event"]
    pub event: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, event: *const spa_event),
    >,
    #[doc = " info changed for an object managed by the device, info is NULL when\n the object is removed"]
    pub object_info: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            id: u32,
            info: *const spa_device_object_info,
        ),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_device_events"][::std::mem::size_of::<spa_device_events>() - 40usize];
    ["Alignment of spa_device_events"][::std::mem::align_of::<spa_device_events>() - 8usize];
    ["Offset of field: spa_device_events::version"]
        [::std::mem::offset_of!(spa_device_events, version) - 0usize];
    ["Offset of field: spa_device_events::info"]
        [::std::mem::offset_of!(spa_device_events, info) - 8usize];
    ["Offset of field: spa_device_events::result"]
        [::std::mem::offset_of!(spa_device_events, result) - 16usize];
    ["Offset of field: spa_device_events::event"]
        [::std::mem::offset_of!(spa_device_events, event) - 24usize];
    ["Offset of field: spa_device_events::object_info"]
        [::std::mem::offset_of!(spa_device_events, object_info) - 32usize];
};
#[doc = " spa_device_methods:"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_device_methods {
    pub version: u32,
    #[doc = " Set events to receive asynchronous notifications from\n the device.\n\n Setting the events will trigger the info event and an\n object_info event for each managed object on the new\n listener.\n\n \\param object a \\ref spa_device\n \\param listener a listener\n \\param events a struct \\ref spa_device_events\n \\param data data passed as first argument in functions of \\a events\n \\return 0 on success\n\t   < 0 errno on error"]
    pub add_listener: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            listener: *mut spa_hook,
            events: *const spa_device_events,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Perform a sync operation.\n\n This method will emit the result event with the given sequence\n number synchronously or with the returned async return value\n asynchronously.\n\n Because all methods are serialized in the device, this can be used\n to wait for completion of all previous method calls.\n\n \\param seq a sequence number\n \\return 0 on success\n         -EINVAL when node is NULL\n         an async result"]
    pub sync: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            seq: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Enumerate the parameters of a device.\n\n Parameters are identified with an \\a id. Some parameters can have\n multiple values, see the documentation of the parameter id.\n\n Parameters can be filtered by passing a non-NULL \\a filter.\n\n The result callback will be called at most \\a max times with a\n struct spa_result_device_params as the result.\n\n This function must be called from the main thread.\n\n \\param device a \\ref spa_device\n \\param seq a sequence number to pass to the result function\n \\param id the param id to enumerate\n \\param index the index of enumeration, pass 0 for the first item.\n \\param max the maximum number of items to iterate\n \\param filter and optional filter to use\n \\return 0 when there are no more parameters to enumerate\n         -EINVAL when invalid arguments are given\n         -ENOENT the parameter \\a id is unknown\n         -ENOTSUP when there are no parameters\n                 implemented on \\a device"]
    pub enum_params: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            seq: ::std::os::raw::c_int,
            id: u32,
            index: u32,
            max: u32,
            filter: *const spa_pod,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Set the configurable parameter in \\a device.\n\n Usually, \\a param will be obtained from enum_params and then\n modified but it is also possible to set another spa_pod\n as long as its keys and types match a supported object.\n\n Objects with property keys that are not known are ignored.\n\n This function must be called from the main thread.\n\n \\param object \\ref spa_device\n \\param id the parameter id to configure\n \\param flags additional flags\n \\param param the parameter to configure\n\n \\return 0 on success\n         -EINVAL when invalid arguments are given\n         -ENOTSUP when there are no parameters implemented on \\a device\n         -ENOENT the parameter is unknown"]
    pub set_param: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            id: u32,
            flags: u32,
            param: *const spa_pod,
        ) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_device_methods"][::std::mem::size_of::<spa_device_methods>() - 40usize];
    ["Alignment of spa_device_methods"][::std::mem::align_of::<spa_device_methods>() - 8usize];
    ["Offset of field: spa_device_methods::version"]
        [::std::mem::offset_of!(spa_device_methods, version) - 0usize];
    ["Offset of field: spa_device_methods::add_listener"]
        [::std::mem::offset_of!(spa_device_methods, add_listener) - 8usize];
    ["Offset of field: spa_device_methods::sync"]
        [::std::mem::offset_of!(spa_device_methods, sync) - 16usize];
    ["Offset of field: spa_device_methods::enum_params"]
        [::std::mem::offset_of!(spa_device_methods, enum_params) - 24usize];
    ["Offset of field: spa_device_methods::set_param"]
        [::std::mem::offset_of!(spa_device_methods, set_param) - 32usize];
};
#[doc = " Device events, listen to them with \\ref pw_impl_device_add_listener"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_impl_device_events {
    pub version: u32,
    #[doc = " the device is destroyed"]
    pub destroy: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " the device is freed"]
    pub free: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " the device is initialized"]
    pub initialized: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " the device info changed"]
    pub info_changed: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, info: *const pw_device_info),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_impl_device_events"][::std::mem::size_of::<pw_impl_device_events>() - 40usize];
    ["Alignment of pw_impl_device_events"]
        [::std::mem::align_of::<pw_impl_device_events>() - 8usize];
    ["Offset of field: pw_impl_device_events::version"]
        [::std::mem::offset_of!(pw_impl_device_events, version) - 0usize];
    ["Offset of field: pw_impl_device_events::destroy"]
        [::std::mem::offset_of!(pw_impl_device_events, destroy) - 8usize];
    ["Offset of field: pw_impl_device_events::free"]
        [::std::mem::offset_of!(pw_impl_device_events, free) - 16usize];
    ["Offset of field: pw_impl_device_events::initialized"]
        [::std::mem::offset_of!(pw_impl_device_events, initialized) - 24usize];
    ["Offset of field: pw_impl_device_events::info_changed"]
        [::std::mem::offset_of!(pw_impl_device_events, info_changed) - 32usize];
};
unsafe extern "C" {
    pub fn pw_context_create_device(
        context: *mut pw_context,
        properties: *mut pw_properties,
        user_data_size: usize,
    ) -> *mut pw_impl_device;
}
unsafe extern "C" {
    pub fn pw_impl_device_register(
        device: *mut pw_impl_device,
        properties: *mut pw_properties,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pw_impl_device_destroy(device: *mut pw_impl_device);
}
unsafe extern "C" {
    pub fn pw_impl_device_get_user_data(device: *mut pw_impl_device)
        -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " Set the device implementation"]
    pub fn pw_impl_device_set_implementation(
        device: *mut pw_impl_device,
        spa_device: *mut spa_device,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the device implementation"]
    pub fn pw_impl_device_get_implementation(device: *mut pw_impl_device) -> *mut spa_device;
}
unsafe extern "C" {
    #[doc = " Get the global of this device"]
    pub fn pw_impl_device_get_global(device: *mut pw_impl_device) -> *mut pw_global;
}
unsafe extern "C" {
    #[doc = " Add an event listener"]
    pub fn pw_impl_device_add_listener(
        device: *mut pw_impl_device,
        listener: *mut spa_hook,
        events: *const pw_impl_device_events,
        data: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn pw_impl_device_update_properties(
        device: *mut pw_impl_device,
        dict: *const spa_dict,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pw_impl_device_get_properties(device: *mut pw_impl_device) -> *const pw_properties;
}
unsafe extern "C" {
    pub fn pw_impl_device_for_each_param(
        device: *mut pw_impl_device,
        seq: ::std::os::raw::c_int,
        param_id: u32,
        index: u32,
        max: u32,
        filter: *const spa_pod,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                data: *mut ::std::os::raw::c_void,
                seq: ::std::os::raw::c_int,
                id: u32,
                index: u32,
                next: u32,
                param: *mut spa_pod,
            ) -> ::std::os::raw::c_int,
        >,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
#[doc = " \\addtogroup pw_impl_factory\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_impl_factory {
    _unused: [u8; 0],
}
#[doc = " Factory events, listen to them with \\ref pw_impl_factory_add_listener"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_impl_factory_events {
    pub version: u32,
    #[doc = " the factory is destroyed"]
    pub destroy: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " the factory is freed"]
    pub free: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " the factory is initialized"]
    pub initialized: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_impl_factory_events"][::std::mem::size_of::<pw_impl_factory_events>() - 32usize];
    ["Alignment of pw_impl_factory_events"]
        [::std::mem::align_of::<pw_impl_factory_events>() - 8usize];
    ["Offset of field: pw_impl_factory_events::version"]
        [::std::mem::offset_of!(pw_impl_factory_events, version) - 0usize];
    ["Offset of field: pw_impl_factory_events::destroy"]
        [::std::mem::offset_of!(pw_impl_factory_events, destroy) - 8usize];
    ["Offset of field: pw_impl_factory_events::free"]
        [::std::mem::offset_of!(pw_impl_factory_events, free) - 16usize];
    ["Offset of field: pw_impl_factory_events::initialized"]
        [::std::mem::offset_of!(pw_impl_factory_events, initialized) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_impl_factory_implementation {
    pub version: u32,
    #[doc = " The function to create an object from this factory"]
    pub create_object: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            resource: *mut pw_resource,
            type_: *const ::std::os::raw::c_char,
            version: u32,
            properties: *mut pw_properties,
            new_id: u32,
        ) -> *mut ::std::os::raw::c_void,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_impl_factory_implementation"]
        [::std::mem::size_of::<pw_impl_factory_implementation>() - 16usize];
    ["Alignment of pw_impl_factory_implementation"]
        [::std::mem::align_of::<pw_impl_factory_implementation>() - 8usize];
    ["Offset of field: pw_impl_factory_implementation::version"]
        [::std::mem::offset_of!(pw_impl_factory_implementation, version) - 0usize];
    ["Offset of field: pw_impl_factory_implementation::create_object"]
        [::std::mem::offset_of!(pw_impl_factory_implementation, create_object) - 8usize];
};
unsafe extern "C" {
    pub fn pw_context_create_factory(
        context: *mut pw_context,
        name: *const ::std::os::raw::c_char,
        type_: *const ::std::os::raw::c_char,
        version: u32,
        properties: *mut pw_properties,
        user_data_size: usize,
    ) -> *mut pw_impl_factory;
}
unsafe extern "C" {
    #[doc = " Get the factory properties"]
    pub fn pw_impl_factory_get_properties(factory: *mut pw_impl_factory) -> *const pw_properties;
}
unsafe extern "C" {
    #[doc = " Get the factory info"]
    pub fn pw_impl_factory_get_info(factory: *mut pw_impl_factory) -> *const pw_factory_info;
}
unsafe extern "C" {
    #[doc = " Update the factory properties"]
    pub fn pw_impl_factory_update_properties(
        factory: *mut pw_impl_factory,
        dict: *const spa_dict,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pw_impl_factory_register(
        factory: *mut pw_impl_factory,
        properties: *mut pw_properties,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pw_impl_factory_destroy(factory: *mut pw_impl_factory);
}
unsafe extern "C" {
    pub fn pw_impl_factory_get_user_data(
        factory: *mut pw_impl_factory,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " Get the global of this factory"]
    pub fn pw_impl_factory_get_global(factory: *mut pw_impl_factory) -> *mut pw_global;
}
unsafe extern "C" {
    #[doc = " Add an event listener"]
    pub fn pw_impl_factory_add_listener(
        factory: *mut pw_impl_factory,
        listener: *mut spa_hook,
        events: *const pw_impl_factory_events,
        data: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn pw_impl_factory_set_implementation(
        factory: *mut pw_impl_factory,
        implementation: *const pw_impl_factory_implementation,
        data: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn pw_impl_factory_create_object(
        factory: *mut pw_impl_factory,
        resource: *mut pw_resource,
        type_: *const ::std::os::raw::c_char,
        version: u32,
        properties: *mut pw_properties,
        new_id: u32,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " Find a factory by name"]
    pub fn pw_context_find_factory(
        context: *mut pw_context,
        name: *const ::std::os::raw::c_char,
    ) -> *mut pw_impl_factory;
}
#[doc = " \\addtogroup pw_impl_link\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_impl_link {
    _unused: [u8; 0],
}
#[doc = " link events added with \\ref pw_impl_link_add_listener"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_impl_link_events {
    pub version: u32,
    #[doc = " A link is destroyed"]
    pub destroy: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " A link is freed"]
    pub free: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " a Link is initialized"]
    pub initialized: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " The info changed on a link"]
    pub info_changed: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, info: *const pw_link_info),
    >,
    #[doc = " The link state changed, \\a error is only valid when the state is\n in error."]
    pub state_changed: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            old: pw_link_state,
            state: pw_link_state,
            error: *const ::std::os::raw::c_char,
        ),
    >,
    #[doc = " A port is unlinked"]
    pub port_unlinked: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, port: *mut pw_impl_port),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_impl_link_events"][::std::mem::size_of::<pw_impl_link_events>() - 56usize];
    ["Alignment of pw_impl_link_events"][::std::mem::align_of::<pw_impl_link_events>() - 8usize];
    ["Offset of field: pw_impl_link_events::version"]
        [::std::mem::offset_of!(pw_impl_link_events, version) - 0usize];
    ["Offset of field: pw_impl_link_events::destroy"]
        [::std::mem::offset_of!(pw_impl_link_events, destroy) - 8usize];
    ["Offset of field: pw_impl_link_events::free"]
        [::std::mem::offset_of!(pw_impl_link_events, free) - 16usize];
    ["Offset of field: pw_impl_link_events::initialized"]
        [::std::mem::offset_of!(pw_impl_link_events, initialized) - 24usize];
    ["Offset of field: pw_impl_link_events::info_changed"]
        [::std::mem::offset_of!(pw_impl_link_events, info_changed) - 32usize];
    ["Offset of field: pw_impl_link_events::state_changed"]
        [::std::mem::offset_of!(pw_impl_link_events, state_changed) - 40usize];
    ["Offset of field: pw_impl_link_events::port_unlinked"]
        [::std::mem::offset_of!(pw_impl_link_events, port_unlinked) - 48usize];
};
unsafe extern "C" {
    #[doc = " Make a new link between two ports\n \\return a newly allocated link"]
    pub fn pw_context_create_link(
        context: *mut pw_context,
        output: *mut pw_impl_port,
        input: *mut pw_impl_port,
        format_filter: *mut spa_pod,
        properties: *mut pw_properties,
        user_data_size: usize,
    ) -> *mut pw_impl_link;
}
unsafe extern "C" {
    #[doc = " Destroy a link"]
    pub fn pw_impl_link_destroy(link: *mut pw_impl_link);
}
unsafe extern "C" {
    #[doc = " Add an event listener to \\a link"]
    pub fn pw_impl_link_add_listener(
        link: *mut pw_impl_link,
        listener: *mut spa_hook,
        events: *const pw_impl_link_events,
        data: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = " Finish link configuration and register"]
    pub fn pw_impl_link_register(
        link: *mut pw_impl_link,
        properties: *mut pw_properties,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the context of a link"]
    pub fn pw_impl_link_get_context(link: *mut pw_impl_link) -> *mut pw_context;
}
unsafe extern "C" {
    #[doc = " Get the user_data of a link, the size of the memory is given when\n constructing the link"]
    pub fn pw_impl_link_get_user_data(link: *mut pw_impl_link) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " Get the link info"]
    pub fn pw_impl_link_get_info(link: *mut pw_impl_link) -> *const pw_link_info;
}
unsafe extern "C" {
    #[doc = " Get the global of the link"]
    pub fn pw_impl_link_get_global(link: *mut pw_impl_link) -> *mut pw_global;
}
unsafe extern "C" {
    #[doc = " Get the output port of the link"]
    pub fn pw_impl_link_get_output(link: *mut pw_impl_link) -> *mut pw_impl_port;
}
unsafe extern "C" {
    #[doc = " Get the input port of the link"]
    pub fn pw_impl_link_get_input(link: *mut pw_impl_link) -> *mut pw_impl_port;
}
unsafe extern "C" {
    #[doc = " Find the link between 2 ports"]
    pub fn pw_impl_link_find(
        output: *mut pw_impl_port,
        input: *mut pw_impl_port,
    ) -> *mut pw_impl_link;
}
#[doc = " \\addtogroup pw_impl_metadata\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_impl_metadata {
    _unused: [u8; 0],
}
#[doc = " Metadata events, listen to them with \\ref pw_impl_metadata_add_listener"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_impl_metadata_events {
    pub version: u32,
    #[doc = " the metadata is destroyed"]
    pub destroy: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " the metadata is freed"]
    pub free: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " a property changed"]
    pub property: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            subject: u32,
            key: *const ::std::os::raw::c_char,
            type_: *const ::std::os::raw::c_char,
            value: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_impl_metadata_events"][::std::mem::size_of::<pw_impl_metadata_events>() - 32usize];
    ["Alignment of pw_impl_metadata_events"]
        [::std::mem::align_of::<pw_impl_metadata_events>() - 8usize];
    ["Offset of field: pw_impl_metadata_events::version"]
        [::std::mem::offset_of!(pw_impl_metadata_events, version) - 0usize];
    ["Offset of field: pw_impl_metadata_events::destroy"]
        [::std::mem::offset_of!(pw_impl_metadata_events, destroy) - 8usize];
    ["Offset of field: pw_impl_metadata_events::free"]
        [::std::mem::offset_of!(pw_impl_metadata_events, free) - 16usize];
    ["Offset of field: pw_impl_metadata_events::property"]
        [::std::mem::offset_of!(pw_impl_metadata_events, property) - 24usize];
};
unsafe extern "C" {
    pub fn pw_context_create_metadata(
        context: *mut pw_context,
        name: *const ::std::os::raw::c_char,
        properties: *mut pw_properties,
        user_data_size: usize,
    ) -> *mut pw_impl_metadata;
}
unsafe extern "C" {
    #[doc = " Get the metadata properties"]
    pub fn pw_impl_metadata_get_properties(metadata: *mut pw_impl_metadata)
        -> *const pw_properties;
}
unsafe extern "C" {
    pub fn pw_impl_metadata_register(
        metadata: *mut pw_impl_metadata,
        properties: *mut pw_properties,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pw_impl_metadata_destroy(metadata: *mut pw_impl_metadata);
}
unsafe extern "C" {
    pub fn pw_impl_metadata_get_user_data(
        metadata: *mut pw_impl_metadata,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn pw_impl_metadata_set_implementation(
        metadata: *mut pw_impl_metadata,
        impl_: *mut pw_metadata,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pw_impl_metadata_get_implementation(metadata: *mut pw_impl_metadata)
        -> *mut pw_metadata;
}
unsafe extern "C" {
    #[doc = " Get the global of this metadata"]
    pub fn pw_impl_metadata_get_global(metadata: *mut pw_impl_metadata) -> *mut pw_global;
}
unsafe extern "C" {
    #[doc = " Add an event listener"]
    pub fn pw_impl_metadata_add_listener(
        metadata: *mut pw_impl_metadata,
        listener: *mut spa_hook,
        events: *const pw_impl_metadata_events,
        data: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = " Set a property"]
    pub fn pw_impl_metadata_set_property(
        metadata: *mut pw_impl_metadata,
        subject: u32,
        key: *const ::std::os::raw::c_char,
        type_: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pw_impl_metadata_set_propertyf(
        metadata: *mut pw_impl_metadata,
        subject: u32,
        key: *const ::std::os::raw::c_char,
        type_: *const ::std::os::raw::c_char,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
#[doc = " Module init function signature\n\n \\param module A \\ref pw_impl_module\n \\param args Arguments to the module\n \\return 0 on success, < 0 otherwise with an errno style error\n\n A module should provide an init function with this signature. This function\n will be called when a module is loaded."]
pub type pw_impl_module_init_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        module: *mut pw_impl_module,
        args: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Module events added with \\ref pw_impl_module_add_listener"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_impl_module_events {
    pub version: u32,
    #[doc = " The module is destroyed. This is the time to unregister and\n destroy any objects created by the module."]
    pub destroy: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " The module is freed. This will be called after destroy() returns."]
    pub free: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " The module is initialized"]
    pub initialized: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " The module is registered. This is a good time to register\n objects created from the module."]
    pub registered: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_impl_module_events"][::std::mem::size_of::<pw_impl_module_events>() - 40usize];
    ["Alignment of pw_impl_module_events"]
        [::std::mem::align_of::<pw_impl_module_events>() - 8usize];
    ["Offset of field: pw_impl_module_events::version"]
        [::std::mem::offset_of!(pw_impl_module_events, version) - 0usize];
    ["Offset of field: pw_impl_module_events::destroy"]
        [::std::mem::offset_of!(pw_impl_module_events, destroy) - 8usize];
    ["Offset of field: pw_impl_module_events::free"]
        [::std::mem::offset_of!(pw_impl_module_events, free) - 16usize];
    ["Offset of field: pw_impl_module_events::initialized"]
        [::std::mem::offset_of!(pw_impl_module_events, initialized) - 24usize];
    ["Offset of field: pw_impl_module_events::registered"]
        [::std::mem::offset_of!(pw_impl_module_events, registered) - 32usize];
};
unsafe extern "C" {
    pub fn pw_context_load_module(
        context: *mut pw_context,
        name: *const ::std::os::raw::c_char,
        args: *const ::std::os::raw::c_char,
        properties: *mut pw_properties,
    ) -> *mut pw_impl_module;
}
unsafe extern "C" {
    #[doc = " Get the context of a module"]
    pub fn pw_impl_module_get_context(module: *mut pw_impl_module) -> *mut pw_context;
}
unsafe extern "C" {
    #[doc = " Get the global of a module"]
    pub fn pw_impl_module_get_global(module: *mut pw_impl_module) -> *mut pw_global;
}
unsafe extern "C" {
    #[doc = " Get the module properties"]
    pub fn pw_impl_module_get_properties(module: *mut pw_impl_module) -> *const pw_properties;
}
unsafe extern "C" {
    #[doc = " Update the module properties"]
    pub fn pw_impl_module_update_properties(
        module: *mut pw_impl_module,
        dict: *const spa_dict,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the module info"]
    pub fn pw_impl_module_get_info(module: *mut pw_impl_module) -> *const pw_module_info;
}
unsafe extern "C" {
    #[doc = " Add an event listener to a module"]
    pub fn pw_impl_module_add_listener(
        module: *mut pw_impl_module,
        listener: *mut spa_hook,
        events: *const pw_impl_module_events,
        data: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = " Destroy a module"]
    pub fn pw_impl_module_destroy(module: *mut pw_impl_module);
}
unsafe extern "C" {
    #[doc = " Schedule a destroy later on the main thread"]
    pub fn pw_impl_module_schedule_destroy(module: *mut pw_impl_module);
}
#[doc = " Node events, listen to them with \\ref pw_impl_node_add_listener"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_impl_node_events {
    pub version: u32,
    #[doc = " the node is destroyed"]
    pub destroy: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " the node is about to be freed"]
    pub free: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " the node is initialized"]
    pub initialized: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " a port is being initialized on the node"]
    pub port_init: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, port: *mut pw_impl_port),
    >,
    #[doc = " a port was added"]
    pub port_added: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, port: *mut pw_impl_port),
    >,
    #[doc = " a port was removed"]
    pub port_removed: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, port: *mut pw_impl_port),
    >,
    #[doc = " the node info changed"]
    pub info_changed: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, info: *const pw_node_info),
    >,
    #[doc = " a port on the node changed info"]
    pub port_info_changed: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            port: *mut pw_impl_port,
            info: *const pw_port_info,
        ),
    >,
    #[doc = " the node active state changed"]
    pub active_changed: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, active: bool),
    >,
    #[doc = " a new state is requested on the node"]
    pub state_request: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, state: pw_node_state),
    >,
    #[doc = " the state of the node changed"]
    pub state_changed: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            old: pw_node_state,
            state: pw_node_state,
            error: *const ::std::os::raw::c_char,
        ),
    >,
    #[doc = " a result was received"]
    pub result: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            seq: ::std::os::raw::c_int,
            res: ::std::os::raw::c_int,
            type_: u32,
            result: *const ::std::os::raw::c_void,
        ),
    >,
    #[doc = " an event is emitted"]
    pub event: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, event: *const spa_event),
    >,
    #[doc = " the driver of the node changed"]
    pub driver_changed: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            old: *mut pw_impl_node,
            driver: *mut pw_impl_node,
        ),
    >,
    #[doc = " a peer was added"]
    pub peer_added: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, peer: *mut pw_impl_node),
    >,
    #[doc = " a peer was removed"]
    pub peer_removed: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, peer: *mut pw_impl_node),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_impl_node_events"][::std::mem::size_of::<pw_impl_node_events>() - 136usize];
    ["Alignment of pw_impl_node_events"][::std::mem::align_of::<pw_impl_node_events>() - 8usize];
    ["Offset of field: pw_impl_node_events::version"]
        [::std::mem::offset_of!(pw_impl_node_events, version) - 0usize];
    ["Offset of field: pw_impl_node_events::destroy"]
        [::std::mem::offset_of!(pw_impl_node_events, destroy) - 8usize];
    ["Offset of field: pw_impl_node_events::free"]
        [::std::mem::offset_of!(pw_impl_node_events, free) - 16usize];
    ["Offset of field: pw_impl_node_events::initialized"]
        [::std::mem::offset_of!(pw_impl_node_events, initialized) - 24usize];
    ["Offset of field: pw_impl_node_events::port_init"]
        [::std::mem::offset_of!(pw_impl_node_events, port_init) - 32usize];
    ["Offset of field: pw_impl_node_events::port_added"]
        [::std::mem::offset_of!(pw_impl_node_events, port_added) - 40usize];
    ["Offset of field: pw_impl_node_events::port_removed"]
        [::std::mem::offset_of!(pw_impl_node_events, port_removed) - 48usize];
    ["Offset of field: pw_impl_node_events::info_changed"]
        [::std::mem::offset_of!(pw_impl_node_events, info_changed) - 56usize];
    ["Offset of field: pw_impl_node_events::port_info_changed"]
        [::std::mem::offset_of!(pw_impl_node_events, port_info_changed) - 64usize];
    ["Offset of field: pw_impl_node_events::active_changed"]
        [::std::mem::offset_of!(pw_impl_node_events, active_changed) - 72usize];
    ["Offset of field: pw_impl_node_events::state_request"]
        [::std::mem::offset_of!(pw_impl_node_events, state_request) - 80usize];
    ["Offset of field: pw_impl_node_events::state_changed"]
        [::std::mem::offset_of!(pw_impl_node_events, state_changed) - 88usize];
    ["Offset of field: pw_impl_node_events::result"]
        [::std::mem::offset_of!(pw_impl_node_events, result) - 96usize];
    ["Offset of field: pw_impl_node_events::event"]
        [::std::mem::offset_of!(pw_impl_node_events, event) - 104usize];
    ["Offset of field: pw_impl_node_events::driver_changed"]
        [::std::mem::offset_of!(pw_impl_node_events, driver_changed) - 112usize];
    ["Offset of field: pw_impl_node_events::peer_added"]
        [::std::mem::offset_of!(pw_impl_node_events, peer_added) - 120usize];
    ["Offset of field: pw_impl_node_events::peer_removed"]
        [::std::mem::offset_of!(pw_impl_node_events, peer_removed) - 128usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_impl_node_rt_events {
    pub version: u32,
    #[doc = " the node is drained"]
    pub drained: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " the node had an xrun"]
    pub xrun: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " the driver node starts processing"]
    pub start: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " the driver node completed processing"]
    pub complete: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " the driver node did not complete processing"]
    pub incomplete: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " the node had a timeout"]
    pub timeout: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_impl_node_rt_events"][::std::mem::size_of::<pw_impl_node_rt_events>() - 56usize];
    ["Alignment of pw_impl_node_rt_events"]
        [::std::mem::align_of::<pw_impl_node_rt_events>() - 8usize];
    ["Offset of field: pw_impl_node_rt_events::version"]
        [::std::mem::offset_of!(pw_impl_node_rt_events, version) - 0usize];
    ["Offset of field: pw_impl_node_rt_events::drained"]
        [::std::mem::offset_of!(pw_impl_node_rt_events, drained) - 8usize];
    ["Offset of field: pw_impl_node_rt_events::xrun"]
        [::std::mem::offset_of!(pw_impl_node_rt_events, xrun) - 16usize];
    ["Offset of field: pw_impl_node_rt_events::start"]
        [::std::mem::offset_of!(pw_impl_node_rt_events, start) - 24usize];
    ["Offset of field: pw_impl_node_rt_events::complete"]
        [::std::mem::offset_of!(pw_impl_node_rt_events, complete) - 32usize];
    ["Offset of field: pw_impl_node_rt_events::incomplete"]
        [::std::mem::offset_of!(pw_impl_node_rt_events, incomplete) - 40usize];
    ["Offset of field: pw_impl_node_rt_events::timeout"]
        [::std::mem::offset_of!(pw_impl_node_rt_events, timeout) - 48usize];
};
unsafe extern "C" {
    #[doc = " Create a new node"]
    pub fn pw_context_create_node(
        context: *mut pw_context,
        properties: *mut pw_properties,
        user_data_size: usize,
    ) -> *mut pw_impl_node;
}
unsafe extern "C" {
    #[doc = " Complete initialization of the node and register"]
    pub fn pw_impl_node_register(
        node: *mut pw_impl_node,
        properties: *mut pw_properties,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Destroy a node"]
    pub fn pw_impl_node_destroy(node: *mut pw_impl_node);
}
unsafe extern "C" {
    #[doc = " Get the node info"]
    pub fn pw_impl_node_get_info(node: *mut pw_impl_node) -> *const pw_node_info;
}
unsafe extern "C" {
    #[doc = " Get node user_data. The size of the memory was given in \\ref pw_context_create_node"]
    pub fn pw_impl_node_get_user_data(node: *mut pw_impl_node) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " Get the context of this node"]
    pub fn pw_impl_node_get_context(node: *mut pw_impl_node) -> *mut pw_context;
}
unsafe extern "C" {
    #[doc = " Get the global of this node"]
    pub fn pw_impl_node_get_global(node: *mut pw_impl_node) -> *mut pw_global;
}
unsafe extern "C" {
    #[doc = " Get the node properties"]
    pub fn pw_impl_node_get_properties(node: *mut pw_impl_node) -> *const pw_properties;
}
unsafe extern "C" {
    #[doc = " Update the node properties"]
    pub fn pw_impl_node_update_properties(
        node: *mut pw_impl_node,
        dict: *const spa_dict,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Set the node implementation"]
    pub fn pw_impl_node_set_implementation(
        node: *mut pw_impl_node,
        spa_node: *mut spa_node,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the node implementation"]
    pub fn pw_impl_node_get_implementation(node: *mut pw_impl_node) -> *mut spa_node;
}
unsafe extern "C" {
    #[doc = " Add an event listener"]
    pub fn pw_impl_node_add_listener(
        node: *mut pw_impl_node,
        listener: *mut spa_hook,
        events: *const pw_impl_node_events,
        data: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = " Add an rt_event listener"]
    pub fn pw_impl_node_add_rt_listener(
        node: *mut pw_impl_node,
        listener: *mut spa_hook,
        events: *const pw_impl_node_rt_events,
        data: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn pw_impl_node_remove_rt_listener(node: *mut pw_impl_node, listener: *mut spa_hook);
}
unsafe extern "C" {
    #[doc = " Iterate the ports in the given direction. The callback should return\n 0 to fetch the next item, any other value stops the iteration and returns\n the value. When all callbacks return 0, this function returns 0 when all\n items are iterated."]
    pub fn pw_impl_node_for_each_port(
        node: *mut pw_impl_node,
        direction: spa_direction,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                data: *mut ::std::os::raw::c_void,
                port: *mut pw_impl_port,
            ) -> ::std::os::raw::c_int,
        >,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pw_impl_node_for_each_param(
        node: *mut pw_impl_node,
        seq: ::std::os::raw::c_int,
        param_id: u32,
        index: u32,
        max: u32,
        filter: *const spa_pod,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                data: *mut ::std::os::raw::c_void,
                seq: ::std::os::raw::c_int,
                id: u32,
                index: u32,
                next: u32,
                param: *mut spa_pod,
            ) -> ::std::os::raw::c_int,
        >,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Find the port with direction and port_id or NULL when not found. Passing\n PW_ID_ANY for port_id will return any port, preferably an unlinked one."]
    pub fn pw_impl_node_find_port(
        node: *mut pw_impl_node,
        direction: spa_direction,
        port_id: u32,
    ) -> *mut pw_impl_port;
}
unsafe extern "C" {
    #[doc = " Get a free unused port_id from the node"]
    pub fn pw_impl_node_get_free_port_id(node: *mut pw_impl_node, direction: spa_direction) -> u32;
}
unsafe extern "C" {
    pub fn pw_impl_node_initialized(node: *mut pw_impl_node) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Set a node active. This will start negotiation with all linked active\n nodes and start data transport"]
    pub fn pw_impl_node_set_active(node: *mut pw_impl_node, active: bool) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Check if a node is active"]
    pub fn pw_impl_node_is_active(node: *mut pw_impl_node) -> bool;
}
unsafe extern "C" {
    #[doc = " Check if a node is active, Since 0.3.39"]
    pub fn pw_impl_node_send_command(
        node: *mut pw_impl_node,
        command: *const spa_command,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Set a param on the node, Since 0.3.65"]
    pub fn pw_impl_node_set_param(
        node: *mut pw_impl_node,
        id: u32,
        flags: u32,
        param: *const spa_pod,
    ) -> ::std::os::raw::c_int;
}
#[doc = "< the port is in error"]
pub const pw_impl_port_state_PW_IMPL_PORT_STATE_ERROR: pw_impl_port_state = -1;
#[doc = "< the port is being created"]
pub const pw_impl_port_state_PW_IMPL_PORT_STATE_INIT: pw_impl_port_state = 0;
#[doc = "< the port is ready for format negotiation"]
pub const pw_impl_port_state_PW_IMPL_PORT_STATE_CONFIGURE: pw_impl_port_state = 1;
#[doc = "< the port is ready for buffer allocation"]
pub const pw_impl_port_state_PW_IMPL_PORT_STATE_READY: pw_impl_port_state = 2;
#[doc = "< the port is paused"]
pub const pw_impl_port_state_PW_IMPL_PORT_STATE_PAUSED: pw_impl_port_state = 3;
pub type pw_impl_port_state = ::std::os::raw::c_int;
#[doc = " Port events, use \\ref pw_impl_port_add_listener"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_impl_port_events {
    pub version: u32,
    #[doc = " The port is destroyed"]
    pub destroy: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " The port is freed"]
    pub free: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " The port is initialized"]
    pub initialized: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " the port info changed"]
    pub info_changed: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, info: *const pw_port_info),
    >,
    #[doc = " a new link is added on this port"]
    pub link_added: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, link: *mut pw_impl_link),
    >,
    #[doc = " a link is removed from this port"]
    pub link_removed: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, link: *mut pw_impl_link),
    >,
    #[doc = " the state of the port changed"]
    pub state_changed: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            old: pw_impl_port_state,
            state: pw_impl_port_state,
            error: *const ::std::os::raw::c_char,
        ),
    >,
    #[doc = " a control was added to the port"]
    pub control_added: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, control: *mut pw_control),
    >,
    #[doc = " a control was removed from the port"]
    pub control_removed: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, control: *mut pw_control),
    >,
    #[doc = " a parameter changed, since version 1"]
    pub param_changed:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, id: u32)>,
    #[doc = " latency changed. Since version 2"]
    pub latency_changed:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " tag changed. Since version 3"]
    pub tag_changed: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_impl_port_events"][::std::mem::size_of::<pw_impl_port_events>() - 104usize];
    ["Alignment of pw_impl_port_events"][::std::mem::align_of::<pw_impl_port_events>() - 8usize];
    ["Offset of field: pw_impl_port_events::version"]
        [::std::mem::offset_of!(pw_impl_port_events, version) - 0usize];
    ["Offset of field: pw_impl_port_events::destroy"]
        [::std::mem::offset_of!(pw_impl_port_events, destroy) - 8usize];
    ["Offset of field: pw_impl_port_events::free"]
        [::std::mem::offset_of!(pw_impl_port_events, free) - 16usize];
    ["Offset of field: pw_impl_port_events::initialized"]
        [::std::mem::offset_of!(pw_impl_port_events, initialized) - 24usize];
    ["Offset of field: pw_impl_port_events::info_changed"]
        [::std::mem::offset_of!(pw_impl_port_events, info_changed) - 32usize];
    ["Offset of field: pw_impl_port_events::link_added"]
        [::std::mem::offset_of!(pw_impl_port_events, link_added) - 40usize];
    ["Offset of field: pw_impl_port_events::link_removed"]
        [::std::mem::offset_of!(pw_impl_port_events, link_removed) - 48usize];
    ["Offset of field: pw_impl_port_events::state_changed"]
        [::std::mem::offset_of!(pw_impl_port_events, state_changed) - 56usize];
    ["Offset of field: pw_impl_port_events::control_added"]
        [::std::mem::offset_of!(pw_impl_port_events, control_added) - 64usize];
    ["Offset of field: pw_impl_port_events::control_removed"]
        [::std::mem::offset_of!(pw_impl_port_events, control_removed) - 72usize];
    ["Offset of field: pw_impl_port_events::param_changed"]
        [::std::mem::offset_of!(pw_impl_port_events, param_changed) - 80usize];
    ["Offset of field: pw_impl_port_events::latency_changed"]
        [::std::mem::offset_of!(pw_impl_port_events, latency_changed) - 88usize];
    ["Offset of field: pw_impl_port_events::tag_changed"]
        [::std::mem::offset_of!(pw_impl_port_events, tag_changed) - 96usize];
};
unsafe extern "C" {
    #[doc = " Create a new port\n \\return a newly allocated port"]
    pub fn pw_context_create_port(
        context: *mut pw_context,
        direction: spa_direction,
        port_id: u32,
        info: *const spa_port_info,
        user_data_size: usize,
    ) -> *mut pw_impl_port;
}
unsafe extern "C" {
    #[doc = " Get the port direction"]
    pub fn pw_impl_port_get_direction(port: *mut pw_impl_port) -> spa_direction;
}
unsafe extern "C" {
    #[doc = " Get the port properties"]
    pub fn pw_impl_port_get_properties(port: *mut pw_impl_port) -> *const pw_properties;
}
unsafe extern "C" {
    #[doc = " Update the port properties"]
    pub fn pw_impl_port_update_properties(
        port: *mut pw_impl_port,
        dict: *const spa_dict,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the port info"]
    pub fn pw_impl_port_get_info(port: *mut pw_impl_port) -> *const pw_port_info;
}
unsafe extern "C" {
    #[doc = " Get the port id"]
    pub fn pw_impl_port_get_id(port: *mut pw_impl_port) -> u32;
}
unsafe extern "C" {
    #[doc = " Get the port state as a string"]
    pub fn pw_impl_port_state_as_string(state: pw_impl_port_state)
        -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Get the port parent node or NULL when not yet set"]
    pub fn pw_impl_port_get_node(port: *mut pw_impl_port) -> *mut pw_impl_node;
}
unsafe extern "C" {
    #[doc = " check is a port has links, return 0 if not, 1 if it is linked"]
    pub fn pw_impl_port_is_linked(port: *mut pw_impl_port) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Add a port to a node"]
    pub fn pw_impl_port_add(
        port: *mut pw_impl_port,
        node: *mut pw_impl_node,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Add an event listener on the port"]
    pub fn pw_impl_port_add_listener(
        port: *mut pw_impl_port,
        listener: *mut spa_hook,
        events: *const pw_impl_port_events,
        data: *mut ::std::os::raw::c_void,
    );
}
pub type pw_work_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        obj: *mut ::std::os::raw::c_void,
        data: *mut ::std::os::raw::c_void,
        res: ::std::os::raw::c_int,
        id: u32,
    ),
>;
unsafe extern "C" {
    pub fn pw_work_queue_new(loop_: *mut pw_loop) -> *mut pw_work_queue;
}
unsafe extern "C" {
    pub fn pw_work_queue_destroy(queue: *mut pw_work_queue);
}
unsafe extern "C" {
    pub fn pw_work_queue_add(
        queue: *mut pw_work_queue,
        obj: *mut ::std::os::raw::c_void,
        res: ::std::os::raw::c_int,
        func: pw_work_func_t,
        data: *mut ::std::os::raw::c_void,
    ) -> u32;
}
unsafe extern "C" {
    pub fn pw_work_queue_cancel(
        queue: *mut pw_work_queue,
        obj: *mut ::std::os::raw::c_void,
        id: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pw_work_queue_complete(
        queue: *mut pw_work_queue,
        obj: *mut ::std::os::raw::c_void,
        seq: u32,
        res: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type pw_global_bind_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        object: *mut ::std::os::raw::c_void,
        client: *mut pw_impl_client,
        permissions: u32,
        version: u32,
        id: u32,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Global events, use \\ref pw_global_add_listener"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_global_events {
    pub version: u32,
    #[doc = " The global is destroyed"]
    pub destroy: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " The global is freed"]
    pub free: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " The permissions changed for a client"]
    pub permissions_changed: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            client: *mut pw_impl_client,
            old_permissions: u32,
            new_permissions: u32,
        ),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_global_events"][::std::mem::size_of::<pw_global_events>() - 32usize];
    ["Alignment of pw_global_events"][::std::mem::align_of::<pw_global_events>() - 8usize];
    ["Offset of field: pw_global_events::version"]
        [::std::mem::offset_of!(pw_global_events, version) - 0usize];
    ["Offset of field: pw_global_events::destroy"]
        [::std::mem::offset_of!(pw_global_events, destroy) - 8usize];
    ["Offset of field: pw_global_events::free"]
        [::std::mem::offset_of!(pw_global_events, free) - 16usize];
    ["Offset of field: pw_global_events::permissions_changed"]
        [::std::mem::offset_of!(pw_global_events, permissions_changed) - 24usize];
};
unsafe extern "C" {
    #[doc = " Create a new global object"]
    pub fn pw_global_new(
        context: *mut pw_context,
        type_: *const ::std::os::raw::c_char,
        version: u32,
        permission_mask: u32,
        properties: *mut pw_properties,
        func: pw_global_bind_func_t,
        object: *mut ::std::os::raw::c_void,
    ) -> *mut pw_global;
}
unsafe extern "C" {
    #[doc = " Register a global object to the context registry"]
    pub fn pw_global_register(global: *mut pw_global) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Add an event listener on the global"]
    pub fn pw_global_add_listener(
        global: *mut pw_global,
        listener: *mut spa_hook,
        events: *const pw_global_events,
        data: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = " Get the permissions of the global for a given client"]
    pub fn pw_global_get_permissions(global: *mut pw_global, client: *mut pw_impl_client) -> u32;
}
unsafe extern "C" {
    #[doc = " Get the context object of this global"]
    pub fn pw_global_get_context(global: *mut pw_global) -> *mut pw_context;
}
unsafe extern "C" {
    #[doc = " Get the global type"]
    pub fn pw_global_get_type(global: *mut pw_global) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Check a global type"]
    pub fn pw_global_is_type(global: *mut pw_global, type_: *const ::std::os::raw::c_char) -> bool;
}
unsafe extern "C" {
    #[doc = " Get the global version"]
    pub fn pw_global_get_version(global: *mut pw_global) -> u32;
}
unsafe extern "C" {
    #[doc = " Get the global properties"]
    pub fn pw_global_get_properties(global: *mut pw_global) -> *const pw_properties;
}
unsafe extern "C" {
    #[doc = " Update the global properties, must be done when unregistered"]
    pub fn pw_global_update_keys(
        global: *mut pw_global,
        dict: *const spa_dict,
        keys: *const *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the object associated with the global. This depends on the type of the\n global"]
    pub fn pw_global_get_object(global: *mut pw_global) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " Get the unique id of the global"]
    pub fn pw_global_get_id(global: *mut pw_global) -> u32;
}
unsafe extern "C" {
    #[doc = " Get the serial number of the global"]
    pub fn pw_global_get_serial(global: *mut pw_global) -> u64;
}
unsafe extern "C" {
    #[doc = " Add a resource to a global"]
    pub fn pw_global_add_resource(
        global: *mut pw_global,
        resource: *mut pw_resource,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Iterate all resources added to the global The callback should return\n 0 to fetch the next item, any other value stops the iteration and returns\n the value. When all callbacks return 0, this function returns 0 when all\n items are iterated."]
    pub fn pw_global_for_each_resource(
        global: *mut pw_global,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                data: *mut ::std::os::raw::c_void,
                resource: *mut pw_resource,
            ) -> ::std::os::raw::c_int,
        >,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Let a client bind to a global"]
    pub fn pw_global_bind(
        global: *mut pw_global,
        client: *mut pw_impl_client,
        permissions: u32,
        version: u32,
        id: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pw_global_update_permissions(
        global: *mut pw_global,
        client: *mut pw_impl_client,
        old_permissions: u32,
        new_permissions: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Destroy a global"]
    pub fn pw_global_destroy(global: *mut pw_global);
}
#[doc = " The events that a client can emit"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_impl_client_events {
    pub version: u32,
    #[doc = " emitted when the client is destroyed"]
    pub destroy: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " emitted right before the client is freed"]
    pub free: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " the client is initialized"]
    pub initialized: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " emitted when the client info changed"]
    pub info_changed: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, info: *const pw_client_info),
    >,
    #[doc = " emitted when a new resource is added for client"]
    pub resource_added: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, resource: *mut pw_resource),
    >,
    #[doc = " emitted when a resource is removed"]
    pub resource_removed: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, resource: *mut pw_resource),
    >,
    #[doc = " emitted when the client becomes busy processing an asynchronous\n message. In the busy state no messages should be processed.\n Processing should resume when the client becomes not busy"]
    pub busy_changed:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, busy: bool)>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_impl_client_events"][::std::mem::size_of::<pw_impl_client_events>() - 64usize];
    ["Alignment of pw_impl_client_events"]
        [::std::mem::align_of::<pw_impl_client_events>() - 8usize];
    ["Offset of field: pw_impl_client_events::version"]
        [::std::mem::offset_of!(pw_impl_client_events, version) - 0usize];
    ["Offset of field: pw_impl_client_events::destroy"]
        [::std::mem::offset_of!(pw_impl_client_events, destroy) - 8usize];
    ["Offset of field: pw_impl_client_events::free"]
        [::std::mem::offset_of!(pw_impl_client_events, free) - 16usize];
    ["Offset of field: pw_impl_client_events::initialized"]
        [::std::mem::offset_of!(pw_impl_client_events, initialized) - 24usize];
    ["Offset of field: pw_impl_client_events::info_changed"]
        [::std::mem::offset_of!(pw_impl_client_events, info_changed) - 32usize];
    ["Offset of field: pw_impl_client_events::resource_added"]
        [::std::mem::offset_of!(pw_impl_client_events, resource_added) - 40usize];
    ["Offset of field: pw_impl_client_events::resource_removed"]
        [::std::mem::offset_of!(pw_impl_client_events, resource_removed) - 48usize];
    ["Offset of field: pw_impl_client_events::busy_changed"]
        [::std::mem::offset_of!(pw_impl_client_events, busy_changed) - 56usize];
};
unsafe extern "C" {
    #[doc = " Create a new client. This is mainly used by protocols."]
    pub fn pw_context_create_client(
        core: *mut pw_impl_core,
        protocol: *mut pw_protocol,
        properties: *mut pw_properties,
        user_data_size: usize,
    ) -> *mut pw_impl_client;
}
unsafe extern "C" {
    #[doc = " Destroy a previously created client"]
    pub fn pw_impl_client_destroy(client: *mut pw_impl_client);
}
unsafe extern "C" {
    #[doc = " Finish configuration and register a client"]
    pub fn pw_impl_client_register(
        client: *mut pw_impl_client,
        properties: *mut pw_properties,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the client user data"]
    pub fn pw_impl_client_get_user_data(client: *mut pw_impl_client)
        -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " Get the client information"]
    pub fn pw_impl_client_get_info(client: *mut pw_impl_client) -> *const pw_client_info;
}
unsafe extern "C" {
    #[doc = " Update the client properties"]
    pub fn pw_impl_client_update_properties(
        client: *mut pw_impl_client,
        dict: *const spa_dict,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Update the client permissions"]
    pub fn pw_impl_client_update_permissions(
        client: *mut pw_impl_client,
        n_permissions: u32,
        permissions: *const pw_permission,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " check if a client has permissions for global_id, Since 0.3.9"]
    pub fn pw_impl_client_check_permissions(
        client: *mut pw_impl_client,
        global_id: u32,
        permissions: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the client properties"]
    pub fn pw_impl_client_get_properties(client: *mut pw_impl_client) -> *const pw_properties;
}
unsafe extern "C" {
    #[doc = " Get the context used to create this client"]
    pub fn pw_impl_client_get_context(client: *mut pw_impl_client) -> *mut pw_context;
}
unsafe extern "C" {
    #[doc = " Get the protocol used to create this client"]
    pub fn pw_impl_client_get_protocol(client: *mut pw_impl_client) -> *mut pw_protocol;
}
unsafe extern "C" {
    #[doc = " Get the client core resource"]
    pub fn pw_impl_client_get_core_resource(client: *mut pw_impl_client) -> *mut pw_resource;
}
unsafe extern "C" {
    #[doc = " Get a resource with the given id"]
    pub fn pw_impl_client_find_resource(client: *mut pw_impl_client, id: u32) -> *mut pw_resource;
}
unsafe extern "C" {
    #[doc = " Get the global associated with this client"]
    pub fn pw_impl_client_get_global(client: *mut pw_impl_client) -> *mut pw_global;
}
unsafe extern "C" {
    #[doc = " Get the mempool associated with this client, Since 0.3.74"]
    pub fn pw_impl_client_get_mempool(client: *mut pw_impl_client) -> *mut pw_mempool;
}
unsafe extern "C" {
    #[doc = " listen to events from this client"]
    pub fn pw_impl_client_add_listener(
        client: *mut pw_impl_client,
        listener: *mut spa_hook,
        events: *const pw_impl_client_events,
        data: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = " Mark the client busy. This can be used when an asynchronous operation is\n started and no further processing is allowed to happen for the client"]
    pub fn pw_impl_client_set_busy(client: *mut pw_impl_client, busy: bool);
}
#[doc = " Resource events"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_resource_events {
    pub version: u32,
    #[doc = " The resource is destroyed"]
    pub destroy: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " a reply to a ping event completed"]
    pub pong: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, seq: ::std::os::raw::c_int),
    >,
    #[doc = " an error occurred on the resource"]
    pub error: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            seq: ::std::os::raw::c_int,
            res: ::std::os::raw::c_int,
            message: *const ::std::os::raw::c_char,
        ),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_resource_events"][::std::mem::size_of::<pw_resource_events>() - 32usize];
    ["Alignment of pw_resource_events"][::std::mem::align_of::<pw_resource_events>() - 8usize];
    ["Offset of field: pw_resource_events::version"]
        [::std::mem::offset_of!(pw_resource_events, version) - 0usize];
    ["Offset of field: pw_resource_events::destroy"]
        [::std::mem::offset_of!(pw_resource_events, destroy) - 8usize];
    ["Offset of field: pw_resource_events::pong"]
        [::std::mem::offset_of!(pw_resource_events, pong) - 16usize];
    ["Offset of field: pw_resource_events::error"]
        [::std::mem::offset_of!(pw_resource_events, error) - 24usize];
};
unsafe extern "C" {
    #[doc = " Make a new resource for client"]
    pub fn pw_resource_new(
        client: *mut pw_impl_client,
        id: u32,
        permissions: u32,
        type_: *const ::std::os::raw::c_char,
        version: u32,
        user_data_size: usize,
    ) -> *mut pw_resource;
}
unsafe extern "C" {
    #[doc = " Destroy a resource"]
    pub fn pw_resource_destroy(resource: *mut pw_resource);
}
unsafe extern "C" {
    #[doc = " Remove a resource, like pw_resource_destroy but without sending a\n remove_id message to the client"]
    pub fn pw_resource_remove(resource: *mut pw_resource);
}
unsafe extern "C" {
    #[doc = " Get the client owning this resource"]
    pub fn pw_resource_get_client(resource: *mut pw_resource) -> *mut pw_impl_client;
}
unsafe extern "C" {
    #[doc = " Get the unique id of this resource"]
    pub fn pw_resource_get_id(resource: *mut pw_resource) -> u32;
}
unsafe extern "C" {
    #[doc = " Get the permissions of this resource"]
    pub fn pw_resource_get_permissions(resource: *mut pw_resource) -> u32;
}
unsafe extern "C" {
    #[doc = " Get the type and optionally the version of this resource"]
    pub fn pw_resource_get_type(
        resource: *mut pw_resource,
        version: *mut u32,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Get the protocol used for this resource"]
    pub fn pw_resource_get_protocol(resource: *mut pw_resource) -> *mut pw_protocol;
}
unsafe extern "C" {
    #[doc = " Get the user data for the resource, the size was given in \\ref pw_resource_new"]
    pub fn pw_resource_get_user_data(resource: *mut pw_resource) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " Add an event listener"]
    pub fn pw_resource_add_listener(
        resource: *mut pw_resource,
        listener: *mut spa_hook,
        events: *const pw_resource_events,
        data: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = " Set the resource implementation."]
    pub fn pw_resource_add_object_listener(
        resource: *mut pw_resource,
        listener: *mut spa_hook,
        funcs: *const ::std::os::raw::c_void,
        data: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = " Generate an ping event for a resource. This will generate a pong event\n with the same \\a sequence number in the return value."]
    pub fn pw_resource_ping(
        resource: *mut pw_resource,
        seq: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " ref/unref a resource, Since 0.3.52"]
    pub fn pw_resource_ref(resource: *mut pw_resource);
}
unsafe extern "C" {
    pub fn pw_resource_unref(resource: *mut pw_resource);
}
unsafe extern "C" {
    #[doc = " Notify global id this resource is bound to"]
    pub fn pw_resource_set_bound_id(
        resource: *mut pw_resource,
        global_id: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the global id this resource is bound to or SPA_ID_INVALID when not bound"]
    pub fn pw_resource_get_bound_id(resource: *mut pw_resource) -> u32;
}
unsafe extern "C" {
    #[doc = " Generate an error for a resource"]
    pub fn pw_resource_error(
        resource: *mut pw_resource,
        res: ::std::os::raw::c_int,
        error: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    pub fn pw_resource_errorf(
        resource: *mut pw_resource,
        res: ::std::os::raw::c_int,
        error: *const ::std::os::raw::c_char,
        ...
    );
}
unsafe extern "C" {
    pub fn pw_resource_errorf_id(
        resource: *mut pw_resource,
        id: u32,
        res: ::std::os::raw::c_int,
        error: *const ::std::os::raw::c_char,
        ...
    );
}
unsafe extern "C" {
    #[doc = " Get the list of object listeners from a resource"]
    pub fn pw_resource_get_object_listeners(resource: *mut pw_resource) -> *mut spa_hook_list;
}
unsafe extern "C" {
    #[doc = " Get the marshal functions for the resource"]
    pub fn pw_resource_get_marshal(resource: *mut pw_resource) -> *const pw_protocol_marshal;
}
unsafe extern "C" {
    #[doc = " install a marshal function on a resource"]
    pub fn pw_resource_install_marshal(
        resource: *mut pw_resource,
        implementor: bool,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_protocol_native_message {
    pub id: u32,
    pub opcode: u32,
    pub data: *mut ::std::os::raw::c_void,
    pub size: u32,
    pub n_fds: u32,
    pub fds: *mut ::std::os::raw::c_int,
    pub seq: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_protocol_native_message"]
        [::std::mem::size_of::<pw_protocol_native_message>() - 40usize];
    ["Alignment of pw_protocol_native_message"]
        [::std::mem::align_of::<pw_protocol_native_message>() - 8usize];
    ["Offset of field: pw_protocol_native_message::id"]
        [::std::mem::offset_of!(pw_protocol_native_message, id) - 0usize];
    ["Offset of field: pw_protocol_native_message::opcode"]
        [::std::mem::offset_of!(pw_protocol_native_message, opcode) - 4usize];
    ["Offset of field: pw_protocol_native_message::data"]
        [::std::mem::offset_of!(pw_protocol_native_message, data) - 8usize];
    ["Offset of field: pw_protocol_native_message::size"]
        [::std::mem::offset_of!(pw_protocol_native_message, size) - 16usize];
    ["Offset of field: pw_protocol_native_message::n_fds"]
        [::std::mem::offset_of!(pw_protocol_native_message, n_fds) - 20usize];
    ["Offset of field: pw_protocol_native_message::fds"]
        [::std::mem::offset_of!(pw_protocol_native_message, fds) - 24usize];
    ["Offset of field: pw_protocol_native_message::seq"]
        [::std::mem::offset_of!(pw_protocol_native_message, seq) - 32usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_protocol_native_demarshal {
    pub func: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            msg: *const pw_protocol_native_message,
        ) -> ::std::os::raw::c_int,
    >,
    pub permissions: u32,
    pub flags: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_protocol_native_demarshal"]
        [::std::mem::size_of::<pw_protocol_native_demarshal>() - 16usize];
    ["Alignment of pw_protocol_native_demarshal"]
        [::std::mem::align_of::<pw_protocol_native_demarshal>() - 8usize];
    ["Offset of field: pw_protocol_native_demarshal::func"]
        [::std::mem::offset_of!(pw_protocol_native_demarshal, func) - 0usize];
    ["Offset of field: pw_protocol_native_demarshal::permissions"]
        [::std::mem::offset_of!(pw_protocol_native_demarshal, permissions) - 8usize];
    ["Offset of field: pw_protocol_native_demarshal::flags"]
        [::std::mem::offset_of!(pw_protocol_native_demarshal, flags) - 12usize];
};
#[doc = " \\ref pw_protocol_native_ext methods"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_protocol_native_ext {
    pub version: u32,
    pub begin_proxy: ::std::option::Option<
        unsafe extern "C" fn(
            proxy: *mut pw_proxy,
            opcode: u8,
            msg: *mut *mut pw_protocol_native_message,
        ) -> *mut spa_pod_builder,
    >,
    pub add_proxy_fd: ::std::option::Option<
        unsafe extern "C" fn(proxy: *mut pw_proxy, fd: ::std::os::raw::c_int) -> u32,
    >,
    pub get_proxy_fd: ::std::option::Option<
        unsafe extern "C" fn(proxy: *mut pw_proxy, index: u32) -> ::std::os::raw::c_int,
    >,
    pub end_proxy: ::std::option::Option<
        unsafe extern "C" fn(
            proxy: *mut pw_proxy,
            builder: *mut spa_pod_builder,
        ) -> ::std::os::raw::c_int,
    >,
    pub begin_resource: ::std::option::Option<
        unsafe extern "C" fn(
            resource: *mut pw_resource,
            opcode: u8,
            msg: *mut *mut pw_protocol_native_message,
        ) -> *mut spa_pod_builder,
    >,
    pub add_resource_fd: ::std::option::Option<
        unsafe extern "C" fn(resource: *mut pw_resource, fd: ::std::os::raw::c_int) -> u32,
    >,
    pub get_resource_fd: ::std::option::Option<
        unsafe extern "C" fn(resource: *mut pw_resource, index: u32) -> ::std::os::raw::c_int,
    >,
    pub end_resource: ::std::option::Option<
        unsafe extern "C" fn(
            resource: *mut pw_resource,
            builder: *mut spa_pod_builder,
        ) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_protocol_native_ext"][::std::mem::size_of::<pw_protocol_native_ext>() - 72usize];
    ["Alignment of pw_protocol_native_ext"]
        [::std::mem::align_of::<pw_protocol_native_ext>() - 8usize];
    ["Offset of field: pw_protocol_native_ext::version"]
        [::std::mem::offset_of!(pw_protocol_native_ext, version) - 0usize];
    ["Offset of field: pw_protocol_native_ext::begin_proxy"]
        [::std::mem::offset_of!(pw_protocol_native_ext, begin_proxy) - 8usize];
    ["Offset of field: pw_protocol_native_ext::add_proxy_fd"]
        [::std::mem::offset_of!(pw_protocol_native_ext, add_proxy_fd) - 16usize];
    ["Offset of field: pw_protocol_native_ext::get_proxy_fd"]
        [::std::mem::offset_of!(pw_protocol_native_ext, get_proxy_fd) - 24usize];
    ["Offset of field: pw_protocol_native_ext::end_proxy"]
        [::std::mem::offset_of!(pw_protocol_native_ext, end_proxy) - 32usize];
    ["Offset of field: pw_protocol_native_ext::begin_resource"]
        [::std::mem::offset_of!(pw_protocol_native_ext, begin_resource) - 40usize];
    ["Offset of field: pw_protocol_native_ext::add_resource_fd"]
        [::std::mem::offset_of!(pw_protocol_native_ext, add_resource_fd) - 48usize];
    ["Offset of field: pw_protocol_native_ext::get_resource_fd"]
        [::std::mem::offset_of!(pw_protocol_native_ext, get_resource_fd) - 56usize];
    ["Offset of field: pw_protocol_native_ext::end_resource"]
        [::std::mem::offset_of!(pw_protocol_native_ext, end_resource) - 64usize];
};
pub const pw_endpoint_link_state_PW_ENDPOINT_LINK_STATE_ERROR: pw_endpoint_link_state = -1;
pub const pw_endpoint_link_state_PW_ENDPOINT_LINK_STATE_PREPARING: pw_endpoint_link_state = 0;
pub const pw_endpoint_link_state_PW_ENDPOINT_LINK_STATE_INACTIVE: pw_endpoint_link_state = 1;
pub const pw_endpoint_link_state_PW_ENDPOINT_LINK_STATE_ACTIVE: pw_endpoint_link_state = 2;
#[doc = " \\addtogroup pw_session_manager\n \\{"]
pub type pw_endpoint_link_state = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_session_info {
    #[doc = "< version of this structure"]
    pub version: u32,
    #[doc = "< the session id (global)"]
    pub id: u32,
    #[doc = "< bitfield of changed fields since last call"]
    pub change_mask: u64,
    #[doc = "< extra properties"]
    pub props: *mut spa_dict,
    #[doc = "< parameters"]
    pub params: *mut spa_param_info,
    #[doc = "< number of items in \\a params"]
    pub n_params: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_session_info"][::std::mem::size_of::<pw_session_info>() - 40usize];
    ["Alignment of pw_session_info"][::std::mem::align_of::<pw_session_info>() - 8usize];
    ["Offset of field: pw_session_info::version"]
        [::std::mem::offset_of!(pw_session_info, version) - 0usize];
    ["Offset of field: pw_session_info::id"][::std::mem::offset_of!(pw_session_info, id) - 4usize];
    ["Offset of field: pw_session_info::change_mask"]
        [::std::mem::offset_of!(pw_session_info, change_mask) - 8usize];
    ["Offset of field: pw_session_info::props"]
        [::std::mem::offset_of!(pw_session_info, props) - 16usize];
    ["Offset of field: pw_session_info::params"]
        [::std::mem::offset_of!(pw_session_info, params) - 24usize];
    ["Offset of field: pw_session_info::n_params"]
        [::std::mem::offset_of!(pw_session_info, n_params) - 32usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_endpoint_info {
    #[doc = "< version of this structure"]
    pub version: u32,
    #[doc = "< the endpoint id (global)"]
    pub id: u32,
    #[doc = "< name of the endpoint"]
    pub name: *mut ::std::os::raw::c_char,
    #[doc = "< media class of the endpoint"]
    pub media_class: *mut ::std::os::raw::c_char,
    #[doc = "< direction of the endpoint"]
    pub direction: spa_direction,
    #[doc = "< additional flags"]
    pub flags: u32,
    #[doc = "< bitfield of changed fields since last call"]
    pub change_mask: u64,
    #[doc = "< number of streams available"]
    pub n_streams: u32,
    #[doc = "< the id of the controlling session"]
    pub session_id: u32,
    #[doc = "< extra properties"]
    pub props: *mut spa_dict,
    #[doc = "< parameters"]
    pub params: *mut spa_param_info,
    #[doc = "< number of items in \\a params"]
    pub n_params: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_endpoint_info"][::std::mem::size_of::<pw_endpoint_info>() - 72usize];
    ["Alignment of pw_endpoint_info"][::std::mem::align_of::<pw_endpoint_info>() - 8usize];
    ["Offset of field: pw_endpoint_info::version"]
        [::std::mem::offset_of!(pw_endpoint_info, version) - 0usize];
    ["Offset of field: pw_endpoint_info::id"]
        [::std::mem::offset_of!(pw_endpoint_info, id) - 4usize];
    ["Offset of field: pw_endpoint_info::name"]
        [::std::mem::offset_of!(pw_endpoint_info, name) - 8usize];
    ["Offset of field: pw_endpoint_info::media_class"]
        [::std::mem::offset_of!(pw_endpoint_info, media_class) - 16usize];
    ["Offset of field: pw_endpoint_info::direction"]
        [::std::mem::offset_of!(pw_endpoint_info, direction) - 24usize];
    ["Offset of field: pw_endpoint_info::flags"]
        [::std::mem::offset_of!(pw_endpoint_info, flags) - 28usize];
    ["Offset of field: pw_endpoint_info::change_mask"]
        [::std::mem::offset_of!(pw_endpoint_info, change_mask) - 32usize];
    ["Offset of field: pw_endpoint_info::n_streams"]
        [::std::mem::offset_of!(pw_endpoint_info, n_streams) - 40usize];
    ["Offset of field: pw_endpoint_info::session_id"]
        [::std::mem::offset_of!(pw_endpoint_info, session_id) - 44usize];
    ["Offset of field: pw_endpoint_info::props"]
        [::std::mem::offset_of!(pw_endpoint_info, props) - 48usize];
    ["Offset of field: pw_endpoint_info::params"]
        [::std::mem::offset_of!(pw_endpoint_info, params) - 56usize];
    ["Offset of field: pw_endpoint_info::n_params"]
        [::std::mem::offset_of!(pw_endpoint_info, n_params) - 64usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_endpoint_stream_info {
    #[doc = "< version of this structure"]
    pub version: u32,
    #[doc = "< the stream id (local or global)"]
    pub id: u32,
    #[doc = "< the endpoint id (global)"]
    pub endpoint_id: u32,
    #[doc = "< name of the stream"]
    pub name: *mut ::std::os::raw::c_char,
    #[doc = "< bitfield of changed fields since last call"]
    pub change_mask: u64,
    #[doc = "< information for linking this stream"]
    pub link_params: *mut spa_pod,
    #[doc = "< extra properties"]
    pub props: *mut spa_dict,
    #[doc = "< parameters"]
    pub params: *mut spa_param_info,
    #[doc = "< number of items in \\a params"]
    pub n_params: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_endpoint_stream_info"][::std::mem::size_of::<pw_endpoint_stream_info>() - 64usize];
    ["Alignment of pw_endpoint_stream_info"]
        [::std::mem::align_of::<pw_endpoint_stream_info>() - 8usize];
    ["Offset of field: pw_endpoint_stream_info::version"]
        [::std::mem::offset_of!(pw_endpoint_stream_info, version) - 0usize];
    ["Offset of field: pw_endpoint_stream_info::id"]
        [::std::mem::offset_of!(pw_endpoint_stream_info, id) - 4usize];
    ["Offset of field: pw_endpoint_stream_info::endpoint_id"]
        [::std::mem::offset_of!(pw_endpoint_stream_info, endpoint_id) - 8usize];
    ["Offset of field: pw_endpoint_stream_info::name"]
        [::std::mem::offset_of!(pw_endpoint_stream_info, name) - 16usize];
    ["Offset of field: pw_endpoint_stream_info::change_mask"]
        [::std::mem::offset_of!(pw_endpoint_stream_info, change_mask) - 24usize];
    ["Offset of field: pw_endpoint_stream_info::link_params"]
        [::std::mem::offset_of!(pw_endpoint_stream_info, link_params) - 32usize];
    ["Offset of field: pw_endpoint_stream_info::props"]
        [::std::mem::offset_of!(pw_endpoint_stream_info, props) - 40usize];
    ["Offset of field: pw_endpoint_stream_info::params"]
        [::std::mem::offset_of!(pw_endpoint_stream_info, params) - 48usize];
    ["Offset of field: pw_endpoint_stream_info::n_params"]
        [::std::mem::offset_of!(pw_endpoint_stream_info, n_params) - 56usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_endpoint_link_info {
    #[doc = "< version of this structure"]
    pub version: u32,
    #[doc = "< the link id (global)"]
    pub id: u32,
    #[doc = "< the session id (global)"]
    pub session_id: u32,
    #[doc = "< the output endpoint id (global)"]
    pub output_endpoint_id: u32,
    #[doc = "< the output stream id (local or global)"]
    pub output_stream_id: u32,
    #[doc = "< the input endpoint id (global)"]
    pub input_endpoint_id: u32,
    #[doc = "< the input stream id (local or global)"]
    pub input_stream_id: u32,
    #[doc = "< bitfield of changed fields since last call"]
    pub change_mask: u64,
    #[doc = "< the state of the link"]
    pub state: pw_endpoint_link_state,
    #[doc = "< error string if state == ERROR"]
    pub error: *mut ::std::os::raw::c_char,
    #[doc = "< extra properties"]
    pub props: *mut spa_dict,
    #[doc = "< parameters"]
    pub params: *mut spa_param_info,
    #[doc = "< number of items in \\a params"]
    pub n_params: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_endpoint_link_info"][::std::mem::size_of::<pw_endpoint_link_info>() - 80usize];
    ["Alignment of pw_endpoint_link_info"]
        [::std::mem::align_of::<pw_endpoint_link_info>() - 8usize];
    ["Offset of field: pw_endpoint_link_info::version"]
        [::std::mem::offset_of!(pw_endpoint_link_info, version) - 0usize];
    ["Offset of field: pw_endpoint_link_info::id"]
        [::std::mem::offset_of!(pw_endpoint_link_info, id) - 4usize];
    ["Offset of field: pw_endpoint_link_info::session_id"]
        [::std::mem::offset_of!(pw_endpoint_link_info, session_id) - 8usize];
    ["Offset of field: pw_endpoint_link_info::output_endpoint_id"]
        [::std::mem::offset_of!(pw_endpoint_link_info, output_endpoint_id) - 12usize];
    ["Offset of field: pw_endpoint_link_info::output_stream_id"]
        [::std::mem::offset_of!(pw_endpoint_link_info, output_stream_id) - 16usize];
    ["Offset of field: pw_endpoint_link_info::input_endpoint_id"]
        [::std::mem::offset_of!(pw_endpoint_link_info, input_endpoint_id) - 20usize];
    ["Offset of field: pw_endpoint_link_info::input_stream_id"]
        [::std::mem::offset_of!(pw_endpoint_link_info, input_stream_id) - 24usize];
    ["Offset of field: pw_endpoint_link_info::change_mask"]
        [::std::mem::offset_of!(pw_endpoint_link_info, change_mask) - 32usize];
    ["Offset of field: pw_endpoint_link_info::state"]
        [::std::mem::offset_of!(pw_endpoint_link_info, state) - 40usize];
    ["Offset of field: pw_endpoint_link_info::error"]
        [::std::mem::offset_of!(pw_endpoint_link_info, error) - 48usize];
    ["Offset of field: pw_endpoint_link_info::props"]
        [::std::mem::offset_of!(pw_endpoint_link_info, props) - 56usize];
    ["Offset of field: pw_endpoint_link_info::params"]
        [::std::mem::offset_of!(pw_endpoint_link_info, params) - 64usize];
    ["Offset of field: pw_endpoint_link_info::n_params"]
        [::std::mem::offset_of!(pw_endpoint_link_info, n_params) - 72usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_session {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_endpoint {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_endpoint_stream {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_endpoint_link {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_session_events {
    #[doc = "< version of this structure"]
    pub version: u32,
    #[doc = " Notify session info\n\n \\param info info about the session"]
    pub info: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, info: *const pw_session_info),
    >,
    #[doc = " Notify a session param\n\n Event emitted as a result of the enum_params method.\n\n \\param seq the sequence number of the request\n \\param id the param id\n \\param index the param index\n \\param next the param index of the next param\n \\param param the parameter"]
    pub param: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            seq: ::std::os::raw::c_int,
            id: u32,
            index: u32,
            next: u32,
            param: *const spa_pod,
        ),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_session_events"][::std::mem::size_of::<pw_session_events>() - 24usize];
    ["Alignment of pw_session_events"][::std::mem::align_of::<pw_session_events>() - 8usize];
    ["Offset of field: pw_session_events::version"]
        [::std::mem::offset_of!(pw_session_events, version) - 0usize];
    ["Offset of field: pw_session_events::info"]
        [::std::mem::offset_of!(pw_session_events, info) - 8usize];
    ["Offset of field: pw_session_events::param"]
        [::std::mem::offset_of!(pw_session_events, param) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_session_methods {
    #[doc = "< version of this structure"]
    pub version: u32,
    pub add_listener: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            listener: *mut spa_hook,
            events: *const pw_session_events,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Subscribe to parameter changes\n\n Automatically emit param events for the given ids when\n they are changed.\n\n \\param ids an array of param ids\n \\param n_ids the number of ids in \\a ids\n\n This requires X permissions."]
    pub subscribe_params: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            ids: *mut u32,
            n_ids: u32,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Enumerate session parameters\n\n Start enumeration of session parameters. For each param, a\n param event will be emitted.\n\n \\param seq a sequence number returned in the reply\n \\param id the parameter id to enumerate\n \\param start the start index or 0 for the first param\n \\param num the maximum number of params to retrieve\n \\param filter a param filter or NULL\n\n This requires X permissions."]
    pub enum_params: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            seq: ::std::os::raw::c_int,
            id: u32,
            start: u32,
            num: u32,
            filter: *const spa_pod,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Set a parameter on the session\n\n \\param id the parameter id to set\n \\param flags extra parameter flags\n \\param param the parameter to set\n\n This requires X and W permissions."]
    pub set_param: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            id: u32,
            flags: u32,
            param: *const spa_pod,
        ) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_session_methods"][::std::mem::size_of::<pw_session_methods>() - 40usize];
    ["Alignment of pw_session_methods"][::std::mem::align_of::<pw_session_methods>() - 8usize];
    ["Offset of field: pw_session_methods::version"]
        [::std::mem::offset_of!(pw_session_methods, version) - 0usize];
    ["Offset of field: pw_session_methods::add_listener"]
        [::std::mem::offset_of!(pw_session_methods, add_listener) - 8usize];
    ["Offset of field: pw_session_methods::subscribe_params"]
        [::std::mem::offset_of!(pw_session_methods, subscribe_params) - 16usize];
    ["Offset of field: pw_session_methods::enum_params"]
        [::std::mem::offset_of!(pw_session_methods, enum_params) - 24usize];
    ["Offset of field: pw_session_methods::set_param"]
        [::std::mem::offset_of!(pw_session_methods, set_param) - 32usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_endpoint_events {
    #[doc = "< version of this structure"]
    pub version: u32,
    #[doc = " Notify endpoint info\n\n \\param info info about the endpoint"]
    pub info: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, info: *const pw_endpoint_info),
    >,
    #[doc = " Notify a endpoint param\n\n Event emitted as a result of the enum_params method.\n\n \\param seq the sequence number of the request\n \\param id the param id\n \\param index the param index\n \\param next the param index of the next param\n \\param param the parameter"]
    pub param: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            seq: ::std::os::raw::c_int,
            id: u32,
            index: u32,
            next: u32,
            param: *const spa_pod,
        ),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_endpoint_events"][::std::mem::size_of::<pw_endpoint_events>() - 24usize];
    ["Alignment of pw_endpoint_events"][::std::mem::align_of::<pw_endpoint_events>() - 8usize];
    ["Offset of field: pw_endpoint_events::version"]
        [::std::mem::offset_of!(pw_endpoint_events, version) - 0usize];
    ["Offset of field: pw_endpoint_events::info"]
        [::std::mem::offset_of!(pw_endpoint_events, info) - 8usize];
    ["Offset of field: pw_endpoint_events::param"]
        [::std::mem::offset_of!(pw_endpoint_events, param) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_endpoint_methods {
    #[doc = "< version of this structure"]
    pub version: u32,
    pub add_listener: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            listener: *mut spa_hook,
            events: *const pw_endpoint_events,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Subscribe to parameter changes\n\n Automatically emit param events for the given ids when\n they are changed.\n\n \\param ids an array of param ids\n \\param n_ids the number of ids in \\a ids\n\n This requires X permissions."]
    pub subscribe_params: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            ids: *mut u32,
            n_ids: u32,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Enumerate endpoint parameters\n\n Start enumeration of endpoint parameters. For each param, a\n param event will be emitted.\n\n \\param seq a sequence number returned in the reply\n \\param id the parameter id to enumerate\n \\param start the start index or 0 for the first param\n \\param num the maximum number of params to retrieve\n \\param filter a param filter or NULL\n\n This requires X permissions."]
    pub enum_params: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            seq: ::std::os::raw::c_int,
            id: u32,
            start: u32,
            num: u32,
            filter: *const spa_pod,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Set a parameter on the endpoint\n\n \\param id the parameter id to set\n \\param flags extra parameter flags\n \\param param the parameter to set\n\n This requires X and W permissions."]
    pub set_param: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            id: u32,
            flags: u32,
            param: *const spa_pod,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Create a link\n\n This requires X permissions."]
    pub create_link: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            props: *const spa_dict,
        ) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_endpoint_methods"][::std::mem::size_of::<pw_endpoint_methods>() - 48usize];
    ["Alignment of pw_endpoint_methods"][::std::mem::align_of::<pw_endpoint_methods>() - 8usize];
    ["Offset of field: pw_endpoint_methods::version"]
        [::std::mem::offset_of!(pw_endpoint_methods, version) - 0usize];
    ["Offset of field: pw_endpoint_methods::add_listener"]
        [::std::mem::offset_of!(pw_endpoint_methods, add_listener) - 8usize];
    ["Offset of field: pw_endpoint_methods::subscribe_params"]
        [::std::mem::offset_of!(pw_endpoint_methods, subscribe_params) - 16usize];
    ["Offset of field: pw_endpoint_methods::enum_params"]
        [::std::mem::offset_of!(pw_endpoint_methods, enum_params) - 24usize];
    ["Offset of field: pw_endpoint_methods::set_param"]
        [::std::mem::offset_of!(pw_endpoint_methods, set_param) - 32usize];
    ["Offset of field: pw_endpoint_methods::create_link"]
        [::std::mem::offset_of!(pw_endpoint_methods, create_link) - 40usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_endpoint_stream_events {
    #[doc = "< version of this structure"]
    pub version: u32,
    #[doc = " Notify endpoint stream info\n\n \\param info info about the endpoint stream"]
    pub info: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            info: *const pw_endpoint_stream_info,
        ),
    >,
    #[doc = " Notify a endpoint stream param\n\n Event emitted as a result of the enum_params method.\n\n \\param seq the sequence number of the request\n \\param id the param id\n \\param index the param index\n \\param next the param index of the next param\n \\param param the parameter"]
    pub param: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            seq: ::std::os::raw::c_int,
            id: u32,
            index: u32,
            next: u32,
            param: *const spa_pod,
        ),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_endpoint_stream_events"]
        [::std::mem::size_of::<pw_endpoint_stream_events>() - 24usize];
    ["Alignment of pw_endpoint_stream_events"]
        [::std::mem::align_of::<pw_endpoint_stream_events>() - 8usize];
    ["Offset of field: pw_endpoint_stream_events::version"]
        [::std::mem::offset_of!(pw_endpoint_stream_events, version) - 0usize];
    ["Offset of field: pw_endpoint_stream_events::info"]
        [::std::mem::offset_of!(pw_endpoint_stream_events, info) - 8usize];
    ["Offset of field: pw_endpoint_stream_events::param"]
        [::std::mem::offset_of!(pw_endpoint_stream_events, param) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_endpoint_stream_methods {
    #[doc = "< version of this structure"]
    pub version: u32,
    pub add_listener: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            listener: *mut spa_hook,
            events: *const pw_endpoint_stream_events,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Subscribe to parameter changes\n\n Automatically emit param events for the given ids when\n they are changed.\n\n \\param ids an array of param ids\n \\param n_ids the number of ids in \\a ids\n\n This requires X permissions."]
    pub subscribe_params: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            ids: *mut u32,
            n_ids: u32,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Enumerate stream parameters\n\n Start enumeration of stream parameters. For each param, a\n param event will be emitted.\n\n \\param seq a sequence number returned in the reply\n \\param id the parameter id to enumerate\n \\param start the start index or 0 for the first param\n \\param num the maximum number of params to retrieve\n \\param filter a param filter or NULL\n\n This requires X permissions."]
    pub enum_params: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            seq: ::std::os::raw::c_int,
            id: u32,
            start: u32,
            num: u32,
            filter: *const spa_pod,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Set a parameter on the stream\n\n \\param id the parameter id to set\n \\param flags extra parameter flags\n \\param param the parameter to set\n\n This requires X and W permissions."]
    pub set_param: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            id: u32,
            flags: u32,
            param: *const spa_pod,
        ) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_endpoint_stream_methods"]
        [::std::mem::size_of::<pw_endpoint_stream_methods>() - 40usize];
    ["Alignment of pw_endpoint_stream_methods"]
        [::std::mem::align_of::<pw_endpoint_stream_methods>() - 8usize];
    ["Offset of field: pw_endpoint_stream_methods::version"]
        [::std::mem::offset_of!(pw_endpoint_stream_methods, version) - 0usize];
    ["Offset of field: pw_endpoint_stream_methods::add_listener"]
        [::std::mem::offset_of!(pw_endpoint_stream_methods, add_listener) - 8usize];
    ["Offset of field: pw_endpoint_stream_methods::subscribe_params"]
        [::std::mem::offset_of!(pw_endpoint_stream_methods, subscribe_params) - 16usize];
    ["Offset of field: pw_endpoint_stream_methods::enum_params"]
        [::std::mem::offset_of!(pw_endpoint_stream_methods, enum_params) - 24usize];
    ["Offset of field: pw_endpoint_stream_methods::set_param"]
        [::std::mem::offset_of!(pw_endpoint_stream_methods, set_param) - 32usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_endpoint_link_events {
    #[doc = "< version of this structure"]
    pub version: u32,
    #[doc = " Notify endpoint link info\n\n \\param info info about the endpoint link"]
    pub info: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, info: *const pw_endpoint_link_info),
    >,
    #[doc = " Notify a endpoint link param\n\n Event emitted as a result of the enum_params method.\n\n \\param seq the sequence number of the request\n \\param id the param id\n \\param index the param index\n \\param next the param index of the next param\n \\param param the parameter"]
    pub param: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            seq: ::std::os::raw::c_int,
            id: u32,
            index: u32,
            next: u32,
            param: *const spa_pod,
        ),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_endpoint_link_events"][::std::mem::size_of::<pw_endpoint_link_events>() - 24usize];
    ["Alignment of pw_endpoint_link_events"]
        [::std::mem::align_of::<pw_endpoint_link_events>() - 8usize];
    ["Offset of field: pw_endpoint_link_events::version"]
        [::std::mem::offset_of!(pw_endpoint_link_events, version) - 0usize];
    ["Offset of field: pw_endpoint_link_events::info"]
        [::std::mem::offset_of!(pw_endpoint_link_events, info) - 8usize];
    ["Offset of field: pw_endpoint_link_events::param"]
        [::std::mem::offset_of!(pw_endpoint_link_events, param) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_endpoint_link_methods {
    #[doc = "< version of this structure"]
    pub version: u32,
    pub add_listener: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            listener: *mut spa_hook,
            events: *const pw_endpoint_link_events,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Subscribe to parameter changes\n\n Automatically emit param events for the given ids when\n they are changed.\n\n \\param ids an array of param ids\n \\param n_ids the number of ids in \\a ids\n\n This requires X permissions."]
    pub subscribe_params: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            ids: *mut u32,
            n_ids: u32,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Enumerate link parameters\n\n Start enumeration of link parameters. For each param, a\n param event will be emitted.\n\n \\param seq a sequence number returned in the reply\n \\param id the parameter id to enumerate\n \\param start the start index or 0 for the first param\n \\param num the maximum number of params to retrieve\n \\param filter a param filter or NULL\n\n This requires X permissions."]
    pub enum_params: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            seq: ::std::os::raw::c_int,
            id: u32,
            start: u32,
            num: u32,
            filter: *const spa_pod,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Set a parameter on the link\n\n \\param id the parameter id to set\n \\param flags extra parameter flags\n \\param param the parameter to set\n\n This requires X and W permissions."]
    pub set_param: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            id: u32,
            flags: u32,
            param: *const spa_pod,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Request a state on the link.\n\n This requires X and W permissions."]
    pub request_state: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            state: pw_endpoint_link_state,
        ) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_endpoint_link_methods"]
        [::std::mem::size_of::<pw_endpoint_link_methods>() - 48usize];
    ["Alignment of pw_endpoint_link_methods"]
        [::std::mem::align_of::<pw_endpoint_link_methods>() - 8usize];
    ["Offset of field: pw_endpoint_link_methods::version"]
        [::std::mem::offset_of!(pw_endpoint_link_methods, version) - 0usize];
    ["Offset of field: pw_endpoint_link_methods::add_listener"]
        [::std::mem::offset_of!(pw_endpoint_link_methods, add_listener) - 8usize];
    ["Offset of field: pw_endpoint_link_methods::subscribe_params"]
        [::std::mem::offset_of!(pw_endpoint_link_methods, subscribe_params) - 16usize];
    ["Offset of field: pw_endpoint_link_methods::enum_params"]
        [::std::mem::offset_of!(pw_endpoint_link_methods, enum_params) - 24usize];
    ["Offset of field: pw_endpoint_link_methods::set_param"]
        [::std::mem::offset_of!(pw_endpoint_link_methods, set_param) - 32usize];
    ["Offset of field: pw_endpoint_link_methods::request_state"]
        [::std::mem::offset_of!(pw_endpoint_link_methods, request_state) - 40usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_client_endpoint {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_client_endpoint_events {
    #[doc = "< version of this structure"]
    pub version: u32,
    #[doc = " Sets the session id of the \\a endpoint.\n\n On endpoints that are not session masters, this method notifies\n the implementation that it has been associated with a session.\n The implementation is obliged to set this id in the\n #struct pw_endpoint_info \\a session_id field.\n\n \\param endpoint a #pw_endpoint\n \\param id the session id associated with this endpoint\n\n \\return 0 on success\n         -EINVAL when the session id has already been set\n         -ENOTSUP when the endpoint is a session master"]
    pub set_session_id: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            session_id: u32,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Set the configurable parameter in \\a endpoint.\n\n Usually, \\a param will be obtained from enum_params and then\n modified but it is also possible to set another spa_pod\n as long as its keys and types match a supported object.\n\n Objects with property keys that are not known are ignored.\n\n This function must be called from the main thread.\n\n \\param endpoint a #struct pw_endpoint\n \\param id the parameter id to configure\n \\param flags additional flags\n \\param param the parameter to configure\n\n \\return 0 on success\n         -EINVAL when \\a endpoint is NULL\n         -ENOTSUP when there are no parameters implemented on \\a endpoint\n         -ENOENT the parameter is unknown"]
    pub set_param: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            id: u32,
            flags: u32,
            param: *const spa_pod,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Set a parameter on \\a stream_id of \\a endpoint.\n\n When \\a param is NULL, the parameter will be unset.\n\n This function must be called from the main thread.\n\n \\param endpoint a #struct pw_endpoint\n \\param stream_id the stream to configure\n \\param id the parameter id to set\n \\param flags optional flags\n \\param param a #struct spa_pod with the parameter to set\n \\return 0 on success\n         1 on success, the value of \\a param might have been\n                changed depending on \\a flags and the final value can\n                be found by doing stream_enum_params.\n         -EINVAL when \\a endpoint is NULL or invalid arguments are given\n         -ESRCH when the type or size of a property is not correct.\n         -ENOENT when the param id is not found"]
    pub stream_set_param: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            stream_id: u32,
            id: u32,
            flags: u32,
            param: *const spa_pod,
        ) -> ::std::os::raw::c_int,
    >,
    pub create_link: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            props: *const spa_dict,
        ) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_client_endpoint_events"]
        [::std::mem::size_of::<pw_client_endpoint_events>() - 40usize];
    ["Alignment of pw_client_endpoint_events"]
        [::std::mem::align_of::<pw_client_endpoint_events>() - 8usize];
    ["Offset of field: pw_client_endpoint_events::version"]
        [::std::mem::offset_of!(pw_client_endpoint_events, version) - 0usize];
    ["Offset of field: pw_client_endpoint_events::set_session_id"]
        [::std::mem::offset_of!(pw_client_endpoint_events, set_session_id) - 8usize];
    ["Offset of field: pw_client_endpoint_events::set_param"]
        [::std::mem::offset_of!(pw_client_endpoint_events, set_param) - 16usize];
    ["Offset of field: pw_client_endpoint_events::stream_set_param"]
        [::std::mem::offset_of!(pw_client_endpoint_events, stream_set_param) - 24usize];
    ["Offset of field: pw_client_endpoint_events::create_link"]
        [::std::mem::offset_of!(pw_client_endpoint_events, create_link) - 32usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_client_endpoint_methods {
    #[doc = "< version of this structure"]
    pub version: u32,
    pub add_listener: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            listener: *mut spa_hook,
            events: *const pw_client_endpoint_events,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Update endpoint information"]
    pub update: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            change_mask: u32,
            n_params: u32,
            params: *mut *const spa_pod,
            info: *const pw_endpoint_info,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Update stream information"]
    pub stream_update: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            stream_id: u32,
            change_mask: u32,
            n_params: u32,
            params: *mut *const spa_pod,
            info: *const pw_endpoint_stream_info,
        ) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_client_endpoint_methods"]
        [::std::mem::size_of::<pw_client_endpoint_methods>() - 32usize];
    ["Alignment of pw_client_endpoint_methods"]
        [::std::mem::align_of::<pw_client_endpoint_methods>() - 8usize];
    ["Offset of field: pw_client_endpoint_methods::version"]
        [::std::mem::offset_of!(pw_client_endpoint_methods, version) - 0usize];
    ["Offset of field: pw_client_endpoint_methods::add_listener"]
        [::std::mem::offset_of!(pw_client_endpoint_methods, add_listener) - 8usize];
    ["Offset of field: pw_client_endpoint_methods::update"]
        [::std::mem::offset_of!(pw_client_endpoint_methods, update) - 16usize];
    ["Offset of field: pw_client_endpoint_methods::stream_update"]
        [::std::mem::offset_of!(pw_client_endpoint_methods, stream_update) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_client_session {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_client_session_events {
    #[doc = "< version of this structure"]
    pub version: u32,
    #[doc = " Set the configurable parameter in \\a session.\n\n Usually, \\a param will be obtained from enum_params and then\n modified but it is also possible to set another spa_pod\n as long as its keys and types match a supported object.\n\n Objects with property keys that are not known are ignored.\n\n This function must be called from the main thread.\n\n \\param session a #struct pw_session\n \\param id the parameter id to configure\n \\param flags additional flags\n \\param param the parameter to configure\n\n \\return 0 on success\n         -EINVAL when \\a session is NULL\n         -ENOTSUP when there are no parameters implemented on \\a session\n         -ENOENT the parameter is unknown"]
    pub set_param: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            id: u32,
            flags: u32,
            param: *const spa_pod,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Set a parameter on \\a link_id of \\a session.\n\n When \\a param is NULL, the parameter will be unset.\n\n This function must be called from the main thread.\n\n \\param session a #struct pw_session\n \\param link_id the link to configure\n \\param id the parameter id to set\n \\param flags optional flags\n \\param param a #struct spa_pod with the parameter to set\n \\return 0 on success\n         1 on success, the value of \\a param might have been\n                changed depending on \\a flags and the final value can\n                be found by doing link_enum_params.\n         -EINVAL when \\a session is NULL or invalid arguments are given\n         -ESRCH when the type or size of a property is not correct.\n         -ENOENT when the param id is not found"]
    pub link_set_param: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            link_id: u32,
            id: u32,
            flags: u32,
            param: *const spa_pod,
        ) -> ::std::os::raw::c_int,
    >,
    pub link_request_state: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            link_id: u32,
            state: u32,
        ) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_client_session_events"]
        [::std::mem::size_of::<pw_client_session_events>() - 32usize];
    ["Alignment of pw_client_session_events"]
        [::std::mem::align_of::<pw_client_session_events>() - 8usize];
    ["Offset of field: pw_client_session_events::version"]
        [::std::mem::offset_of!(pw_client_session_events, version) - 0usize];
    ["Offset of field: pw_client_session_events::set_param"]
        [::std::mem::offset_of!(pw_client_session_events, set_param) - 8usize];
    ["Offset of field: pw_client_session_events::link_set_param"]
        [::std::mem::offset_of!(pw_client_session_events, link_set_param) - 16usize];
    ["Offset of field: pw_client_session_events::link_request_state"]
        [::std::mem::offset_of!(pw_client_session_events, link_request_state) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_client_session_methods {
    #[doc = "< version of this structure"]
    pub version: u32,
    pub add_listener: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            listener: *mut spa_hook,
            events: *const pw_client_session_events,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Update session information"]
    pub update: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            change_mask: u32,
            n_params: u32,
            params: *mut *const spa_pod,
            info: *const pw_session_info,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Update link information"]
    pub link_update: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            link_id: u32,
            change_mask: u32,
            n_params: u32,
            params: *mut *const spa_pod,
            info: *const pw_endpoint_link_info,
        ) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_client_session_methods"]
        [::std::mem::size_of::<pw_client_session_methods>() - 32usize];
    ["Alignment of pw_client_session_methods"]
        [::std::mem::align_of::<pw_client_session_methods>() - 8usize];
    ["Offset of field: pw_client_session_methods::version"]
        [::std::mem::offset_of!(pw_client_session_methods, version) - 0usize];
    ["Offset of field: pw_client_session_methods::add_listener"]
        [::std::mem::offset_of!(pw_client_session_methods, add_listener) - 8usize];
    ["Offset of field: pw_client_session_methods::update"]
        [::std::mem::offset_of!(pw_client_session_methods, update) - 16usize];
    ["Offset of field: pw_client_session_methods::link_update"]
        [::std::mem::offset_of!(pw_client_session_methods, link_update) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __va_list_tag"][::std::mem::size_of::<__va_list_tag>() - 24usize];
    ["Alignment of __va_list_tag"][::std::mem::align_of::<__va_list_tag>() - 8usize];
    ["Offset of field: __va_list_tag::gp_offset"]
        [::std::mem::offset_of!(__va_list_tag, gp_offset) - 0usize];
    ["Offset of field: __va_list_tag::fp_offset"]
        [::std::mem::offset_of!(__va_list_tag, fp_offset) - 4usize];
    ["Offset of field: __va_list_tag::overflow_arg_area"]
        [::std::mem::offset_of!(__va_list_tag, overflow_arg_area) - 8usize];
    ["Offset of field: __va_list_tag::reg_save_area"]
        [::std::mem::offset_of!(__va_list_tag, reg_save_area) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_pod_builder {
    pub _address: u8,
}
